Overall Concept (3)
1. Root Node (User Prompt)
    * The user starts by typing a prompt (e.g., “Design the interface for a 1000-floor elevator”).
    * This prompt becomes the root node on the Main Canvas, the trunk of a tree from which all subsequent branches (questions) extend.
2. AI-Powered Question Generation (via gpt-4-0125-preview)
    * After initial preferences (like conflict and unknown handling) are set, the AI dynamically generates follow-up questions.
    * It references prior answers and any uploaded knowledge base (elevator guidelines, building specs) to decide which child nodes (sub-branches) to create.
    * Early questions are intentionally basic—for instance, “Is the elevator primarily for humans or for machinery?”—to clarify fundamental requirements before going deeper.
3. Breadth-First or Depth-First Q&A
    * The user chooses one of two traversal modes:
        1. Breadth-First: The system completes all siblings at the current “layer” before revealing children.
        2. Depth-First: The system immediately drills down into child nodes of the just-answered question, postponing siblings until that branch is finished.
    * Sequential Question Generation: In either mode, a new question (whether a sibling or child) is generated only after the user answers the current question.
    * Pruning & Conflict Resolution: The AI may prune paths if an updated answer invalidates them or silently fix minor conflicts if auto-resolve is chosen.
4. Stopping Criteria & Generation
    * The user can cap the total number of questions (e.g., “Stop after 20”), prompting a mockup.
    * Alternatively, the AI decides when it has enough info to produce a final design.
    * Upon Q&A completion, the system consolidates everything into a requirements doc and React/Tailwind code for a working prototype.

Step 1: Initial Setup & Prompt Node
1. Enter the Prompt
    * The user types, “Design the interface for a 1000-floor elevator.”
    * Labeled on the Main Canvas as “Prompt: 1000-floor elevator” (the root node).
2. Optional Knowledge Base Upload
    * If users upload relevant documents (codes, guidelines), the AI may auto-populate answers where it’s confident.
    * No knowledge base = no auto-populate.
3. Unknown & Conflict Handling (AI Settings)
    * Unknowns:
        * Auto (trivial): The AI guesses minor data gaps (e.g., kiosk color).
        * Always prompt: The user addresses every unknown. Major unknowns (like safety codes) always require explicit confirmation.
    * Conflicts:
        * Auto-resolve minor: The AI quietly fixes small contradictions by pruning the less critical node.
        * Manual resolution: All conflicts appear in the Q&A Panel. Major ones always prompt the user.
4. Breadth-First or Depth-First Q&A Selection
    * The user picks which traversal method:
        * Breadth-First: Finish all top-level siblings before revealing child nodes.
        * Depth-First: Immediately dive into a parent’s children (recursively) before returning to siblings.
5. Question Limit or AI-Determined Stop
    * The user can limit total questions (e.g., 20) or let the AI decide.
    * Once confirmed, the root node is finalized on the Main Canvas.

Step 2: Interactive Q&A Flow (AI-Driven)
2.1. The Root Node & First Questions
* Main Canvas: Shows the root node (user’s prompt).
* Right-Hand Q&A Panel: A “Begin Q&A” button triggers gpt-4-0125-preview.
* AI Question Generation:
    * The AI spawns initial top-level questions (e.g., Q1, Q2, Q3) based on the user’s prompt/knowledge base.
    * Example:
        * Q1: “Is the elevator primarily for humans or machinery?”
        * Q2: “What is the total number of floors?”
        * Q3: “Any known budget constraints?”
2.2. Q&A Progression (Breadth vs. Depth)
2.2.1. One Question at a Time
* The system never shows Q2 until Q1 is answered, never shows Q3 until Q2 is answered, etc.
* Each child node (Q4, Q5) only appears after the user finishes its parent’s question (Q1).
2.2.2. Breadth-First Mode
1. Layer-by-Layer
    * The user completes all siblings at the current level: Q1, Q2, Q3.
    * Only then does the system reveal each sibling’s child nodes: Q4, Q5 for Q1; Q6, Q7 for Q2; Q8 for Q3, etc.
2. Recursive BFS
    * Once the user addresses the children of Q1 (layer 2), it moves on to the children of Q2, then Q3, etc., each layer fully before the next.
    * This continues until no more nodes remain at any depth, completing a classic BFS traversal.
2.2.3. Depth-First Mode
1. Go Deep Immediately
    * After Q1 is answered, the system immediately spawns Q1’s children (Q4, Q5).
    * The user answers Q4, then if Q4 has further children (Q6, Q7), the system spawns them. This goes on until Q4’s entire subtree is done.
2. Then Next Sibling
    * The user returns to Q5 (the other child of Q1). If Q5 spawns more children (Q8, Q9), those get answered before returning up the branch to Q2.
    * This continues until each branch is fully explored, a classic DFS traversal.
2.2.4. New Top-Level Branches
* The AI may discover or the user may request a new major domain mid-flow.
* Three ways new top-level nodes arise:
    1. User-Initiated (“What about signage?”).
    2. AI-Detected Mid-Flow (e.g., advanced security domain).
    3. Post-Completion (final check after finishing all known questions).
* By default, these new top-level questions remain queued until the current layer or branch is done—unless the user/AI marks it urgent.

2.3. Conflict & Unknown Resolution (AI Assistance)
1. Conflict Detection
    * The AI checks each new answer for contradictions vs. previous answers or the knowledge base.
2. Minor Conflicts (Auto-Resolve)
    * If enabled, small clashes (e.g., color preferences) are silently fixed by adjusting or pruning the less critical node.
    * Example: The user changed kiosk color from “Green” to “Light Green” halfway through. The AI picks one and removes the other reference.
3. Major Conflicts (Always Prompt)
    * If the conflict is fundamental (e.g., code compliance), the system prompts the user:
        * “Floors above 500 must have advanced voice commands, but voice recognition hardware is disallowed. Please reconcile.”
4. Unknown Fields
    * Trivial Unknown (Auto-Mode): AI guesses, marking it as “AI-guessed.”
    * Major Unknown: The user must provide data (child nodes don’t appear until resolved).
    * If “Always prompt,” no auto-fills occur; the user addresses every gap manually.

2.4. Revisiting & Editing Answers
* Clicking an Answered Node
    * The user can revisit Q2, changing its answer. The system re-checks Q2’s children to see if they remain valid.
* Pruning & Replacement
    * If the new answer invalidates old children, those nodes are pruned. If the updated answer triggers different logic, the system spawns fresh child questions.
* Cross-Branch Conflicts
    * If Q2’s edit contradicts Q7 in a different branch, the system decides if it’s minor or major. Minor = auto-fix if enabled; major = user must pick which node stands.

2.5. Stopping & Additional Inquiries
1. Max Questions Reached
    * If the user set “Stop after 20,” the system says, “20 questions reached. Generate a mockup now or continue?”
2. AI Decides
    * If no cap is set, once the AI believes it has enough data, it asks if the user wants to generate or keep asking more.
3. User-Initiated Topics
    * The user can at any point say, “Give me more detail on accessibility,” spawning new sub-branches or top-level nodes if relevant.

Step 3: Consolidate & Generate
3.1. Requirements Document
* AI Compilation:
    * The system compiles all final answers (Q1–QX), system assumptions, any auto-resolved conflicts, and “AI-guessed” unknowns.
* Preview & Download:
    * The user can view it on-screen, then export as PDF, DOCX, or Markdown.
3.2. Prototype UI Code (React/Tailwind)
* Code Generation:
    * The AI creates a sandboxed React + Tailwind (or HTML/CSS) mockup reflecting the final, resolved design.
    * The user can preview the layout—elevator panel, kiosk interface, etc.
* Copy/Export:
    * A “Copy Code” button enables quick integration into another environment.
    * An “Export to Figma” option can feed design tokens into a Figma plugin.
3.3. Multiple Versions
* Generate Another Version:
    * If desired, the user can generate alternative UI designs (styles, layouts).
    * They can create multiple versions and switch among them for comparison.
3.4. Save for Later
* Session Preservation:
    * The system can save the entire Q&A session (prompt, answers, auto-populated data, conflict resolutions, design previews).
* Local vs. Server Storage:
    * Locally (e.g., localStorage) or on the server if user accounts exist.
* Metadata & Session Management:
    * Each session gets a name, timestamp, progress. A “My Sessions” dashboard allows resuming, renaming, or deleting saved sessions.
* Auto-Save & Manual Save:
    * The system periodically auto-saves and allows manual “Save.” If the user leaves, it warns or auto-saves.

Interface Layout Summary
1. Main Canvas (Center)
    * Root Node (Prompt): The user’s typed question.
    * Top-Level Questions (Q1, Q2, Q3): Branches from the root.
    * Child Nodes (Q4, Q5, etc.): Appear beneath a parent question.
    * Visual Indicators: Conflict icons for major contradictions, auto-filled icons for AI guesses.
2. Right-Hand Q&A Panel
    * Always open, showing the current question.
    * Displays AI-generated prompts, conflict/unknown alerts, resolution options.
    * “Auto-Populate” if knowledge base data is sufficient.
3. Header / Toolbar (Top)
    * Steps: (1) Setup, (2) Q&A, (3) Generate.
    * A progress indicator (e.g., “X / Y answered”).
    * A knowledge base status icon (if docs are uploaded).
4. Generation/Preview Area
    * After Q&A concludes, the user sees a Requirements Doc Preview and a React/Tailwind sandbox.
    * Tools for doc download, copying code, or exporting to design platforms (like Figma).

Graph Impact Summary
1. Overridden Nodes & Children from Conflicts
    * In auto-resolve mode, the AI prunes less critical nodes.
    * Major conflicts prompt user choice. The losing path is removed.
2. Unknown Answers & Children
    * Auto-mode guesses trivial unknowns (marked “AI-guessed”).
    * Major unknowns block subsequent child nodes until user input is provided.
3. Editing a Parent Node & Branch Replacement
    * If a parent answer changes, old children might be pruned.
    * Fresh children appear if the new logic differs.
    * Branches removed by conflict override only reappear if the user changes the relevant answer again.
4. Cross-Branch Conflicts from Edited Nodes
    * If editing Q2 contradicts Q7 in another branch, minor vs. major rules apply.
    * Minor = silent fix (if enabled), major = user picks which node stands.

Why This Flow Works
1. Prompt as Anchor
    * The user’s main design goal—like “1000-floor elevator”—remains central.
2. Configurable Q&A Traversal
    * Users pick breadth-first (layer by layer) or depth-first (fully explore one branch, then move on). Both are handled recursively and generate subsequent questions sequentially.
3. Sequential Question Generation
    * Prevents overload: The system spawns a new question (sibling or child) only after the current one is answered.
4. Granular Unknown/Conflict Settings
    * Streamlines minor gaps or contradictions, flags major ones for user oversight.
5. Flexible Stopping
    * Either a fixed question limit or AI-based determination of “enough” data.
6. Requirements & Live Prototype
    * Produces both a requirements document and a React/Tailwind mockup from the final Q&A data.
7. Multiple Versions & Saved Sessions
    * Rapid iteration with different designs, plus the ability to pause/resume seamlessly.
By explicitly recursing through questions in breadth-first or depth-first fashion—and only generating each new question after the current one is answered—this system ensures a clear Q&A flow. It can handle large, complex designs (like a 1000-floor elevator) while gracefully managing conflicts, unknowns, and newly discovered top-level topics.