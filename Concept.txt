Overall Concept
1. Root Node (User Prompt)
    * The user starts by typing a prompt (e.g., “Design the interface for a 1000-floor elevator”).
    * This prompt becomes the root node on the Main Canvas, the trunk of a tree from which all subsequent branches (questions) extend.
2. AI-Powered Question Generation (via gpt-4-0125-preview)
    * After initial preferences (like conflict and unknown handling) are set, the AI dynamically generates follow-up questions.
    * It references prior answers and any uploaded knowledge base (elevator guidelines, building specs) to decide which child nodes (sub-branches) to create.
    * Early questions are intentionally basic—“Is the elevator primarily for humans or for machinery?”—to clarify fundamental requirements before diving deeper.
3. Breadth-First or Depth-First Q&A
    * The user chooses one of two traversal modes:
        1. Breadth-First: The system completes all siblings at the current “layer” before revealing children.
        2. Depth-First: The system immediately drills down into child nodes of the just-answered question, postponing siblings until that branch is finished.
    * Sequential Question Generation: In either mode, a new question (whether a sibling or child) is generated only after the user answers the current question.
    * Pruning & Conflict Resolution: The AI may prune paths if an updated answer invalidates them or silently fix minor conflicts if auto-resolve is chosen.
4. Stopping Criteria & Generation
    * The user can cap the total number of questions (e.g., “Stop after 20”), prompting a mockup.
    * Alternatively, the AI decides when it has enough info to produce a final design.
    * Upon Q&A completion, the system consolidates everything into a requirements doc and React/Tailwind code for a working prototype.

Step 1: Initial Setup & Prompt Node
1. Enter the Prompt
    * The user types: “Design the interface for a 1000-floor elevator.”
    * Labeled on the Main Canvas as “Prompt: 1000-floor elevator” (the root node).
2. Optional Knowledge Base Upload
    * If users upload relevant documents (building specs, guidelines), the AI may auto-populate certain answers.
    * No knowledge base = no auto-populate option.
3. Unknown & Conflict Handling (AI Settings)
    * Unknowns:
        * Auto (trivial): The AI guesses minor data gaps (e.g., kiosk color).
        * Always prompt: The user addresses every unknown. Major unknowns (like safety codes) always require explicit confirmation.
    * Conflicts:
        * Auto-resolve minor: The AI quietly fixes small contradictions by pruning the less critical node.
        * Manual resolution: All conflicts appear in the Q&A Panel. Major ones always prompt the user.
4. Breadth-First or Depth-First Q&A Selection
    * The user picks which traversal method:
        * Breadth-First: Finish all top-level siblings before revealing child nodes.
        * Depth-First: Immediately dive into a parent’s children (recursively) before returning to siblings.
5. Question Limit or AI-Determined Stop
    * The user can limit total questions (e.g., 20) or let the AI decide.
    * Once confirmed, the root node is finalized on the Main Canvas.

Step 2: Interactive Q&A Flow (AI-Driven)
2.1. The Root Node & First Questions
* Main Canvas: Shows the root node (user’s prompt).
* Right-Hand Q&A Panel: A “Begin Q&A” button triggers gpt-4-0125-preview.
* AI Question Generation:
    * The AI spawns initial top-level questions (e.g., Q1, Q2, Q3) based on the user’s prompt/knowledge base.
    * For example:
        * Q1: “Is the elevator primarily for humans or machinery?”
        * Q2: “What is the total number of floors?”
        * Q3: “Any known budget constraints?”
2.2. Q&A Progression (Breadth vs. Depth)
2.2.1. One Question at a Time
* The system never shows the next question until the current one is answered.
* Child nodes (e.g., Q4, Q5) appear only after the user finishes Q1.
2.2.2. Breadth-First Mode (Example)
1. Layer-by-Layer
    * Suppose the system’s first top-level set is Q1, Q2, Q3. The user answers them in order (Q1 → Q2 → Q3).
    * Only after Q1, Q2, Q3 are done do their children appear:
        * Q4, Q5 might be children of Q1,
        * Q6, Q7 might be children of Q2,
        * Q8 might be a child of Q3.
2. Recursive BFS
    * After finishing Q4, Q5 (children of Q1), the system moves to Q6, Q7 (children of Q2), then Q8 (child of Q3).
    * If Q4 spawns more children (Q9, Q10), those appear in the same BFS layer, after Q4 is answered but before moving on to Q2’s children.
    * The important point is siblings are always handled at the same layer—before revealing the next layer’s children.
    * Example BFS-Like Numbering: Q1, Q2, Q3 as siblings. Then Q4, Q5 (children of Q1), Q6, Q7 (children of Q2), Q8 (child of Q3). Next, Q9, Q10 (children of Q4), Q11, Q12 (children of Q5), etc.
2.2.3. Depth-First Mode (Example)
1. Go Deep Immediately
    * The user answers Q1 first.
    * Instead of seeing Q2 and Q3 (siblings) right away, the system spawns Q1’s children (Q4, Q5).
    * Q2 might not appear until much later—potentially labeled something like Q17 by the time we return to the “root” level.
2. Fully Exploring Each Branch
    * After answering Q4, if Q4 spawns Q6, Q7, you finish those. Then move on to Q5 (the other child of Q1).
    * Only after completing the entire subtree under Q1 does the system “come back up” to show Q2.
    * Example DFS-Like Numbering: Q1 → Q4, Q5 (children of Q1). Q4 might spawn Q6, Q7. That entire chain is resolved before Q5. Once Q5 is done, we finally see Q2 (which could be Q17 if the AI introduced many nodes under Q4, Q5 first).
3. Recursive DFS
    * Each node’s children appear immediately after that node is answered, exploring that branch first.
    * Siblings (like “Q2 and Q3 at the root level”) might appear later or have a higher question label if the system introduced many child nodes in between.
2.2.4. New Top-Level Branches
* If the AI uncovers (or the user requests) a new major domain mid-flow, it creates a new top-level node.
* Three ways these arise:
    1. User-Initiated: “What about signage?”
    2. AI-Detected: The AI sees advanced security is needed.
    3. Post-Completion: A final check after all known Q’s.
* By default, these new top-level Q’s are queued until the current layer or branch is done—unless deemed urgent by user/AI.

2.3. Conflict & Unknown Resolution (AI Assistance)
1. Conflict Detection
    * Each new answer is checked for contradictions vs. previous answers or knowledge-base references.
2. Minor Conflicts (Auto-Resolve)
    * If enabled, trivial mismatches (e.g., color preferences) are silently fixed.
3. Major Conflicts (Always Prompt)
    * If a conflict is fundamental (e.g., code compliance), the system prompts the user to reconcile.
4. Unknown Fields
    * Trivial Unknown (Auto): The AI guesses, labeling it “AI-guessed.”
    * Major Unknown: The user must supply data; child nodes won’t appear until resolved.
    * “Always prompt” means no auto-fills occur.

2.4. Revisiting & Editing Answers
* Clicking an Answered Node
    * The user can revisit, say Q2, and change its answer. The system re-checks Q2’s children or conflicts.
* Pruning & Replacement
    * If a new parent answer invalidates old children, they’re pruned. If the updated logic triggers new children, they appear.
* Cross-Branch Conflicts
    * If changing Q2 contradicts Q7 in a different branch, the system checks if it’s minor or major. Minor = silent fix (if enabled), major = user picks which node stands.

2.5. Stopping & Additional Inquiries
1. Max Questions Reached
    * If the user set “Stop after 20,” the system says, “20 questions reached—generate a mockup or continue?”
2. AI Decides
    * If no limit, once the AI believes enough data is collected, it asks if the user wants to finalize.
3. User-Initiated Topics
    * At any time, the user can say “Explain accessibility in detail,” spawning new nodes or top-level questions if needed.

Step 3: Consolidate & Generate
3.1. Requirements Document
* AI Compilation:
    * The system compiles all final answers (Q1–QX), plus assumptions, conflicts, and AI guesses.
* Preview & Download:
    * The user can see the doc on-screen, then export as PDF, DOCX, or Markdown.
3.2. Prototype UI Code (React/Tailwind)
* Code Generation:
    * The AI outputs React + Tailwind (or HTML/CSS), letting the user preview an elevator kiosk/panel with specified features.
* Copy/Export:
    * A “Copy Code” button enables quick integration.
    * “Export to Figma” for design iteration.
3.3. Multiple Versions
* Generate Another Version:
    * If desired, the user can create alternative design styles or layouts.
    * They can produce multiple versions and toggle among them.
3.4. Save for Later
* Session Preservation:
    * The system saves the entire Q&A (root prompt, answers, conflicts, design previews).
* Local vs. Server:
    * Data can be stored locally or on a server if user accounts exist.
* Metadata & Session Management:
    * Each session has a name, timestamp, and progress. A “My Sessions” list lets users resume, rename, or delete.
* Auto-Save & Manual Save:
    * The system auto-saves periodically; a manual “Save” is available. If the user leaves, it warns or auto-saves.

Interface Layout Summary
1. Main Canvas (Center)
    * Root Node (Prompt): “1000-floor elevator,” from which top-level questions branch.
    * Child Nodes (Q4, Q5, etc.): Appear beneath each answered parent.
    * Visual Indicators: Conflict icons, auto-fill icons for knowledge-base guesses.
2. Right-Hand Q&A Panel
    * Always open, showing the current question.
    * Displays AI-generated prompts, conflicts/unknown alerts, resolution options.
    * “Auto-Populate” if relevant knowledge base data exists.
3. Header / Toolbar (Top)
    * Steps: (1) Setup, (2) Q&A, (3) Generate.
    * A progress bar (e.g., “X / Y answered”).
    * Knowledge Base status icon.
4. Generation/Preview Area
    * After Q&A, shows a Requirements Doc Preview and a React/Tailwind sandbox.
    * Tools for doc download, copying code, or exporting to design platforms.

Graph Impact Summary
1. Overridden Nodes & Children from Conflicts
    * Auto-resolve minor conflicts prunes/adjusts. Major prompts user choice.
2. Unknown Answers & Children
    * Auto-mode guesses trivial unknowns. Major unknowns block child nodes until resolved.
3. Editing a Parent Node & Branch Replacement
    * Updating a parent’s answer can prune old children, possibly spawning fresh ones.
    * Branches removed by conflict override only reappear if the relevant answer changes again.
4. Cross-Branch Conflicts
    * If Q2’s edit contradicts Q7 in another branch, minor=auto-fix if enabled, major=user must choose.

Why This Flow Works
1. Prompt as Anchor
    * Keeps the user’s main design goal—like a 1000-floor elevator—central.
2. Configurable Q&A Traversal
    * Users pick breadth-first (Q2 is truly a top-level sibling) or depth-first (Q2 might become a “child” or appear later, say Q17), ensuring each path is traversed recursively in a structured manner.
3. Sequential Question Generation
    * The system spawns each new question only after the current one is answered, preventing user overload.
4. Granular Unknown/Conflict Settings
    * Minor issues are auto-fixed if desired; major ones always prompt user choice.
5. Flexible Stopping
    * Either a question cap or the AI’s sense of “enough data” triggers final mockup generation.
6. Requirements & Live Prototype
    * Produces a comprehensive requirements document and a functional React/Tailwind mockup.
7. Multiple Versions & Saved Sessions
    * Allows iterative design changes and the ability to pause/resume Q&A at will.
