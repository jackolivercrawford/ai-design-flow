Codebase Tree Structure:
========================
AI-DESIGN-FLOW
  ├── .next
  │   └── ... (contents hidden)
  ├── app
  │   ├── api
  │   │   ├── generate-mockup
  │   │   │   └── route.ts
  │   │   ├── generate-questions
  │   │   │   └── route.ts
  │   │   ├── process-knowledge-base
  │   │   │   └── route.ts
  │   │   └── update-requirements
  │   │       └── route.ts
  │   ├── preview
  │   │   └── page.tsx
  │   ├── qna
  │   │   └── page.tsx
  │   ├── favicon.ico
  │   ├── globals.css
  │   ├── layout.tsx
  │   └── page.tsx
  ├── components
  │   ├── Canvas.tsx
  │   ├── CanvasTree.tsx
  │   ├── HeaderToolbar.tsx
  │   ├── LivePreview.tsx
  │   ├── PreviewArea.tsx
  │   ├── PreviewPanel.tsx
  │   ├── PromptInput.tsx
  │   └── QAPanel.tsx
  ├── node_modules
  │   └── ... (contents hidden)
  ├── public
  │   ├── file.svg
  │   ├── globe.svg
  │   ├── next.svg
  │   ├── vercel.svg
  │   └── window.svg
  ├── types
  │   ├── index.ts
  │   ├── pdf-parse.d.ts
  │   └── settings.ts
  ├── .env.local
  ├── .gitignore
  ├── codebase.txt
  ├── Concept.txt
  ├── eslint.config.mjs
  ├── generateCodebase.js
  ├── next-env.d.ts
  ├── next.config.ts
  ├── package-lock.json
  ├── package.json
  ├── postcss.config.mjs
  ├── README.md
  ├── tailwind.config.ts
  └── tsconfig.json


File Contents:
==============

----- /Users/jackcrawford/ai-design-flow/app/api/generate-mockup/route.ts -----
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { RequirementsDocument, RequirementCategory } from '@/types';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(request: NextRequest) {
  try {
    const { requirementsDoc } = await request.json();
    
    if (!requirementsDoc) {
      return NextResponse.json(
        { error: 'Requirements document is required' },
        { status: 400 }
      );
    }

    // Format requirements for the prompt
    const formattedRequirements = Object.entries(requirementsDoc.categories as Record<string, RequirementCategory>)
      .map(([key, category]) => {
        const reqs = category.requirements
          .map(req => `- ${req.text} (${req.priority} priority)`)
          .join('\n');
        return `${category.title}:\n${reqs}`;
      })
      .join('\n\n');

    // Check requirements size
    const promptText = `Design Prompt: ${requirementsDoc.prompt}\n\nRequirements:\n${formattedRequirements}`;
    const estimatedTokens = promptText.split(/\s+/).length; // Rough estimation
    if (estimatedTokens > 2000) {
      return NextResponse.json(
        { error: 'Requirements document is too large. Please reduce the number of requirements or split into multiple requests.' },
        { status: 400 }
      );
    }

    const completion = await openai.chat.completions.create({
      model: "o3-mini",
      messages: [
        {
          role: "system",
          content: `You are an expert UI developer who creates React components with Tailwind CSS. Your task is to generate a beautiful, modern, and functional mockup based on the provided requirements and return it as a JSON object.

Guidelines:
1. Use only React and Tailwind CSS (no external libraries)
2. Follow modern design principles and best practices
3. Ensure the UI is responsive and accessible
4. Include comments explaining key design decisions
5. Structure the code in a clean, maintainable way
6. Use semantic HTML elements
7. Include hover states and transitions
8. Implement proper spacing and hierarchy
9. Use a consistent color scheme
10. Include proper TypeScript types

CRITICAL REQUIREMENTS:
1. The code MUST implement ALL features mentioned in the requirements
2. Each requirement should be traceable to specific UI elements or functionality
3. The color scheme should be carefully chosen to match the application's purpose
4. Components should be modular and reusable
5. All interactive elements must have proper ARIA labels and roles
6. Error states, loading states, and success states must be handled
7. The interface must be fully responsive
8. All user inputs must be validated
9. Emergency and critical functions must be easily accessible
10. Real-time updates and status changes must be clearly visible

The code must be a complete, working React component that:
1. Includes all necessary imports at the top
2. Defines all required TypeScript interfaces
3. Implements a main component that uses the interfaces
4. Uses React hooks (useState, useEffect) for state management
5. Includes all event handlers and UI interactions
6. Has proper error handling and loading states
7. Uses the provided color scheme consistently
8. Implements all features from the requirements
9. Has proper ARIA labels and accessibility features
10. Exports the main component as default

Example structure:
\`\`\`tsx
import React, { useState, useEffect } from 'react';

interface ComponentProps {
  // prop definitions
}

interface ComponentState {
  // state definitions
}

function MainComponent() {
  const [state, setState] = useState<ComponentState>({});
  
  useEffect(() => {
    // side effects
  }, []);

  const handleEvent = () => {
    // event handling
  };

  return (
    <div>
      {/* component JSX */}
    </div>
  );
}

export default MainComponent;
\`\`\`

Return your response in this exact JSON format:
{
  "code": "Complete React/Tailwind component code as shown in the example above",
  "colorScheme": {
    "primary": "hex color (should be suitable for main actions and headers)",
    "secondary": "hex color (should be suitable for supporting elements)",
    "accent": "hex color (should be suitable for attention-grabbing elements)",
    "background": "hex color (should be suitable for the main background)",
    "text": "hex color (should be suitable for main text content)"
  },
  "components": [
    "Detailed list of all reusable components created, with their purposes"
  ],
  "features": [
    "Comprehensive list of all implemented features, matching the requirements"
  ],
  "nextSteps": [
    "List of suggested improvements or additions for future iterations"
  ]
}`
        },
        {
          role: "user",
          content: `Design Prompt: ${requirementsDoc.prompt}

Requirements (MUST ALL BE IMPLEMENTED):
${formattedRequirements}

Generate a complete React/Tailwind mockup that satisfies ALL these requirements. The mockup should be immediately usable and include all necessary types and styling. Each requirement should be reflected in the implementation.`
        }
      ],
      max_completion_tokens: 16000,
      response_format: { type: "json_object" },
      reasoning_effort: 'medium'
    });

    const content = completion.choices[0].message.content;
    if (!content) {
      throw new Error('Empty response from OpenAI');
    }

    try {
      const mockupData = JSON.parse(content);
      return NextResponse.json(mockupData);
    } catch (parseError) {
      console.error('Error parsing mockup data:', parseError);
      return NextResponse.json(
        { error: 'Failed to parse mockup data' },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error('Error generating mockup:', error);
    return NextResponse.json(
      { error: 'Failed to generate mockup' },
      { status: 500 }
    );
  }
} 

----- /Users/jackcrawford/ai-design-flow/app/api/generate-questions/route.ts -----
// /app/api/generate-questions/route.ts
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { KnowledgeBaseSource } from '@/types/settings';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(request: NextRequest) {
  try {
    const { prompt, previousQuestions, traversalMode, knowledgeBase, isAutoPopulate, currentQuestion, depth, parentContext } = await request.json();
    console.log('API received knowledge base:', knowledgeBase);

    // Calculate current depth by counting parents in previousQuestions
    let currentDepth = 0;
    let currentParent = previousQuestions[previousQuestions.length - 1];
    while (currentParent?.parent) {
      currentDepth++;
      currentParent = currentParent.parent;
    }

    // Format knowledge base content for the prompt
    const knowledgeBaseContext = knowledgeBase?.length 
      ? `The following information is available from multiple knowledge base sources:

${knowledgeBase.map((source: KnowledgeBaseSource, index: number) => `
Source ${index + 1} (${source.type === 'file' ? 'File' : 'Text'}: ${source.name}):
Requirements: ${JSON.stringify(source.processedContent?.requirements || [])}
Technical Specs: ${JSON.stringify(source.processedContent?.technicalSpecifications || [])}
Design Guidelines: ${JSON.stringify(source.processedContent?.designGuidelines || [])}
User Preferences: ${JSON.stringify(source.processedContent?.userPreferences || [])}
Industry Standards: ${JSON.stringify(source.processedContent?.industryStandards || [])}
`).join('\n')}

Use this information to:
- Auto-populate answers when confident (especially when multiple sources agree)
- Guide question generation based on available information
- Identify gaps that need to be filled
- Validate answers against known constraints
- Highlight any conflicts between different sources`
      : 'No knowledge base provided.';

    console.log('Formatted knowledge base context:', knowledgeBaseContext);

    const completion = await openai.chat.completions.create({
      model: 'o3-mini',
      messages: [
        {
          role: 'system',
          content: isAutoPopulate 
            ? `You are an expert UX design assistant that helps suggest answers based on the knowledge base and context. Your task is to provide a well-reasoned answer to the current question and return it as a JSON object.

Knowledge Base Context:
${knowledgeBaseContext}

Previous Questions Already Asked:
${previousQuestions.map((q: { question: string; answer: string }, index: number) => 
  `${index + 1}. Q: ${q.question}\n   A: ${q.answer}`
).join('\n')}

Guidelines for suggesting answers:
1. Focus ONLY on answering the current question
2. Use information from the knowledge base when available
3. Write answers in third person, making definitive statements
4. Avoid second person pronouns (your, you, yours) entirely
5. State suggestions as definitive facts that can be modified
6. Avoid hedging words like "might", "could", "probably", "likely", "maybe"
7. Make clear, direct suggestions even with low confidence
8. If multiple knowledge base sources agree, use that information with high confidence
9. If sources conflict, use the most relevant or recent information
10. If no relevant information exists, provide a reasonable suggestion based on UX best practices

Return your response in this JSON format:
{
  "questions": [],
  "shouldStopBranch": false,
  "stopReason": "",
  "suggestedAnswer": "Your suggested answer here",
  "sourceReferences": [array of source indices that contributed],
  "confidence": "high" | "medium" | "low"
}`
            : `You are an expert UX design assistant that helps generate follow-up questions for a design prompt. Your task is to generate ONE follow-up question based on the traversal mode and return it as a JSON object.

${parentContext ? `
Current Parent Question Context:
- Parent Question: "${parentContext.parentQuestion}"
- Parent Answer: "${parentContext.parentAnswer}"
- Parent Topics: ${JSON.stringify(parentContext.parentTopics)}

CRITICAL: The generated question MUST:
1. Be more specific than the parent question
2. Focus on a specific aspect mentioned in the parent's answer
3. Not repeat information already covered in the parent's answer
4. Ask for implementation details or specific requirements about topics mentioned in the parent's answer
` : ''}

Follow these guidelines:
1. Question Progression Levels:
   Current Depth: ${depth}/5
   
   BFS Mode Levels:
   - Level 1 (Basic Needs): Broad, fundamental questions about purpose, audience, and core requirements
     Example: "What is the fundamental purpose of the portfolio website?"
   - Level 2 (Features): Main sections and key features, but not specifics yet
     Example: "What main sections should be included in the navigation?"
   - Level 3 (Details): Specific details about each feature/section identified in level 2
     Example: "What project details should be displayed in each portfolio item?"
   - Level 4 (Refinements): Technical specifications and implementation details
     Example: "What image formats and sizes should be supported for project thumbnails?"
   - Level 5 (Polish): Edge cases and final refinements
     Example: "How should the portfolio handle projects with missing images?"

2. Child Question Generation Rules:
   - Child questions MUST be more specific than their parent question
   - Child questions MUST explore a specific aspect mentioned in the parent's answer
   - NEVER ask the same question as the parent with slightly different wording
   - Example progression:
     Parent Q: "What sections should the portfolio include?"
     Parent A: "The portfolio should include a projects section, about me, skills, and contact."
     Valid child Q: "What specific project details should be displayed in the projects section?"
     Invalid child Q: "What content should be included in the portfolio?"

3. Traversal Rules (${traversalMode}):
   ${traversalMode === 'bfs' 
     ? `BFS Guidelines:
        - At Level 1: Generate at least 3-4 broad, fundamental questions before going deeper
        - Each level should be more specific than the last
        - Questions at the same level should cover different aspects
        - Example progression:
          Level 1: "Who is the target audience?"
          Level 2: "What main navigation sections are needed?"
          Level 3: "What information should appear in the project cards?"
          Level 4: "What should happen when a project card is clicked?"`
     : `DFS Guidelines:
        - Start with a broad topic
        - Each follow-up should be more specific about that topic
        - Example progression:
          Q1: "What project showcase features are needed?"
          Q2: "How should individual project details be displayed?"
          Q3: "What specific project metrics should be highlighted?"
          Q4: "How should project success metrics be visualized?"`
   }

4. Topic Management:
   - Each level should be distinctly more specific than the previous
   - Questions should build upon previous answers
   - Avoid repeating topics already covered
   - Use previous answers to inform specificity
   - Child questions must explore specific aspects mentioned in parent's answer

5. Question Generation:
   - Generate exactly ONE question
   - Make it specific and focused
   - Include clear parent-child relationships
   - Maintain proper depth progression
   - Follow numbering conventions per mode
   - For child questions:
     * Extract key topics/features from parent's answer
     * Ask about specific implementation details of those topics
     * Focus on one specific aspect rather than broad concepts
     * Ensure the question couldn't be answered by the parent's answer

6. Stopping Criteria:
   - Stop current branch if:
     * Topic is fully explored (all aspects covered)
     * Further questions would be too specific
     * A different topic needs attention
     * Knowledge base provides sufficient information
     * The question would be redundant with parent's answer

7. Knowledge Base Context:
${knowledgeBaseContext}

8. Previous Questions Already Asked:
${previousQuestions.map((q: { question: string; answer: string }, index: number) => 
  `${index + 1}. Q: ${q.question}\n   A: ${q.answer}`
).join('\n')}

9. Response Format:
Return your response in this exact JSON format:
{
  "questions": ["Next question to ask"],
  "shouldStopBranch": boolean,
  "stopReason": "Detailed explanation of why we should stop this branch",
  "suggestedAnswer": "string with best guess answer based on knowledge base",
  "sourceReferences": [array of source indices that contributed],
  "confidence": "high" | "medium" | "low",
  "topicsCovered": ["list of topics this question relates to"],
  "parentTopic": "The main topic this question belongs to",
  "subtopics": ["Potential child topics for this question"]
}`
        },
        {
          role: 'user',
          content: isAutoPopulate
            ? `The design prompt is: "${prompt}"

Current Question: "${currentQuestion}"

Based on the knowledge base and previous Q&A context:
1. Analyze the knowledge base for relevant information about this specific question
2. Consider the context from previous questions and answers
3. Provide a clear, direct answer following the guidelines
4. Indicate which knowledge base sources (if any) contributed to the answer
5. Rate your confidence in the answer as high/medium/low

Return your response in this format:
{
  "questions": [],
  "shouldStopBranch": false,
  "stopReason": "",
  "suggestedAnswer": "Your suggested answer here",
  "sourceReferences": [array of source indices that contributed],
  "confidence": "high" | "medium" | "low"
}`
            : `The design prompt is: "${prompt}".
Previous Q&A History:
${JSON.stringify(previousQuestions, null, 2)}

Current Question: ${previousQuestions[previousQuestions.length - 1]?.question || 'Initial question'}

CRITICAL REQUIREMENTS:
1. Review ALL previous questions and their topics carefully
2. Generate ONE question that explores a COMPLETELY DIFFERENT aspect not covered in ANY previous question
3. For BFS mode, ensure the new question:
   - Stays at the same level
   - Covers a new topic not related to any previous questions
   - Follows the level-specific topic guidelines
4. Provide a suggested answer following the guidelines

Topics already covered (DO NOT ask about these or related topics):
${previousQuestions.map((q: { question: string }, index: number) => 
  `${index + 1}. ${q.question}`
).join('\n')}

Remember:
- NEVER repeat a topic that's been covered in previous questions
- Each new question must explore a different aspect of the design
- In BFS mode, stay at the current level but explore new topics
- Make clear, direct statements in suggested answers
- Never use second person pronouns`
        }
      ],
      max_completion_tokens: 4000,
      response_format: { type: "json_object" },
      reasoning_effort: 'medium'
    });

    const content = completion.choices[0].message.content?.trim();
    if (!content) {
      console.error('Empty response from OpenAI');
      // Return a default response instead of throwing
      return NextResponse.json({
        questions: ["What are the core features needed for this design?"],
        shouldStopBranch: false,
        stopReason: "",
        suggestedAnswer: null,
        sourceReferences: [],
        confidence: "low",
        topicsCovered: ["core_features"],
        parentTopic: "requirements",
        subtopics: []
      });
    }

    console.log('Raw OpenAI response:', content);

    let response: {
      questions: string[];
      shouldStopBranch: boolean;
      stopReason: string;
      suggestedAnswer: string | null;
      sourceReferences: number[];
      confidence?: 'high' | 'medium' | 'low';
      topicsCovered: string[];
      parentTopic: string;
      subtopics: string[];
    };

    try {
      // First try to parse the JSON response
      response = JSON.parse(content);
      
      // Ensure required fields exist with defaults
      response = {
        questions: Array.isArray(response.questions) ? response.questions : [response.questions || "What are the core features needed for this design?"],
        shouldStopBranch: response.shouldStopBranch || false,
        stopReason: response.stopReason || "",
        suggestedAnswer: response.suggestedAnswer || null,
        sourceReferences: response.sourceReferences || [],
        confidence: response.confidence || "low",
        topicsCovered: response.topicsCovered || [],
        parentTopic: response.parentTopic || "requirements",
        subtopics: response.subtopics || []
      };

      // Clean up questions to ensure they're plain text
      response.questions = response.questions.map((q: any) => {
        if (typeof q === 'string') return q;
        return q.question || q.text || JSON.stringify(q);
      }).filter(Boolean);

      // If no valid questions after cleanup, provide a default
      if (response.questions.length === 0) {
        response.questions = ["What are the core features needed for this design?"];
      }

      console.log('Formatted response:', response);
      return NextResponse.json(response);
    } catch (jsonError) {
      console.error("Error parsing API response:", jsonError);
      console.error("Raw content causing parse error:", content);
      
      // Try to extract a valid question from the partial response
      let extractedQuestion = "What are the core features needed for this design?";
      try {
        const questionMatch = content.match(/"questions":\s*\[\s*"([^"]+)"/);
        if (questionMatch && questionMatch[1]) {
          extractedQuestion = questionMatch[1];
        }
      } catch (e) {
        console.error("Failed to extract question from partial response");
      }
      
      // Provide a default response using any extracted data
      return NextResponse.json({
        questions: [extractedQuestion],
        shouldStopBranch: false,
        stopReason: "",
        suggestedAnswer: null,
        sourceReferences: [],
        confidence: "low",
        topicsCovered: ["core_features"],
        parentTopic: "requirements",
        subtopics: []
      });
    }
  } catch (error) {
    console.error('Error generating questions:', error);
    return NextResponse.json(
      { error: 'Failed to generate questions' },
      { status: 500 }
    );
  }
}


----- /Users/jackcrawford/ai-design-flow/app/api/process-knowledge-base/route.ts -----
import { NextRequest } from 'next/server';
import OpenAI from 'openai';
import pdfParse from 'pdf-parse';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

async function extractTextFromPDF(buffer: Buffer): Promise<string> {
  try {
    const data = await pdfParse(buffer);
    return data.text;
  } catch (error) {
    console.error('Error extracting text from PDF:', error);
    throw new Error('Failed to extract text from PDF');
  }
}

async function processContent(content: string) {
  try {
    console.log('Starting content processing...');
    const completion = await openai.chat.completions.create({
      model: "o3-mini",
      messages: [
        {
          role: "system",
          content: `You are a knowledge base processor. Extract key information from the provided document and return it as a JSON object. Focus on:
1. Requirements and constraints
2. Technical specifications
3. Design guidelines
4. User preferences or patterns
5. Industry standards or best practices

Return your response in this exact JSON format:
{
  "requirements": [],
  "technicalSpecifications": [],
  "designGuidelines": [],
  "userPreferences": [],
  "industryStandards": []}`
        },
        {
          role: "user",
          content
        }
      ],
      max_completion_tokens: 4000,
      response_format: { type: "json_object" },
      reasoning_effort: 'medium'
    });

    console.log('OpenAI response received');
    const responseContent = completion.choices[0].message.content;
    if (!responseContent) {
      console.error('Empty response content from OpenAI');
      throw new Error('Empty response from OpenAI');
    }

    try {
      const parsedContent = JSON.parse(responseContent);
      console.log('Successfully parsed OpenAI response');
      return parsedContent;
    } catch (parseError) {
      console.error('Error parsing OpenAI response:', parseError, '\nResponse content:', responseContent);
      throw new Error('Failed to parse OpenAI response');
    }
  } catch (error) {
    console.error('Error in processContent:', error);
    if (error instanceof Error) {
      throw new Error(`Failed to process content: ${error.message}`);
    }
    throw new Error('Failed to process content: Unknown error');
  }
}

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const sourceType = formData.get('type');
    const file = formData.get('file');
    const textContent = formData.get('content');

    if (!sourceType) {
      return new Response(JSON.stringify({ error: 'Source type is required' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    let content: string;

    if (sourceType === 'file' && file) {
      // Check if the file has arrayBuffer method (indicating it's a File or Blob)
      const fileObject = file as { arrayBuffer(): Promise<ArrayBuffer>; type?: string; name?: string };
      
      if ('arrayBuffer' in fileObject && typeof fileObject.arrayBuffer === 'function') {
        const buffer = Buffer.from(await fileObject.arrayBuffer());
        
        // Check file type using the file's type property or name
        const fileType = fileObject.type || '';
        const fileName = fileObject.name || '';
        
        if (fileType === 'application/pdf' || fileName.toLowerCase().endsWith('.pdf')) {
          content = await extractTextFromPDF(buffer);
        } else {
          // For text files, convert buffer to string
          content = buffer.toString('utf-8');
        }
      } else {
        throw new Error('Invalid file format');
      }
    } else if (sourceType === 'text' && typeof textContent === 'string') {
      content = textContent;
    } else {
      return new Response(JSON.stringify({ error: 'Invalid input' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    const processedContent = await processContent(content);

    return new Response(JSON.stringify({ success: true, processedContent }), {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
    });

  } catch (error: unknown) {
    console.error('Error in API route:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
    return new Response(JSON.stringify({ error: 'Internal server error', details: errorMessage }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
} 

----- /Users/jackcrawford/ai-design-flow/app/api/update-requirements/route.ts -----
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { RequirementsDocument, QANode, RequirementCategory } from '@/types';
import { KnowledgeBaseSource } from '@/types/settings';
import { v4 as uuidv4 } from 'uuid';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

function findNodeById(root: QANode | null, id: string): QANode | null {
  if (!root) return null;
  if (root.id === id) return root;
  for (const child of root.children) {
    const found = findNodeById(child, id);
    if (found) return found;
  }
  return null;
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    console.log('Received update request:', body);
    
    const { qaTree, currentNodeId, knowledgeBase, existingDocument } = body;
    
    if (!qaTree || !existingDocument) {
      return NextResponse.json(
        { error: 'QA Tree and existing document are required' },
        { status: 400 }
      );
    }
    
    // Find the current node that was just answered
    const currentNode = currentNodeId ? findNodeById(qaTree, currentNodeId) : null;
    
    // Format the Q&A history and knowledge base for the AI
    const qaContext = JSON.stringify({
      question: currentNode?.question || 'No current question',
      answer: currentNode?.answer || 'No answer',
      previousQuestions: qaTree.children.map((node: QANode) => ({
        question: node.question,
        answer: node.answer
      }))
    }, null, 2);

    const knowledgeBaseContext = knowledgeBase?.length
      ? knowledgeBase.map((source: KnowledgeBaseSource, index: number) => 
          `Source ${index + 1}: ${Object.entries(source.processedContent || {})
            .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
            .join('\n')}`
        ).join('\n\n')
      : 'No knowledge base provided';

    console.log('Sending to OpenAI:', {
      qaContext: qaContext.substring(0, 100) + '...',
      knowledgeBaseContext: knowledgeBaseContext.substring(0, 100) + '...'
    });

    const completion = await openai.chat.completions.create({
      model: "o3-mini",
      messages: [
        {
          role: "system",
          content: `You are a requirements document updater. Your task is to update a requirements document based on Q&A session information and knowledge base data and return it as a JSON object.

CRITICAL INSTRUCTIONS:
1. You MUST return ONLY a valid JSON object.
2. DO NOT include any explanatory text, markdown, or other content.
3. DO NOT wrap the JSON in code blocks or quotes.
4. The JSON must exactly match this structure:
{
  "id": string,
  "prompt": string,
  "lastUpdated": string (ISO date),
  "categories": {
    "basicNeeds": {
      "title": "Basic Needs",
      "requirements": []
    },
    "functionalRequirements": {
      "title": "Functional Requirements",
      "requirements": []
    },
    "userExperience": {
      "title": "User Experience",
      "requirements": []
    },
    "implementation": {
      "title": "Implementation",
      "requirements": []
    },
    "refinements": {
      "title": "Refinements",
      "requirements": []
    },
    "constraints": {
      "title": "Constraints",
      "requirements": []
    }
  }
}`
        },
        {
          role: "user",
          content: `Current Document: ${JSON.stringify(existingDocument)}
Latest Q&A: ${qaContext}
Knowledge Base: ${knowledgeBaseContext}

Update the requirements document with any new information from the Q&A and knowledge base. Return ONLY the updated document as a JSON object.`
        }
      ],
      max_completion_tokens: 16000,
      response_format: { type: "json_object" },
      reasoning_effort: 'medium'
    });

    const content = completion.choices[0].message.content;
    if (!content) {
      console.error('Empty response from OpenAI');
      console.log('Returning existing document due to empty OpenAI response');
      return NextResponse.json(existingDocument);
    }

    console.log('OpenAI response:', content.substring(0, 100) + '...');

    try {
      const updatedDocument = JSON.parse(content);
      
      // Validate the document structure
      if (!updatedDocument.id || !updatedDocument.categories) {
        console.error('Invalid document structure:', updatedDocument);
        console.log('Returning existing document due to invalid structure');
        return NextResponse.json(existingDocument);
      }
      
      // Helper function to determine requirement category and tags
      function analyzeRequirement(text: string): {
        category: 'functional' | 'technical' | 'ux' | 'accessibility' | 'security' | 'performance';
        tags: string[];
        priority: 'high' | 'medium' | 'low';
      } {
        const textLower = text.toLowerCase();
        let category: 'functional' | 'technical' | 'ux' | 'accessibility' | 'security' | 'performance' = 'functional';
        const tags: string[] = [];
        let priority: 'high' | 'medium' | 'low' = 'medium';

        // Category determination
        if (textLower.includes('security') || textLower.includes('emergency') || textLower.includes('safety')) {
          category = 'security';
          priority = 'high';
          tags.push('safety');
        } else if (textLower.includes('user') || textLower.includes('interface') || textLower.includes('display') || textLower.includes('visual')) {
          category = 'ux';
          tags.push('interface');
        } else if (textLower.includes('performance') || textLower.includes('speed') || textLower.includes('efficiency')) {
          category = 'performance';
          tags.push('optimization');
        } else if (textLower.includes('accessible') || textLower.includes('disability')) {
          category = 'accessibility';
          priority = 'high';
          tags.push('ada-compliance');
        } else if (textLower.includes('technical') || textLower.includes('system') || textLower.includes('integration')) {
          category = 'technical';
          tags.push('integration');
        }

        // Additional tags based on content
        if (textLower.includes('monitor') || textLower.includes('sensor')) {
          tags.push('monitoring');
        }
        if (textLower.includes('data') || textLower.includes('analytics')) {
          tags.push('data');
        }
        if (textLower.includes('ai') || textLower.includes('machine learning')) {
          tags.push('ai');
        }
        if (textLower.includes('maintenance')) {
          tags.push('maintenance');
        }
        if (textLower.includes('real-time') || textLower.includes('realtime')) {
          tags.push('real-time');
        }

        // Priority determination (if not already set by category)
        if (priority === 'medium') {
          if (textLower.includes('critical') || textLower.includes('essential') || textLower.includes('must')) {
            priority = 'high';
          } else if (textLower.includes('optional') || textLower.includes('nice to have')) {
            priority = 'low';
          }
        }

        return { category, tags, priority };
      }

      // Ensure all requirements have proper structure and IDs
      Object.values(updatedDocument.categories).forEach((category: any) => {
        if (Array.isArray(category.requirements)) {
          category.requirements = category.requirements.map((req: string | any) => {
            // If the requirement is just a string, convert it to proper structure
            if (typeof req === 'string') {
              const analysis = analyzeRequirement(req);
              return {
                id: uuidv4(),
                text: req,
                source: 'user-qa',
                priority: analysis.priority,
                category: analysis.category,
                tags: analysis.tags,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
              };
            }
            // If it's already an object but missing ID
            if (!req.id) {
              const analysis = analyzeRequirement(req.text);
              req.id = uuidv4();
              req.priority = req.priority || analysis.priority;
              req.category = req.category || analysis.category;
              req.tags = req.tags || analysis.tags;
              req.createdAt = new Date().toISOString();
              req.updatedAt = new Date().toISOString();
            }
            return req;
          });
        } else {
          category.requirements = [];
        }
      });
      
      // Ensure all required categories exist
      const requiredCategories = [
        'basicNeeds',
        'functionalRequirements',
        'userExperience',
        'implementation',
        'refinements',
        'constraints'
      ];
      
      const hasAllCategories = requiredCategories.every(
        category => updatedDocument.categories[category]
      );
      
      if (!hasAllCategories) {
        console.error('Missing required categories');
        console.log('Returning existing document due to missing categories');
        return NextResponse.json(existingDocument);
      }
      
      return NextResponse.json(updatedDocument);
    } catch (parseError) {
      console.error('Error parsing OpenAI response:', parseError);
      console.error('Raw response:', content);
      // If parsing fails, return the existing document unchanged
      console.log('Returning existing document due to parse error');
      return NextResponse.json(existingDocument);
    }
  } catch (error) {
    console.error('Error updating requirements:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error occurred' },
      { status: 500 }
    );
  }
} 

----- /Users/jackcrawford/ai-design-flow/app/preview/page.tsx -----
'use client';

import { useEffect, useState } from 'react';
import PreviewArea from '@/components/PreviewArea';
import HeaderToolbar from '@/components/HeaderToolbar';

export default function PreviewPage() {
  const [generatedContent, setGeneratedContent] = useState({
    requirements: '',
    uiCode: '',
  });

  useEffect(() => {
    const storedContent = localStorage.getItem('generatedContent');
    if (storedContent) {
      setGeneratedContent(JSON.parse(storedContent));
    }
  }, []);

  return (
    <div className="min-h-screen flex flex-col">
      <HeaderToolbar />
      <main className="flex-1 container mx-auto px-4 py-8">
        <h1 className="text-3xl font-bold mb-8">Generated Preview</h1>
        <PreviewArea
          requirements={generatedContent.requirements}
          uiCode={generatedContent.uiCode}
        />
      </main>
    </div>
  );
}

----- /Users/jackcrawford/ai-design-flow/app/qna/page.tsx -----
// /app/qna/page.tsx
'use client';

import { useEffect, useRef, useState } from 'react';
import { useRouter } from 'next/navigation';
import { v4 as uuidv4 } from 'uuid';
import HeaderToolbar from '../../components/HeaderToolbar';
import QAPanel from '../../components/QAPanel';
import CanvasTree from '../../components/CanvasTree';
import { QANode, RequirementsDocument, MockupVersion, SessionMetadata } from '@/types';
import { QASettings } from '@/types/settings';
import PreviewPanel from '../../components/PreviewPanel';

interface SavedProgress {
  qaTree: QANode;
  currentNodeId: string | null;
  questionCount: number;
  prompt: string;
  settings: QASettings;
  requirementsDoc: RequirementsDocument;
}

interface QuestionHistoryItem {
  question: string;
  answer?: string;
  topics: string[];
}

export default function QnAPage() {
  const router = useRouter();
  const hasFetchedInitialQuestion = useRef(false);
  const [prompt, setPrompt] = useState<string>('');
  const [settings, setSettings] = useState<QASettings | null>(null);
  const [qaTree, setQaTree] = useState<QANode | null>(null);
  const [currentNode, setCurrentNode] = useState<QANode | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isLoadingNextQuestion, setIsLoadingNextQuestion] = useState(false);
  const [questionCount, setQuestionCount] = useState(0);
  const [suggestedAnswer, setSuggestedAnswer] = useState<{
    text: string;
    confidence: 'high' | 'medium' | 'low';
    sourceReferences: number[];
  } | null>(null);
  const [requirementsDoc, setRequirementsDoc] = useState<RequirementsDocument | null>(null);
  const [askedQuestions, setAskedQuestions] = useState<Set<string>>(new Set());
  const [askedTopics, setAskedTopics] = useState<Set<string>>(new Set());
  const [isPreviewOpen, setIsPreviewOpen] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [sessionMetadata, setSessionMetadata] = useState<SessionMetadata | null>(null);
  const [isLeavingPage, setIsLeavingPage] = useState(false);
  const [isInitialLoad, setIsInitialLoad] = useState(true);

  // Helper: Extract topics from a question
  const extractTopics = (question: string): string[] => {
    const topics = [];
    // Common topic indicators in questions
    if (question.toLowerCase().includes('audience') || 
        question.toLowerCase().includes('user') || 
        question.toLowerCase().includes('visitor')) {
      topics.push('audience');
    }
    if (question.toLowerCase().includes('purpose') || 
        question.toLowerCase().includes('goal')) {
      topics.push('purpose');
    }
    // Add more topic extractors as needed
    return topics;
  };

  // Helper: Get the next question based on traversal mode
  const getNextQuestion = async (node: QANode): Promise<QANode | null> => {
    const isDFS = settings?.traversalMode === 'dfs';
    
    if (isDFS) {
      // DFS: Try to go deeper first by exploring the current topic fully
      if (node.answer) {
        // Build complete question history including topics for the current branch
        const branchHistory: QuestionHistoryItem[] = [];
        let current: QANode | null = node;
        let depth = 0;
        
        // Collect the current branch's history and calculate depth
        while (current) {
          if (current.question !== `Prompt: ${prompt}`) {
            branchHistory.unshift({
              question: current.question,
              answer: current.answer,
              topics: extractTopics(current.question)
            });
            depth++;
          }
          const parent = findParentNode(qaTree!, current);
          if (!parent || parent === current) break;
          current = parent;
        }

        // Try to generate a child question that explores the current topic deeper
        const { nodes: children, shouldStopBranch, stopReason } = await fetchQuestionsForNode(
          prompt, 
          node,
          branchHistory,
          depth,
          true // Enable suggestions for follow-up questions
        );
        
        // If the AI suggests stopping this branch, move to siblings
        if (shouldStopBranch) {
          console.log(`Stopping current branch: ${stopReason}`);
          // Find the next sibling at the highest incomplete level
          let searchNode: QANode | null = node;
          while (searchNode) {
            const parent = findParentNode(qaTree!, searchNode);
            if (!parent) break;
            
            const siblings = parent.children;
            const currentIndex = siblings.indexOf(searchNode);
            
            if (currentIndex < siblings.length - 1) {
              return siblings[currentIndex + 1];
            }
            searchNode = parent;
          }
        } 
        // If we got new questions, verify they explore the current topic deeper
        else if (children.length > 0) {
          const newQuestionTopics = extractTopics(children[0].question);
          const currentTopics = extractTopics(node.question);
          
          // Check if the new question is related to the current topic
          const isRelatedTopic = currentTopics.some(topic => 
            newQuestionTopics.includes(topic) || 
            newQuestionTopics.some(t => t.includes(topic))
          );

          if (isRelatedTopic) {
            // Set the question number based on exploration order
            children[0].questionNumber = questionCount + 1;
            node.children = children;
            return children[0];
          } else {
            console.log('Generated question explores unrelated topic, trying siblings instead');
            // Try to find the next sibling that continues the current topic
            const parent = findParentNode(qaTree!, node);
            if (parent) {
              const siblings = parent.children;
              const currentIndex = siblings.indexOf(node);
              if (currentIndex < siblings.length - 1) {
                return siblings[currentIndex + 1];
              }
            }
          }
        }
      }
      
      return null; // No more questions in this branch
      
    } else {
      // BFS: Complete all questions at the current level before going deeper
      const parent = findParentNode(qaTree!, node);
      if (!parent) return null;
      
      // Get all nodes at the current level
      const currentLevelNodes = parent.children;
      const currentIndex = currentLevelNodes.indexOf(node);
      const currentDepth = getNodeDepth(node);
      
      // Build question history for current level
      const levelHistory: QuestionHistoryItem[] = currentLevelNodes.map(n => ({
        question: n.question,
        answer: n.answer,
        topics: extractTopics(n.question)
      }));
      
      // Check if all nodes at current level are answered
      const allCurrentLevelAnswered = currentLevelNodes.every(n => n.answer);
      
      // If there are existing unanswered siblings, move to the next one
      if (currentIndex < currentLevelNodes.length - 1) {
        return currentLevelNodes[currentIndex + 1];
      }
      
      // For top level (depth 1), ensure we have enough broad coverage before going deeper
      // We want at least 3-4 high-level questions answered before considering going deeper
      const isTopLevel = currentDepth === 1;
      const shouldGenerateMoreSiblings = isTopLevel ? 
        currentLevelNodes.length < 4 : // At top level, always try to get at least 4 questions
        !allCurrentLevelAnswered;      // At other levels, generate siblings until all are answered
      
      // Only try to generate new siblings if we haven't completed the current level
      // or if we need more top-level coverage
      if (shouldGenerateMoreSiblings) {
        const { nodes: newSiblings, shouldStopBranch } = await fetchQuestionsForNode(
          prompt,
          parent,
          levelHistory,
          currentDepth,
          true // Enable suggestions for follow-up questions
        );
        
        if (!shouldStopBranch && newSiblings.length > 0) {
          // Set the question number sequentially within the layer
          newSiblings[0].questionNumber = questionCount + 1;
          parent.children = [...currentLevelNodes, ...newSiblings];
          return newSiblings[0];
        }
      }
      
      // Only if ALL nodes at current level are answered AND we have enough top-level coverage,
      // start going deeper
      if (allCurrentLevelAnswered && (!isTopLevel || currentLevelNodes.length >= 3)) {
        // Find the first answered node that doesn't have children yet
        for (const sibling of currentLevelNodes) {
          if (sibling.answer && sibling.children.length === 0) {
            const siblingHistory = levelHistory.filter(h => 
              extractTopics(h.question).some(t => 
                extractTopics(sibling.question).includes(t)
              )
            );
            
            const { nodes: children, shouldStopBranch } = await fetchQuestionsForNode(
              prompt,
              sibling,
              siblingHistory,
              currentDepth + 1,
              true // Enable suggestions for follow-up questions
            );
            
            if (!shouldStopBranch && children.length > 0) {
              // Set the question number sequentially for the next layer
              children[0].questionNumber = questionCount + 1;
              sibling.children = children;
              return children[0];
            }
          }
        }
      }
      
      return null; // No more questions at this level or deeper
    }
  };

  // Helper: Get the depth of a node in the tree
  const getNodeDepth = (node: QANode): number => {
    let depth = 0;
    let current = node;
    while (findParentNode(qaTree!, current)) {
      depth++;
      current = findParentNode(qaTree!, current)!;
    }
    return depth;
  };

  // Helper: Find parent node
  const findParentNode = (root: QANode | null, target: QANode): QANode | null => {
    if (!root) return null;
    if (root.children.includes(target)) return root;
    for (const child of root.children) {
      const found = findParentNode(child, target);
      if (found) return found;
    }
    return null;
  };

  // Helper: Find all nodes at the same level as the target node
  const findNodesAtSameLevel = (root: QANode | null, target: QANode): QANode[] => {
    if (!root) return [];
    const parent = findParentNode(root, target);
    if (!parent) return root.children; // If no parent, must be root level
    return parent.children;
  };

  // Helper: Find the first unanswered child in the tree (BFS)
  const findFirstUnansweredChild = (root: QANode | null): QANode | null => {
    if (!root) return null;
    const queue: QANode[] = [root];
    while (queue.length > 0) {
      const node = queue.shift()!;
      // Skip the root node when looking for unanswered questions
      if (node.children.length > 0) {
        for (const child of node.children) {
          if (!child.answer) return child;
          queue.push(child);
        }
      } else if (!node.answer && node.question !== `Prompt: ${prompt}`) {
        return node;
      }
    }
    return null;
  };

  // Helper: Find the first node that can have children (has answer but no children)
  const findFirstNodeForChildren = (root: QANode | null): QANode | null => {
    if (!root) return null;
    const queue: QANode[] = [root];
    while (queue.length > 0) {
      const node = queue.shift()!;
      // Skip the root node when looking for nodes that can have children
      if (node.answer && node.children.length === 0 && node.question !== `Prompt: ${prompt}`) {
        return node;
      }
      queue.push(...node.children);
    }
    return null;
  };

  // Helper: fetch questions for a node
  const fetchQuestionsForNode = async (designPrompt: string, parentNode: QANode, questionHistory: QuestionHistoryItem[], depth: number, setSuggestion: boolean = false): Promise<{ nodes: QANode[], shouldStopBranch: boolean, stopReason: string, suggestedAnswer?: string }> => {
    try {
      console.log('Fetching questions with knowledge base:', settings?.knowledgeBase);
      
      // Get parent context for child questions
      const parentContext = parentNode.question !== `Prompt: ${designPrompt}` ? {
        parentQuestion: parentNode.question,
        parentAnswer: parentNode.answer,
        parentTopics: extractTopics(parentNode.question)
      } : null;
      
      const response = await fetch('/api/generate-questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt: designPrompt,
          previousQuestions: questionHistory,
          traversalMode: settings?.traversalMode,
          knowledgeBase: settings?.knowledgeBase,
          depth: depth,
          parentContext: parentContext,
          includeSuggestions: setSuggestion // Only request suggestions when needed
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error occurred' }));
        throw new Error(`API request failed: ${errorData.error || response.statusText}`);
      }

      const data = await response.json();
      console.log('Received API response with suggested answer:', data.suggestedAnswer);
      
      if (!data || !Array.isArray(data.questions) || data.questions.length === 0) {
        throw new Error('Invalid response format or no questions received');
      }

      // Only set suggested answer if explicitly requested
      if (setSuggestion) {
        if (data.suggestedAnswer) {
          console.log('Setting suggested answer:', {
            text: data.suggestedAnswer,
            confidence: data.confidence || 'low',
            sourceReferences: data.sourceReferences || []
          });
          
          setSuggestedAnswer({
            text: data.suggestedAnswer,
            confidence: data.confidence || 'low',
            sourceReferences: data.sourceReferences || []
          });
        } else {
          console.log('Clearing suggested answer');
          setSuggestedAnswer(null);
        }
      }
      
      // Create a single child node with the next question number
      const nextQuestionNumber = questionCount + 1;
      const nodes: QANode[] = data.questions.slice(0, 1).map((q: string) => ({
        id: uuidv4(),
        question: q,
        children: [],
        questionNumber: nextQuestionNumber,
      }));
      
      return {
        nodes,
        shouldStopBranch: data.shouldStopBranch || false,
        stopReason: data.stopReason || 'No more questions needed',
        suggestedAnswer: data.suggestedAnswer
      };
    } catch (error) {
      console.error("Error in fetchQuestionsForNode:", error);
      // Return a default error question node
      const errorNode: QANode = {
        id: uuidv4(),
        question: "Failed to generate question. Please try again or refresh the page.",
        children: [],
        questionNumber: questionCount + 1,
      };
      return { 
        nodes: [errorNode], 
        shouldStopBranch: true, 
        stopReason: error instanceof Error ? error.message : "Error generating questions",
        suggestedAnswer: undefined
      };
    }
  };

  // Helper: Find node by ID in the tree
  const findNodeById = (root: QANode | null, id: string): QANode | null => {
    if (!root) return null;
    if (root.id === id) return root;
    for (const child of root.children) {
      const found = findNodeById(child, id);
      if (found) return found;
    }
    return null;
  };

  // Helper: Update requirements document
  const updateRequirements = async (nodeId: string | null) => {
    try {
      if (!qaTree || !requirementsDoc) {
        console.warn('Missing qaTree or requirementsDoc, skipping requirements update');
        return;
      }

      const response = await fetch('/api/update-requirements', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          qaTree,
          currentNodeId: nodeId,
          knowledgeBase: settings?.knowledgeBase,
          existingDocument: requirementsDoc
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error occurred' }));
        throw new Error(`API request failed: ${errorData.error || response.statusText}`);
      }

      const updatedDoc = await response.json();
      if (!updatedDoc || !updatedDoc.categories) {
        throw new Error('Invalid requirements document received');
      }

      setRequirementsDoc(updatedDoc);
      
      // Save progress including requirements
      saveProgress();
    } catch (error) {
      console.error('Error updating requirements:', error);
      // Don't throw the error, just log it and continue
    }
  };

  // Auto-save timer
  useEffect(() => {
    const autoSaveInterval = setInterval(() => {
      if (qaTree) {
        saveProgress(true);
      }
    }, 60000); // Auto-save every minute

    return () => clearInterval(autoSaveInterval);
  }, [qaTree, currentNode, questionCount, prompt, settings]);

  // Handle page leave
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (!isLeavingPage) {
        e.preventDefault();
        e.returnValue = '';
        saveProgress(true);
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
  }, [isLeavingPage]);

  // Helper: Save current progress
  const saveProgress = (isAutoSave = false) => {
    if (!qaTree || !settings || !requirementsDoc) return;

    try {
      // Update session metadata
      const currentTime = new Date().toISOString();
      const metadata: SessionMetadata = {
        id: sessionMetadata?.id || uuidv4(),
        prompt,
        lastUpdated: currentTime,
        questionCount,
        versions: [],
        settings: {
          traversalMode: settings.traversalMode,
          unknownHandling: settings.unknownHandling,
          conflictResolution: settings.conflictResolution
        },
        name: sessionMetadata?.name
      };

      // Save progress and metadata
      localStorage.setItem('qaProgress', JSON.stringify({
        qaTree,
        currentNodeId: currentNode?.id || null,
        questionCount,
        prompt,
        settings,
        requirementsDoc
      }));

      localStorage.setItem('sessionMetadata', JSON.stringify(metadata));
      setSessionMetadata(metadata);

      if (!isAutoSave) {
        // Show success message for manual saves
        // TODO: Add a toast notification system
        console.log('Progress saved successfully');
      }
    } catch (error) {
      console.error('Error saving progress:', error);
      // TODO: Add error notification
    }
  };

  const handleVersionRestore = (version: MockupVersion) => {
    // Confirm before restoring
    if (window.confirm('Restoring this version will replace your current progress. Continue?')) {
      setQaTree(version.qaTree);
      setRequirementsDoc(version.requirementsDoc);
      
      // Find the first unanswered question in the restored tree
      const firstUnanswered = findFirstUnansweredChild(version.qaTree);
      setCurrentNode(firstUnanswered);
      
      // Update question count
      let count = 0;
      const countAnswers = (node: QANode) => {
        if (node.answer) count++;
        node.children.forEach(countAnswers);
      };
      countAnswers(version.qaTree);
      setQuestionCount(count);
      
      // Save the restored state
      saveProgress();
    }
  };

  const handleSaveSession = (name?: string) => {
    if (sessionMetadata) {
      const updatedMetadata = {
        ...sessionMetadata,
        name,
        lastUpdated: new Date().toISOString()
      };
      setSessionMetadata(updatedMetadata);
      localStorage.setItem('sessionMetadata', JSON.stringify(updatedMetadata));
      saveProgress();
    }
  };

  // On mount: try to load saved progress or start new session
  useEffect(() => {
    // Prevent duplicate API call on initial load
    if (hasFetchedInitialQuestion.current) return;
    hasFetchedInitialQuestion.current = true;

    const savedProgress = localStorage.getItem('qaProgress');
    const storedPrompt = localStorage.getItem('designPrompt');
    const storedSettings = localStorage.getItem('qaSettings');
    
    if (savedProgress) {
      // Load saved progress
      try {
        const progress: SavedProgress = JSON.parse(savedProgress);
        console.log('Loaded settings with knowledge base:', progress.settings.knowledgeBase);
        setPrompt(progress.prompt);
        setSettings(progress.settings);
        setQaTree(progress.qaTree);
        setQuestionCount(progress.questionCount);
        setRequirementsDoc(progress.requirementsDoc);
        if (progress.currentNodeId) {
          const node = findNodeById(progress.qaTree, progress.currentNodeId);
          setCurrentNode(node);
        }
        setIsLoading(false);
        setIsInitialLoad(false);
        return;
      } catch (error) {
        console.error("Error loading saved progress:", error);
      }
    }
    
    // Start new session
    if (storedPrompt && storedSettings) {
      const parsedSettings = JSON.parse(storedSettings);
      console.log('Starting new session with knowledge base:', parsedSettings.knowledgeBase);
      setPrompt(storedPrompt);
      setSettings(parsedSettings);
      
      // Create and set up root node (Q0)
      const rootNode: QANode = {
        id: uuidv4(),
        question: `Prompt: ${storedPrompt}`,
        children: [],
        questionNumber: 0,
      };
      setQaTree(rootNode);
      
      // Initialize requirements document
      const initialRequirementsDoc: RequirementsDocument = {
        id: uuidv4(),
        prompt: storedPrompt,
        lastUpdated: new Date().toISOString(),
        categories: {
          basicNeeds: { title: 'Basic Needs', requirements: [] },
          functionalRequirements: { title: 'Functional Requirements', requirements: [] },
          userExperience: { title: 'User Experience', requirements: [] },
          implementation: { title: 'Implementation', requirements: [] },
          refinements: { title: 'Refinements', requirements: [] },
          constraints: { title: 'Constraints', requirements: [] }
        }
      };
      setRequirementsDoc(initialRequirementsDoc);
      
      // Generate first question (Q1)
      fetchQuestionsForNode(storedPrompt, rootNode, [], 0, false).then(({ nodes: children, suggestedAnswer }) => {
        if (children.length > 0) {
          children[0].questionNumber = 1;
          rootNode.children = children;
          setQaTree({ ...rootNode });
          setCurrentNode(children[0]);
          if (suggestedAnswer) {
            setSuggestedAnswer({ 
              text: suggestedAnswer, 
              confidence: 'medium',
              sourceReferences: []
            });
          }
          setQuestionCount(1);
        }
        setIsLoading(false);
        setIsInitialLoad(false);
      });
    } else {
      console.error("No design prompt or settings found.");
      router.push('/');
    }
  }, [router]);

  // When the user submits an answer
  const handleAnswer = async (answer: string) => {
    if (!currentNode || !settings) return;
    
    setIsLoadingNextQuestion(true);
    setSuggestedAnswer(null);
    
    // Check if we've hit the question limit
    if (settings.maxQuestions && questionCount >= settings.maxQuestions) {
      setCurrentNode(null);
      setIsLoadingNextQuestion(false);
      return;
    }
    
    try {
      // Record the answer
      currentNode.answer = answer;
      
      // Update requirements document with new answer
      await updateRequirements(currentNode.id);
      
      // Get the next question based on traversal mode
      const nextNode = await getNextQuestion(currentNode);
      
      if (nextNode) {
        // Verify this question hasn't been asked before
        if (!askedQuestions.has(nextNode.question)) {
          setAskedQuestions(prev => new Set(prev).add(nextNode.question));
          setIsInitialLoad(true); // Prevent auto-fetch when setting current node
          setCurrentNode(nextNode);
          setQuestionCount(prev => prev + 1);
          setQaTree(prev => prev ? { ...prev } : prev);
          setIsInitialLoad(false); // Reset flag after state updates
        } else {
          console.warn('Duplicate question detected:', nextNode.question);
          setCurrentNode(null);
        }
      } else {
        setCurrentNode(null); // No more questions
        // Final requirements update with no current node
        await updateRequirements(null);
      }
    } catch (error) {
      console.error('Error in handleAnswer:', error);
    } finally {
      setIsLoadingNextQuestion(false);
    }
  };

  const handleAutoPopulate = async (): Promise<string | null> => {
    try {
      // If we already have a suggested answer, use it
      if (suggestedAnswer) {
        return suggestedAnswer.text;
      }
      
      // Otherwise, build the previous Q&A chain up to the current question
      const questionHistory: QuestionHistoryItem[] = [];
      const collectHistory = (n: QANode) => {
        if (n.question !== `Prompt: ${prompt}`) {
          questionHistory.push({
            question: n.question,
            answer: n.answer,
            topics: extractTopics(n.question)
          });
        }
        n.children.forEach(collectHistory);
      };
      collectHistory(qaTree!);

      const response = await fetch('/api/generate-questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt,
          previousQuestions: questionHistory,
          traversalMode: settings?.traversalMode,
          knowledgeBase: settings?.knowledgeBase,
          currentQuestion: currentNode?.question,
          isAutoPopulate: true
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to generate answer');
      }

      const data = await response.json();
      console.log('Auto-populate response:', data);
      
      // Return the suggestedAnswer text if it exists
      if (data.suggestedAnswer) {
        return data.suggestedAnswer;
      }
      
      return null;
    } catch (error) {
      console.error('Error auto-populating answer:', error);
      return null;
    }
  };

  const handleRestart = () => {
    // Set loading state
    setIsLoading(true);
    setIsLoadingNextQuestion(true);
    
    // Create new root node (Q0)
    const rootNode: QANode = {
      id: uuidv4(),
      question: `Prompt: ${prompt}`,
      children: [],
      questionNumber: 0, // Explicitly set prompt as Q0
    };
    
    // Reset all states
    setQaTree(rootNode);
    setQuestionCount(0);
    setCurrentNode(null);
    setAskedQuestions(new Set());
    setAskedTopics(new Set());
    
    // Reset requirements document
    const initialRequirementsDoc: RequirementsDocument = {
      id: uuidv4(),
      prompt: prompt,
      lastUpdated: new Date().toISOString(),
      categories: {
        basicNeeds: { 
          title: 'Basic Needs', 
          requirements: [] 
        },
        functionalRequirements: { 
          title: 'Functional Requirements', 
          requirements: [] 
        },
        userExperience: { 
          title: 'User Experience', 
          requirements: [] 
        },
        implementation: { 
          title: 'Implementation', 
          requirements: [] 
        },
        refinements: { 
          title: 'Refinements', 
          requirements: [] 
        },
        constraints: { 
          title: 'Constraints', 
          requirements: [] 
        }
      }
    };
    setRequirementsDoc(initialRequirementsDoc);
    
    // Generate first question (Q1)
    fetchQuestionsForNode(prompt, rootNode, [], 0, true).then(({ nodes: children }) => {
      if (children.length > 0) {
        // Set first actual question as Q1
        children[0].questionNumber = 1;
        rootNode.children = children;
        setQaTree({ ...rootNode });
        setCurrentNode(children[0]);
        setQuestionCount(1);
      }
    })
      .catch(error => {
        console.error('Error generating first question:', error);
      })
      .finally(() => {
        setIsLoading(false);
        setIsLoadingNextQuestion(false);
      });
  };

  const handleGenerate = async () => {
    setIsPreviewOpen(true);
    setIsGenerating(true);
    
    try {
      // Update requirements one final time before showing preview
      await updateRequirements(currentNode?.id || null);
      
      // Wait a bit to ensure requirements are updated
      await new Promise(resolve => setTimeout(resolve, 500));
      
    } catch (error) {
      console.error('Error generating preview:', error);
    } finally {
      setIsGenerating(false);
    }
  };

  return (
    <div className="min-h-screen flex flex-col bg-gray-100">
      <HeaderToolbar 
        onRestart={handleRestart} 
        onGenerate={handleGenerate}
        onSave={() => handleSaveSession()}
        showRestartButton={!isLoading}
        showGenerateButton={!isLoading && qaTree !== null}
        showSaveButton={!isLoading && qaTree !== null}
      />
      <div className="py-2 px-6 bg-white border-b border-gray-200">
        <div className="flex justify-between items-center">
          <div className="text-sm text-gray-600">
            Questions: {questionCount}{settings?.maxQuestions ? ` / ${settings.maxQuestions}` : ''}
          </div>
          <div className="text-sm text-gray-600">
            Mode: {settings?.traversalMode === 'dfs' ? 'Depth-First' : 'Breadth-First'}
          </div>
        </div>
      </div>
      <main className="flex-1 flex">
        {/* Left: Canvas Tree view */}
        <div className="w-2/3 p-6 overflow-auto">
          <div className="bg-white rounded-lg shadow-lg p-6 min-h-full">
            <h2 className="text-2xl font-bold mb-6 text-gray-900">Question Tree</h2>
            {isLoading ? (
              <div className="flex items-center justify-center h-32">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
              </div>
            ) : (
              <CanvasTree node={qaTree} />
            )}
          </div>
        </div>
        {/* Right: Q&A Panel */}
        <div className="w-1/3 p-6 overflow-auto border-l border-gray-200">
          <QAPanel
            currentQuestion={
              currentNode
                ? currentNode.question
                : "No more questions. Q&A complete."
            }
            onSubmitAnswer={handleAnswer}
            isLoading={isLoading || isLoadingNextQuestion}
            hasKnowledgeBase={Boolean(settings?.knowledgeBase?.length)}
            onAutoPopulate={handleAutoPopulate}
          />
        </div>
      </main>
      
      <PreviewPanel
        isOpen={isPreviewOpen}
        onClose={() => setIsPreviewOpen(false)}
        requirementsDoc={requirementsDoc!}
        isGenerating={isGenerating}
        qaTree={qaTree}
        onVersionRestore={handleVersionRestore}
      />
    </div>
  );
}


----- /Users/jackcrawford/ai-design-flow/app/globals.css -----
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
}


----- /Users/jackcrawford/ai-design-flow/app/layout.tsx -----
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}


----- /Users/jackcrawford/ai-design-flow/app/page.tsx -----
// app/page.tsx
'use client';

import { useRouter } from 'next/navigation';
import { useEffect, useState } from 'react';
import PromptInput from '@/components/PromptInput';
import { QASettings } from '@/types/settings';

interface SavedProgress {
  qaTree: any;
  currentNodeId: string | null;
  questionCount: number;
  prompt: string;
  settings: QASettings;
}

export default function PromptPage() {
  const router = useRouter();
  const [savedSession, setSavedSession] = useState<SavedProgress | null>(null);

  useEffect(() => {
    const savedProgress = localStorage.getItem('qaProgress');
    if (savedProgress) {
      try {
        const progress = JSON.parse(savedProgress);
        setSavedSession(progress);
      } catch (error) {
        console.error("Error loading saved session:", error);
      }
    }
  }, []);

  const handlePromptSubmit = (prompt: string, settings: QASettings) => {
    console.log("User prompt:", prompt);
    console.log("Settings:", settings);
    
    // Clear any existing progress
    localStorage.removeItem('qaProgress');
    
    // Save new prompt and settings
    localStorage.setItem('designPrompt', prompt);
    localStorage.setItem('qaSettings', JSON.stringify(settings));
    router.push('/qna');
  };

  const handleContinueSession = () => {
    router.push('/qna');
  };

  return (
    <div className="min-h-screen flex flex-col justify-center items-center bg-gray-50 px-4">
      {/* Header */}
      <header className="mb-8 text-center">
        <h1 className="text-4xl font-bold text-gray-800">Welcome to AI Design Flow</h1>
        <p className="mt-4 text-lg text-gray-600">
          Enter your design prompt to kick off your interactive design journey.
        </p>
      </header>
      
      {/* Saved Session */}
      {savedSession && (
        <div className="w-full max-w-2xl mb-8">
          <div className="bg-white rounded-lg shadow-lg p-6 border border-gray-200">
            <h2 className="text-xl font-bold text-gray-900 mb-4">Continue Previous Session</h2>
            <div className="space-y-2 mb-4">
              <p className="text-gray-700">
                <span className="font-medium">Prompt:</span> {savedSession.prompt}
              </p>
              <p className="text-gray-700">
                <span className="font-medium">Progress:</span> {savedSession.questionCount} questions answered
              </p>
              <p className="text-gray-700">
                <span className="font-medium">Mode:</span> {savedSession.settings.traversalMode === 'dfs' ? 'Depth-First' : 'Breadth-First'}
              </p>
            </div>
            <div className="flex gap-4">
              <button
                onClick={handleContinueSession}
                className="flex-1 bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium"
              >
                Continue Session
              </button>
              <button
                onClick={() => setSavedSession(null)}
                className="flex-1 bg-gray-100 text-gray-700 px-6 py-3 rounded-lg hover:bg-gray-200 transition-colors font-medium"
              >
                Start New Session
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Prompt Input */}
      {!savedSession && (
        <div className="w-full max-w-2xl">
          <PromptInput onSubmit={handlePromptSubmit} />
        </div>
      )}
    </div>
  );
}


----- /Users/jackcrawford/ai-design-flow/components/Canvas.tsx -----
interface CanvasProps {
  answers: Array<{ question: string; answer: string }>;
}

export default function Canvas({ answers }: CanvasProps) {
  return (
    <div className="bg-gray-50 rounded-lg p-6 overflow-auto">
      <h2 className="text-xl font-semibold mb-4">Design Flow</h2>
      <div className="space-y-4">
        {answers.map((item, index) => (
          <div key={index} className="bg-white p-4 rounded-lg shadow">
            <p className="font-medium text-gray-700 mb-2">Q: {item.question}</p>
            <p className="text-gray-600">A: {item.answer}</p>
          </div>
        ))}
      </div>
    </div>
  );
} 

----- /Users/jackcrawford/ai-design-flow/components/CanvasTree.tsx -----
// components/CanvasTree.tsx
import React from 'react';
import { QANode } from '@/types'; // if you're using a separate types file

interface CanvasTreeProps {
  node: QANode | null;
  depth?: number;
  isRoot?: boolean;
}

const CanvasTree: React.FC<CanvasTreeProps> = ({ node, depth = 0, isRoot = true }) => {
  if (!node) return null;

  const isPromptNode = node.question.startsWith('Prompt:');

  return (
    <div style={{ marginLeft: depth * 16 }} className="mb-4">
      <div className={`p-2 border rounded mb-2 ${isPromptNode ? 'bg-gray-50' : 'bg-white'} shadow`}>
        <p className={`${isPromptNode ? 'font-semibold text-gray-900' : 'font-medium text-gray-900'}`}>
          {isPromptNode ? (
            node.question
          ) : (
            <>
              <span className="text-blue-600 font-semibold">Q{node.questionNumber}: </span>
              {node.question}
            </>
          )}
        </p>
        {!isPromptNode && node.answer && (
          <p className="text-gray-800 mt-1">
            <span className="text-blue-600 font-semibold">A{node.questionNumber}: </span>
            {node.answer}
          </p>
        )}
      </div>
      {node.children?.map((child: QANode) => (
        <CanvasTree key={child.id} node={child} depth={depth + 1} isRoot={false} />
      ))}
    </div>
  );
};

export default CanvasTree;


----- /Users/jackcrawford/ai-design-flow/components/HeaderToolbar.tsx -----
import Link from 'next/link';

interface HeaderToolbarProps {
  onRestart?: () => void;
  onGenerate?: () => void;
  onSave?: () => void;
  showRestartButton?: boolean;
  showGenerateButton?: boolean;
  showSaveButton?: boolean;
}

const HeaderToolbar: React.FC<HeaderToolbarProps> = ({ 
  onRestart, 
  onGenerate,
  onSave,
  showRestartButton = false,
  showGenerateButton = false,
  showSaveButton = false
}) => {
  return (
    <header className="bg-white border-b border-gray-200">
      <div className="w-full px-2">
        <div className="flex justify-between items-center h-16 max-w-[1920px] mx-auto">
          <div className="pl-2">
            <Link href="/" className="text-xl font-bold text-gray-900 hover:text-gray-700 transition-colors">
              AI Design Flow
            </Link>
          </div>
          <div className="pr-2 flex space-x-4">
            {showSaveButton && onSave && (
              <button
                onClick={onSave}
                className="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors flex items-center space-x-2"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" />
                </svg>
                <span>Save Progress</span>
              </button>
            )}
            {showGenerateButton && onGenerate && (
              <button
                onClick={onGenerate}
                className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                </svg>
                <span>Generate Preview</span>
              </button>
            )}
            {showRestartButton && onRestart && (
              <button
                onClick={onRestart}
                className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
              >
                Restart Q&A
              </button>
            )}
          </div>
        </div>
      </div>
    </header>
  );
};

export default HeaderToolbar; 

----- /Users/jackcrawford/ai-design-flow/components/LivePreview.tsx -----
import React, { useEffect, useRef } from 'react';

// Helper function to adjust hex colors
function adjustColor(hex: string, amount: number): string {
  try {
    // Remove the hash if present
    hex = hex.replace('#', '');
    
    // Convert to RGB
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    
    // Adjust each component
    const adjustComponent = (c: number) => {
      const newC = Math.min(255, Math.max(0, c + amount));
      const hex = newC.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };
    
    // Convert back to hex
    return '#' + adjustComponent(r) + adjustComponent(g) + adjustComponent(b);
  } catch {
    // Return a fallback color if there's any error
    return amount > 0 ? '#3B82F6' : '#1E40AF';
  }
}

interface LivePreviewProps {
  code: string;
  colorScheme?: {
    primary: string;
    secondary: string;
    accent: string;
    background: string;
    text: string;
  };
}

const LivePreview: React.FC<LivePreviewProps> = ({ code, colorScheme }) => {
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!containerRef.current || !code) return;

    try {
      // Clean up any previous content
      while (containerRef.current.firstChild) {
        containerRef.current.removeChild(containerRef.current.firstChild);
      }

      // Create a new iframe to sandbox the preview
      const iframe = document.createElement('iframe');
      iframe.style.width = '100%';
      iframe.style.height = '100%';
      iframe.style.border = 'none';
      containerRef.current.appendChild(iframe);

      // Transform the code to remove imports and exports
      let transformedCode = code;
      
      // Remove import statements but keep React imports as globals
      transformedCode = transformedCode.replace(/import\s+{([^}]+)}\s+from\s+['"]react['"];?/g, '');
      transformedCode = transformedCode.replace(/import\s+React\s*,?\s*{([^}]+)}\s+from\s+['"]react['"];?/g, '');
      transformedCode = transformedCode.replace(/import\s+.*?from\s+['"].*?['"];?\n?/g, '');
      
      // Remove export statements but keep the component definition
      transformedCode = transformedCode.replace(/export\s+default\s+/, '');
      transformedCode = transformedCode.replace(/export\s+/, '');

      // Create the document content with necessary dependencies
      const html = `
        <!DOCTYPE html>
        <html>
          <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
            <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
            <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
            <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
            <style>
              body { margin: 0; padding: 1rem; }
              * { font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; }
              
              /* Custom color scheme */
              :root {
                --color-primary: ${colorScheme?.primary || '#1D4ED8'};
                --color-secondary: ${colorScheme?.secondary || '#64748B'};
                --color-accent: ${colorScheme?.accent || '#F59E0B'};
                --color-background: ${colorScheme?.background || '#F3F4F6'};
                --color-text: ${colorScheme?.text || '#111827'};
                
                /* Computed colors for states */
                --color-primary-light: ${colorScheme?.primary ? adjustColor(colorScheme.primary, 20) : '#3B82F6'};
                --color-primary-dark: ${colorScheme?.primary ? adjustColor(colorScheme.primary, -20) : '#1E40AF'};
                --color-secondary-light: ${colorScheme?.secondary ? adjustColor(colorScheme.secondary, 20) : '#94A3B8'};
                --color-secondary-dark: ${colorScheme?.secondary ? adjustColor(colorScheme.secondary, -20) : '#475569'};
                --color-accent-light: ${colorScheme?.accent ? adjustColor(colorScheme.accent, 20) : '#FBBF24'};
                --color-accent-dark: ${colorScheme?.accent ? adjustColor(colorScheme.accent, -20) : '#D97706'};
              }
              
              /* Text colors */
              .text-primary { color: var(--color-primary); }
              .text-primary-light { color: var(--color-primary-light); }
              .text-primary-dark { color: var(--color-primary-dark); }
              .text-secondary { color: var(--color-secondary); }
              .text-secondary-light { color: var(--color-secondary-light); }
              .text-secondary-dark { color: var(--color-secondary-dark); }
              .text-accent { color: var(--color-accent); }
              .text-accent-light { color: var(--color-accent-light); }
              .text-accent-dark { color: var(--color-accent-dark); }
              .text-text { color: var(--color-text); }
              
              /* Background colors */
              .bg-primary { background-color: var(--color-primary); }
              .bg-primary-light { background-color: var(--color-primary-light); }
              .bg-primary-dark { background-color: var(--color-primary-dark); }
              .bg-secondary { background-color: var(--color-secondary); }
              .bg-secondary-light { background-color: var(--color-secondary-light); }
              .bg-secondary-dark { background-color: var(--color-secondary-dark); }
              .bg-accent { background-color: var(--color-accent); }
              .bg-accent-light { background-color: var(--color-accent-light); }
              .bg-accent-dark { background-color: var(--color-accent-dark); }
              .bg-background { background-color: var(--color-background); }
              
              /* Border colors */
              .border-primary { border-color: var(--color-primary); }
              .border-primary-light { border-color: var(--color-primary-light); }
              .border-primary-dark { border-color: var(--color-primary-dark); }
              .border-secondary { border-color: var(--color-secondary); }
              .border-secondary-light { border-color: var(--color-secondary-light); }
              .border-secondary-dark { border-color: var(--color-secondary-dark); }
              .border-accent { border-color: var(--color-accent); }
              .border-accent-light { border-color: var(--color-accent-light); }
              .border-accent-dark { border-color: var(--color-accent-dark); }
              
              /* Hover states */
              .hover\:text-primary:hover { color: var(--color-primary); }
              .hover\:text-primary-light:hover { color: var(--color-primary-light); }
              .hover\:text-primary-dark:hover { color: var(--color-primary-dark); }
              .hover\:text-secondary:hover { color: var(--color-secondary); }
              .hover\:text-accent:hover { color: var(--color-accent); }
              
              .hover\:bg-primary:hover { background-color: var(--color-primary); }
              .hover\:bg-primary-light:hover { background-color: var(--color-primary-light); }
              .hover\:bg-primary-dark:hover { background-color: var(--color-primary-dark); }
              .hover\:bg-secondary:hover { background-color: var(--color-secondary); }
              .hover\:bg-accent:hover { background-color: var(--color-accent); }
              
              /* Focus states */
              .focus\:border-primary:focus { border-color: var(--color-primary); }
              .focus\:border-accent:focus { border-color: var(--color-accent); }
              .focus\:ring-primary:focus { --tw-ring-color: var(--color-primary); }
              .focus\:ring-accent:focus { --tw-ring-color: var(--color-accent); }
              
              /* Active states */
              .active\:bg-primary-dark:active { background-color: var(--color-primary-dark); }
              .active\:bg-secondary-dark:active { background-color: var(--color-secondary-dark); }
              .active\:bg-accent-dark:active { background-color: var(--color-accent-dark); }
              
              /* Disabled states */
              .disabled\:bg-gray-300:disabled { background-color: #D1D5DB; }
              .disabled\:text-gray-500:disabled { color: #6B7280; }
              
              /* Additional utility classes for transitions */
              .transition { transition-property: all; transition-duration: 200ms; }
              .transition-colors { transition-property: background-color, border-color, color, fill, stroke; transition-duration: 200ms; }
            </style>
          </head>
          <body>
            <div id="root"></div>
            <script type="text/babel">
              // Make React hooks available globally
              const { useState, useEffect, useRef, useMemo, useCallback, useContext, useReducer } = React;
              
              // Error Boundary Component
              class ErrorBoundary extends React.Component {
                constructor(props) {
                  super(props);
                  this.state = { hasError: false, error: null };
                }
                
                static getDerivedStateFromError(error) {
                  return { hasError: true, error };
                }
                
                render() {
                  if (this.state.hasError) {
                    return (
                      <div className="p-4 text-red-600 bg-red-50 rounded-lg">
                        <h2 className="text-lg font-semibold mb-2">Error in Component</h2>
                        <pre className="text-sm overflow-auto">
                          {this.state.error?.message || 'Unknown error occurred'}
                        </pre>
                      </div>
                    );
                  }
                  return this.props.children;
                }
              }

              // Define TypeScript-like interface handling
              function defineInterface(name, structure) {
                // Create a basic structure that works with useState destructuring
                const defaultStructure = {
                  [Symbol.iterator]: function* () {
                    yield undefined;  // initial state
                    yield function() {};  // setState function
                  }
                };
                window[name] = { ...defaultStructure, ...structure };
                return window[name];
              }

              // Define basic TypeScript types as JavaScript equivalents
              const TypeScriptTypes = {
                string: String,
                number: Number,
                boolean: Boolean,
                Date: Date,
                null: null,
                undefined: undefined,
                void: undefined,
                any: undefined,
                never: undefined,
                object: Object,
                Array: Array,
                Promise: Promise,
                // React-specific types
                ChangeEvent: class {
                  constructor(target) { this.target = target; }
                },
                FormEvent: class {
                  constructor(target) { 
                    this.target = target;
                    this.preventDefault = () => {};
                  }
                },
                MouseEvent: class {
                  constructor(target) { 
                    this.target = target;
                    this.preventDefault = () => {};
                  }
                }
              };

              // Add TypeScript types to window
              Object.entries(TypeScriptTypes).forEach(([key, value]) => {
                window[key] = value;
              });

              // Extract and define interfaces from the code
              (function() {
                const code = '${transformedCode.replace(/'/g, "\\'")}';
                const interfaceRegex = /interface\\s+(\\w+)\\s*{[^}]+}/g;
                const matches = code.match(interfaceRegex) || [];
                
                matches.forEach(match => {
                  const nameMatch = match.match(/interface\\s+(\\w+)/);
                  if (nameMatch && nameMatch[1]) {
                    try {
                      defineInterface(nameMatch[1], {});
                    } catch (error) {
                      console.warn('Failed to define interface:', nameMatch[1]);
                    }
                  }
                });
              })();
              
              // Component code
              ${transformedCode}
              
              // Find and render the main component
              const components = Object.values(window).filter(
                val => typeof val === 'function' && /^[A-Z]/.test(val?.name || '')
              );
              
              // Get the last defined component (usually the main one)
              const MainComponent = components[components.length - 1];
              
              if (MainComponent) {
                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(
                  <React.StrictMode>
                    <ErrorBoundary>
                      <MainComponent />
                    </ErrorBoundary>
                  </React.StrictMode>
                );
              } else {
                document.getElementById('root').innerHTML = 
                  '<div class="p-4 text-red-600 bg-red-50 rounded-lg">No React component found in the code</div>';
              }
            </script>
          </body>
        </html>
      `;

      // Write the content to the iframe
      const iframeDoc = iframe.contentWindow?.document;
      if (iframeDoc) {
        iframeDoc.open();
        iframeDoc.write(html);
        iframeDoc.close();
      }
    } catch (error) {
      console.error('Error rendering preview:', error);
      // Show error in preview
      if (containerRef.current) {
        containerRef.current.innerHTML = `
          <div class="p-4 text-red-600 bg-red-50 rounded-lg">
            <h2 class="text-lg font-semibold mb-2">Error Rendering Preview</h2>
            <pre class="text-sm overflow-auto">
              ${error instanceof Error ? error.message : 'Unknown error occurred'}
            </pre>
          </div>
        `;
      }
    }
  }, [code, colorScheme]);

  return (
    <div ref={containerRef} className="w-full h-full bg-white">
      <div className="flex items-center justify-center h-full text-gray-400">
        Loading preview...
      </div>
    </div>
  );
};

export default LivePreview; 

----- /Users/jackcrawford/ai-design-flow/components/PreviewArea.tsx -----
interface PreviewAreaProps {
  requirements: string;
  uiCode: string;
}

export default function PreviewArea({ requirements, uiCode }: PreviewAreaProps) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
      <div className="bg-white rounded-lg p-6 shadow-lg">
        <h2 className="text-xl font-semibold mb-4">Requirements</h2>
        <pre className="whitespace-pre-wrap font-mono text-sm bg-gray-50 p-4 rounded">
          {requirements}
        </pre>
      </div>
      <div className="bg-white rounded-lg p-6 shadow-lg">
        <h2 className="text-xl font-semibold mb-4">Generated UI Code</h2>
        <pre className="whitespace-pre-wrap font-mono text-sm bg-gray-50 p-4 rounded overflow-auto">
          {uiCode}
        </pre>
      </div>
    </div>
  );
} 

----- /Users/jackcrawford/ai-design-flow/components/PreviewPanel.tsx -----
import { RequirementsDocument, MockupVersion } from '@/types';
import { useState, useEffect } from 'react';
import { v4 as uuidv4 } from 'uuid';
import dynamic from 'next/dynamic';

// Dynamically import a component that will render the live preview
const LivePreview = dynamic(() => import('./LivePreview'), { ssr: false });

interface MockupData {
  code: string;
  colorScheme: {
    primary: string;
    secondary: string;
    accent: string;
    background: string;
    text: string;
  };
  components: string[];
  features: string[];
  nextSteps: string[];
}

interface PreviewPanelProps {
  isOpen: boolean;
  onClose: () => void;
  requirementsDoc: RequirementsDocument;
  isGenerating: boolean;
  qaTree: any;
  onVersionRestore?: (version: MockupVersion) => void;
}

export default function PreviewPanel({
  isOpen,
  onClose,
  requirementsDoc,
  isGenerating,
  qaTree,
  onVersionRestore
}: PreviewPanelProps) {
  const [activeTab, setActiveTab] = useState<'requirements' | 'mockup' | 'versions'>('requirements');
  const [mockupData, setMockupData] = useState<MockupData | null>(null);
  const [isMockupLoading, setIsMockupLoading] = useState(false);
  const [versions, setVersions] = useState<MockupVersion[]>([]);
  const [selectedVersion, setSelectedVersion] = useState<MockupVersion | null>(null);
  const [isCompareMode, setIsCompareMode] = useState(false);
  const [compareVersion, setCompareVersion] = useState<MockupVersion | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    // Load versions from localStorage
    try {
      const storedVersions = localStorage.getItem('mockupVersions');
      if (storedVersions) {
        setVersions(JSON.parse(storedVersions));
      }
    } catch (error) {
      console.error('Error loading versions:', error);
    }
  }, []);

  useEffect(() => {
    if (activeTab === 'mockup' && !mockupData && !isMockupLoading && !error) {
      generateMockup();
    }
  }, [activeTab, mockupData, isMockupLoading, error]);

  const generateMockup = async () => {
    setIsMockupLoading(true);
    setError(null);
    try {
      const response = await fetch('/api/generate-mockup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ requirementsDoc })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error occurred' }));
        throw new Error(errorData.error || 'Failed to generate mockup');
      }

      const data = await response.json();
      
      // Validate mockup data structure
      if (!data.code || !data.colorScheme || !data.components || !data.features || !data.nextSteps) {
        throw new Error('Invalid mockup data received');
      }

      setMockupData(data);

      // Create new version
      const newVersion: MockupVersion = {
        id: uuidv4(),
        timestamp: new Date().toISOString(),
        qaTree,
        requirementsDoc,
        mockupData: data
      };

      // Add to versions and save to localStorage
      const updatedVersions = [...versions, newVersion];
      setVersions(updatedVersions);
      localStorage.setItem('mockupVersions', JSON.stringify(updatedVersions));

    } catch (error) {
      console.error('Error generating mockup:', error);
      setError(error instanceof Error ? error.message : 'Failed to generate mockup');
    } finally {
      setIsMockupLoading(false);
    }
  };

  const handleVersionSelect = (version: MockupVersion) => {
    setSelectedVersion(version);
    setMockupData(version.mockupData);
  };

  const handleVersionRestore = (version: MockupVersion) => {
    if (onVersionRestore) {
      onVersionRestore(version);
    }
  };

  const handleCompareSelect = (version: MockupVersion) => {
    setCompareVersion(version);
    setIsCompareMode(true);
  };

  const handleCopyCode = () => {
    if (mockupData?.code) {
      navigator.clipboard.writeText(mockupData.code);
    }
  };

  const handleDownload = () => {
    if (activeTab === 'requirements') {
      // Download requirements as markdown
      const requirementsText = Object.entries(requirementsDoc.categories)
        .map(([key, category]) => {
          const reqs = category.requirements
            .map(req => `- ${req.text} (${req.priority} priority)`)
            .join('\n');
          return `## ${category.title}\n${reqs}`;
        })
        .join('\n\n');

      const content = `# ${requirementsDoc.prompt}\n\n${requirementsText}`;
      const blob = new Blob([content], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'requirements.md';
      a.click();
      URL.revokeObjectURL(url);
    } else if (mockupData?.code) {
      // Download mockup as TypeScript file
      const blob = new Blob([mockupData.code], { type: 'text/typescript' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'mockup.tsx';
      a.click();
      URL.revokeObjectURL(url);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-end">
      <div className={`${isCompareMode ? 'w-4/5' : 'w-full'} bg-white h-full shadow-lg flex flex-col`}>
        {/* Header */}
        <div className="p-4 border-b border-gray-200 flex justify-between items-center">
          <div className="flex space-x-4">
            <button
              onClick={() => setActiveTab('requirements')}
              className={`px-4 py-2 rounded-lg ${
                activeTab === 'requirements'
                  ? 'bg-blue-100 text-blue-700'
                  : 'text-gray-600 hover:bg-gray-100'
              }`}
            >
              Requirements
            </button>
            <button
              onClick={() => setActiveTab('mockup')}
              className={`px-4 py-2 rounded-lg ${
                activeTab === 'mockup'
                  ? 'bg-blue-100 text-blue-700'
                  : 'text-gray-600 hover:bg-gray-100'
              }`}
            >
              Mockup
            </button>
            <button
              onClick={() => setActiveTab('versions')}
              className={`px-4 py-2 rounded-lg ${
                activeTab === 'versions'
                  ? 'bg-blue-100 text-blue-700'
                  : 'text-gray-600 hover:bg-gray-100'
              }`}
            >
              Versions ({versions.length})
            </button>
          </div>
          <div className="flex space-x-4">
            {activeTab === 'versions' && selectedVersion && (
              <>
                <button
                  onClick={() => handleVersionRestore(selectedVersion)}
                  className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700"
                >
                  Restore Version
                </button>
                <button
                  onClick={() => handleCompareSelect(selectedVersion)}
                  className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                >
                  Compare
                </button>
              </>
            )}
            <button
              onClick={() => {
                setIsCompareMode(false);
                setCompareVersion(null);
                onClose();
              }}
              className="text-gray-500 hover:text-gray-700"
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-hidden flex">
          {/* Live Preview (Left Side) */}
          {activeTab === 'mockup' && mockupData && (
            <div className="w-2/3 h-full border-r border-gray-200 bg-gray-50 overflow-auto">
              <div className="h-full">
                <LivePreview code={mockupData.code} />
              </div>
            </div>
          )}

          {/* Details Panel (Right Side) */}
          <div className={`${activeTab === 'mockup' && mockupData ? 'w-1/3' : 'w-full'} h-full overflow-auto`}>
            <div className="p-6">
              {error ? (
                <div className="p-6 text-center">
                  <div className="text-red-600 mb-4">{error}</div>
                  <button
                    onClick={() => {
                      setError(null);
                      generateMockup();
                    }}
                    className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                  >
                    Try Again
                  </button>
                </div>
              ) : isGenerating || isMockupLoading ? (
                <div className="flex items-center justify-center h-full">
                  <div className="flex flex-col items-center space-y-4">
                    <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
                    <p className="text-gray-600">
                      {isGenerating ? 'Generating preview...' : 'Generating mockup...'}
                    </p>
                  </div>
                </div>
              ) : activeTab === 'versions' ? (
                <div className="p-6">
                  <h2 className="text-xl font-semibold text-gray-900 mb-4">Version History</h2>
                  <div className="space-y-4">
                    {versions.map((version) => (
                      <div
                        key={version.id}
                        className={`p-4 border rounded-lg cursor-pointer transition-colors ${
                          selectedVersion?.id === version.id
                            ? 'border-blue-500 bg-blue-50'
                            : 'border-gray-200 hover:border-blue-300'
                        }`}
                        onClick={() => handleVersionSelect(version)}
                      >
                        <div className="flex justify-between items-start">
                          <div>
                            <p className="font-medium text-gray-900">
                              Version from {new Date(version.timestamp).toLocaleString()}
                            </p>
                            <p className="text-sm text-gray-600 mt-1">
                              {version.requirementsDoc.categories.basicNeeds.requirements.length} requirements,{' '}
                              {version.mockupData.components.length} components
                            </p>
                          </div>
                          {version.name && (
                            <span className="px-2 py-1 bg-gray-100 text-gray-700 rounded text-sm">
                              {version.name}
                            </span>
                          )}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              ) : (
                <div className={`flex ${isCompareMode ? 'space-x-4' : ''}`}>
                  <div className={`${isCompareMode ? 'w-1/2' : 'w-full'}`}>
                    {activeTab === 'requirements' ? (
                      <div className="space-y-8">
                        <div className="prose max-w-none">
                          <h1 className="text-2xl font-bold text-gray-900 mb-4">
                            {requirementsDoc.prompt}
                          </h1>
                          <p className="text-sm text-gray-500 mb-8">
                            Last updated: {new Date(requirementsDoc.lastUpdated).toLocaleString()}
                          </p>
                        </div>

                        {Object.entries(requirementsDoc.categories).map(([key, category]) => (
                          <div key={key} className="space-y-4">
                            <h2 className="text-xl font-semibold text-gray-900">
                              {category.title}
                            </h2>
                            {category.requirements && category.requirements.length > 0 ? (
                              <ul className="space-y-3">
                                {category.requirements.map((req, index) => (
                                  <li
                                    key={req.id || `${key}-${index}-${req.text}`}
                                    className="bg-white rounded-lg border border-gray-200 p-4"
                                  >
                                    <div className="flex items-start justify-between">
                                      <div className="flex-1">
                                        <p className="text-gray-900">{req.text}</p>
                                        <div className="mt-2 flex flex-wrap gap-2">
                                          {req.priority && (
                                            <span className={`px-2 py-1 rounded-full text-xs ${
                                              req.priority === 'high'
                                                ? 'bg-red-100 text-red-800'
                                                : req.priority === 'medium'
                                                ? 'bg-yellow-100 text-yellow-800'
                                                : 'bg-green-100 text-green-800'
                                            }`}>
                                              {req.priority} priority
                                            </span>
                                          )}
                                          {req.category && (
                                            <span className="px-2 py-1 rounded-full text-xs bg-blue-100 text-blue-800">
                                              {req.category}
                                            </span>
                                          )}
                                          {req.tags?.map((tag, tagIndex) => (
                                            <span
                                              key={`${req.id || index}-tag-${tagIndex}`}
                                              className="px-2 py-1 rounded-full text-xs bg-gray-100 text-gray-800"
                                            >
                                              {tag}
                                            </span>
                                          ))}
                                        </div>
                                      </div>
                                    </div>
                                  </li>
                                ))}
                              </ul>
                            ) : (
                              <p className="text-gray-500 italic">No requirements in {category.title}</p>
                            )}
                          </div>
                        ))}
                      </div>
                    ) : mockupData ? (
                      <div className="space-y-8">
                        {/* Color Scheme */}
                        <div>
                          <h2 className="text-xl font-semibold text-gray-900 mb-4">Color Scheme</h2>
                          <div className="flex flex-wrap gap-4">
                            {Object.entries(mockupData.colorScheme).map(([name, color]) => (
                              <div key={name} className="flex flex-col items-center">
                                <div
                                  className="w-16 h-16 rounded-lg shadow-md"
                                  style={{ backgroundColor: color }}
                                />
                                <span className="mt-2 text-sm text-gray-600">{name}</span>
                                <span className="text-xs text-gray-400">{color}</span>
                              </div>
                            ))}
                          </div>
                        </div>

                        {/* Components */}
                        <div>
                          <h2 className="text-xl font-semibold text-gray-900 mb-4">Components</h2>
                          <ul className="list-disc list-inside space-y-2">
                            {mockupData.components.map((component, index) => (
                              <li key={index} className="text-gray-700">{component}</li>
                            ))}
                          </ul>
                        </div>

                        {/* Features */}
                        <div>
                          <h2 className="text-xl font-semibold text-gray-900 mb-4">Implemented Features</h2>
                          <ul className="list-disc list-inside space-y-2">
                            {mockupData.features.map((feature, index) => (
                              <li key={index} className="text-gray-700">{feature}</li>
                            ))}
                          </ul>
                        </div>

                        {/* Code */}
                        <div>
                          <h2 className="text-xl font-semibold text-gray-900 mb-4">Generated Code</h2>
                          <div className="relative">
                            <pre className="bg-gray-50 p-4 rounded-lg overflow-auto text-sm max-h-96">
                              <code className="text-gray-800">{mockupData.code}</code>
                            </pre>
                            <button
                              onClick={handleCopyCode}
                              className="absolute top-2 right-2 p-2 bg-white rounded-md shadow-sm hover:bg-gray-50"
                              title="Copy code"
                            >
                              <svg className="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                              </svg>
                            </button>
                          </div>
                        </div>

                        {/* Next Steps */}
                        <div>
                          <h2 className="text-xl font-semibold text-gray-900 mb-4">Next Steps</h2>
                          <ul className="list-disc list-inside space-y-2">
                            {mockupData.nextSteps.map((step, index) => (
                              <li key={index} className="text-gray-700">{step}</li>
                            ))}
                          </ul>
                        </div>
                      </div>
                    ) : null}
                  </div>
                  {isCompareMode && compareVersion && (
                    <div className="w-1/2 p-6 border-l border-gray-200">
                      <h2 className="text-xl font-semibold text-gray-900 mb-4">
                        Comparing with version from {new Date(compareVersion.timestamp).toLocaleString()}
                      </h2>
                      {/* Render comparison content */}
                      {activeTab === 'requirements' ? (
                        <div className="space-y-8">
                          {/* ... requirements comparison rendering ... */}
                        </div>
                      ) : (
                        <div className="space-y-8">
                          {/* ... mockup comparison rendering ... */}
                        </div>
                      )}
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Footer */}
        <div className="p-4 border-t border-gray-200">
          <div className="flex justify-between">
            <button
              className="px-4 py-2 text-gray-600 hover:text-gray-800"
              onClick={handleDownload}
            >
              Download {activeTab === 'requirements' ? 'Requirements' : 'Code'}
            </button>
            {activeTab === 'mockup' && mockupData && (
              <div className="flex space-x-4">
                <button
                  className="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700"
                  onClick={() => {
                    // TODO: Implement Figma export
                    alert('Figma export coming soon!');
                  }}
                >
                  Export to Figma
                </button>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
} 

----- /Users/jackcrawford/ai-design-flow/components/PromptInput.tsx -----
// components/PromptInput.tsx
import React, { useState, ChangeEvent } from 'react';
import { QASettings, KnowledgeBaseSource } from '@/types/settings';
import { v4 as uuidv4 } from 'uuid';

interface PromptInputProps {
  onSubmit: (prompt: string, settings: QASettings) => void;
}

const PromptInput: React.FC<PromptInputProps> = ({ onSubmit }) => {
  const [prompt, setPrompt] = useState('');
  const [showSettings, setShowSettings] = useState(false);
  const [settings, setSettings] = useState<QASettings>({
    traversalMode: 'bfs',
    unknownHandling: 'auto',
    conflictResolution: 'auto',
    knowledgeBase: []
  });
  const [isProcessingFile, setIsProcessingFile] = useState(false);
  const [pastedContent, setPastedContent] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (prompt.trim()) {
      setShowSettings(true);
    }
  };

  const handleStartQA = () => {
    onSubmit(prompt, settings);
  };

  const processKnowledgeBase = async (type: 'file' | 'text', data: File | string, name: string) => {
    try {
      setIsProcessingFile(true);
      const formData = new FormData();
      formData.append('type', type);
      
      if (type === 'file') {
        formData.append('file', data as File);
      } else {
        formData.append('content', data as string);
      }

      const response = await fetch('/api/process-knowledge-base', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error('Failed to process knowledge base');
      }

      const result = await response.json();
      
      const newSource: KnowledgeBaseSource = {
        id: uuidv4(),
        type,
        name,
        ...(type === 'file' ? { file: data as File } : { content: data as string }),
        processedContent: result.processedContent
      };

      setSettings(prev => ({
        ...prev,
        knowledgeBase: [...(prev.knowledgeBase || []), newSource]
      }));
    } catch (error) {
      console.error('Error processing knowledge base:', error);
      // You might want to show an error message to the user here
    } finally {
      setIsProcessingFile(false);
    }
  };

  const handleFileUpload = async (file: File) => {
    await processKnowledgeBase('file', file, file.name);
  };

  const handleTextAdd = async () => {
    if (pastedContent.trim()) {
      await processKnowledgeBase('text', pastedContent, `Pasted content ${new Date().toLocaleString()}`);
      setPastedContent('');
    }
  };

  const removeKnowledgeSource = (id: string) => {
    setSettings(prev => ({
      ...prev,
      knowledgeBase: prev.knowledgeBase?.filter(source => source.id !== id)
    }));
  };

  const handleSettingChange = (
    setting: keyof QASettings,
    value: string | number | { file: File; processedContent: any } | undefined
  ) => {
    setSettings(prev => ({
      ...prev,
      [setting]: value
    }));
  };

  if (showSettings) {
    return (
      <div className="p-8 w-full max-w-2xl">
        <div className="mb-6">
          <h3 className="text-xl font-bold text-gray-900 mb-2">Your Prompt:</h3>
          <p className="text-gray-700 bg-gray-50 p-4 rounded-lg">{prompt}</p>
          <button
            onClick={() => setShowSettings(false)}
            className="mt-2 text-blue-600 hover:text-blue-700 text-sm"
          >
            Edit Prompt
          </button>
        </div>
        <div className="space-y-6">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Traversal Mode
            </label>
            <div className="flex gap-4">
              <label className="flex items-center">
                <input
                  type="radio"
                  name="traversalMode"
                  value="bfs"
                  checked={settings.traversalMode === 'bfs'}
                  onChange={(e) => handleSettingChange('traversalMode', e.target.value)}
                  className="mr-2"
                />
                <span className="text-gray-900">Breadth-First</span>
              </label>
              <label className="flex items-center">
                <input
                  type="radio"
                  name="traversalMode"
                  value="dfs"
                  checked={settings.traversalMode === 'dfs'}
                  onChange={(e) => handleSettingChange('traversalMode', e.target.value)}
                  className="mr-2"
                />
                <span className="text-gray-900">Depth-First</span>
              </label>
            </div>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Unknown Handling
            </label>
            <select 
              className="w-full border border-gray-300 rounded-lg p-2 text-gray-900 bg-white"
              value={settings.unknownHandling}
              onChange={(e) => handleSettingChange('unknownHandling', e.target.value)}
            >
              <option value="auto">Auto (trivial)</option>
              <option value="prompt">Always Prompt</option>
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Conflict Resolution
            </label>
            <select 
              className="w-full border border-gray-300 rounded-lg p-2 text-gray-900 bg-white"
              value={settings.conflictResolution}
              onChange={(e) => handleSettingChange('conflictResolution', e.target.value)}
            >
              <option value="auto">Auto-resolve Minor</option>
              <option value="manual">Manual Resolution</option>
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Maximum Questions
            </label>
            <input
              type="number"
              min="1"
              placeholder="Optional"
              className="w-full border border-gray-300 rounded-lg p-2 text-gray-900 bg-white"
              value={settings.maxQuestions || ''}
              onChange={(e) => handleSettingChange('maxQuestions', e.target.value ? parseInt(e.target.value) : undefined)}
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Knowledge Base Sources
            </label>
            <div className="space-y-4">
              {/* File Upload */}
              <div className="space-y-2">
                <input
                  type="file"
                  className="w-full text-gray-900 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
                  accept=".pdf,.doc,.docx,.txt"
                  onChange={(e: ChangeEvent<HTMLInputElement>) => {
                    const file = e.target.files?.[0];
                    if (file) {
                      handleFileUpload(file);
                    }
                  }}
                  disabled={isProcessingFile}
                />
                <p className="text-xs text-gray-500">
                  Supported formats: PDF, DOC, DOCX, TXT
                </p>
              </div>

              {/* Text Input */}
              <div className="space-y-2">
                <textarea
                  value={pastedContent}
                  onChange={(e) => setPastedContent(e.target.value)}
                  placeholder="Paste additional content here..."
                  className="w-full h-32 p-3 border rounded-lg resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                  disabled={isProcessingFile}
                />
                <button
                  onClick={handleTextAdd}
                  disabled={!pastedContent.trim() || isProcessingFile}
                  className="px-4 py-2 text-sm bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors disabled:bg-gray-400"
                >
                  Add Text Content
                </button>
              </div>

              {/* Processing Indicator */}
              {isProcessingFile && (
                <div className="flex items-center space-x-2 text-sm text-gray-600">
                  <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
                  <span>Processing content...</span>
                </div>
              )}

              {/* Knowledge Base List */}
              {settings.knowledgeBase && settings.knowledgeBase.length > 0 && (
                <div className="mt-4">
                  <h4 className="text-sm font-medium text-gray-700 mb-2">Added Sources:</h4>
                  <div className="space-y-2">
                    {settings.knowledgeBase.map((source) => (
                      <div
                        key={source.id}
                        className="flex items-center justify-between p-2 bg-gray-50 rounded-lg"
                      >
                        <div className="flex items-center space-x-2">
                          <span className="text-sm text-gray-600">
                            {source.type === 'file' ? '📄' : '📝'}
                          </span>
                          <span className="text-sm text-gray-800">{source.name}</span>
                        </div>
                        <button
                          onClick={() => removeKnowledgeSource(source.id)}
                          className="text-red-600 hover:text-red-700"
                        >
                          ✕
                        </button>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          </div>

          <button
            onClick={handleStartQA}
            className="w-full bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium"
          >
            Start Q&A
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="p-8 w-full max-w-2xl">
      <form onSubmit={handleSubmit} className="flex flex-col gap-4">
        <label htmlFor="prompt" className="text-xl font-bold text-gray-900">
          Enter your design prompt:
        </label>
        <textarea
          id="prompt"
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          placeholder="Design the interface for a 1000-floor elevator"
          className="border border-gray-300 p-4 rounded-lg h-48 text-gray-900 text-base resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white"
        />
        <button 
          type="submit" 
          className="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium"
        >
          Configure Settings
        </button>
      </form>
    </div>
  );
};

export default PromptInput;

----- /Users/jackcrawford/ai-design-flow/components/QAPanel.tsx -----
import { useState } from 'react';

interface SuggestedAnswer {
  text: string;
  confidence: 'high' | 'medium' | 'low';
  sourceReferences?: number[];
}

interface QAPanelProps {
  currentQuestion: string;
  onSubmitAnswer: (answer: string) => void;
  isLoading: boolean;
  hasKnowledgeBase: boolean;
  onAutoPopulate: () => Promise<string | null>;
  suggestedAnswer?: SuggestedAnswer | null;
}

export default function QAPanel({ 
  currentQuestion, 
  onSubmitAnswer, 
  isLoading,
  hasKnowledgeBase,
  onAutoPopulate,
  suggestedAnswer
}: QAPanelProps) {
  const [answer, setAnswer] = useState('');
  const [isAutoPopulating, setIsAutoPopulating] = useState(false);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (answer.trim()) {
      onSubmitAnswer(answer);
      setAnswer('');
    }
  };

  const handleAutoPopulate = async () => {
    setIsAutoPopulating(true);
    try {
      const suggestedAnswer = await onAutoPopulate();
      if (suggestedAnswer) {
        setAnswer(suggestedAnswer);
      } else {
        alert('No relevant information found in the knowledge base. Please provide your expert answer.');
      }
    } catch (error) {
      console.error('Error generating answer:', error);
      alert('There was an error accessing the knowledge base. Please provide your answer manually.');
    } finally {
      setIsAutoPopulating(false);
    }
  };

  return (
    <div className="bg-white rounded-lg p-6 shadow-lg">
      <div className="mb-6">
        <h3 className="text-lg font-semibold text-gray-900 mb-2">Current Question:</h3>
        {isLoading ? (
          <div className="flex items-center space-x-2">
            <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
            <p className="text-gray-600">Loading question...</p>
          </div>
        ) : (
          <p className="text-gray-800">{currentQuestion}</p>
        )}
      </div>

      {suggestedAnswer && (
        <div className="mb-4 p-4 rounded-lg border border-gray-200">
          <div className="flex-1">
            <div className="flex items-center gap-2 mb-1">
              <h4 className="text-sm font-medium">Suggested Answer</h4>
              <span className={`text-xs px-2 py-0.5 rounded-full ${
                suggestedAnswer.confidence === 'high' 
                  ? 'bg-green-100 text-green-800'
                  : suggestedAnswer.confidence === 'medium'
                  ? 'bg-yellow-100 text-yellow-800'
                  : 'bg-gray-100 text-gray-800'
              }`}>
                {suggestedAnswer.confidence} confidence
              </span>
            </div>
            <p className="text-sm">{suggestedAnswer.text}</p>
            {suggestedAnswer.sourceReferences && suggestedAnswer.sourceReferences.length > 0 && (
              <p className="text-xs mt-2 text-gray-600">
                Sources: {suggestedAnswer.sourceReferences.map(ref => `#${ref + 1}`).join(', ')}
              </p>
            )}
            <button
              onClick={handleAutoPopulate}
              className="mt-3 w-full px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
            >
              Use This Answer
            </button>
          </div>
        </div>
      )}

      <form onSubmit={handleSubmit}>
        <div className="space-y-4">
          {hasKnowledgeBase && (
            <button
              type="button"
              onClick={handleAutoPopulate}
              disabled={isLoading || isAutoPopulating}
              className={`w-full px-4 py-2 rounded-lg transition-colors ${
                isLoading || isAutoPopulating
                  ? 'bg-gray-400 cursor-not-allowed'
                  : 'bg-green-600 hover:bg-green-700'
              } text-white flex items-center justify-center gap-2`}
            >
              {isAutoPopulating ? (
                <>
                  <div className="animate-spin rounded-full h-4 w-4 border-2 border-white border-t-transparent"></div>
                  <span>Finding Best Answer...</span>
                </>
              ) : (
                <>
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
                  </svg>
                  <span>Get Suggested Answer</span>
                </>
              )}
            </button>
          )}
          
          <textarea
            value={answer}
            onChange={(e) => setAnswer(e.target.value)}
            className="w-full h-32 p-3 border rounded-lg resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
            placeholder="Type your answer or use the suggestion button above..."
            disabled={isLoading || isAutoPopulating}
          />
          <button
            type="submit"
            className={`w-full px-4 py-2 rounded-lg transition-colors ${
              isLoading || isAutoPopulating || !answer.trim()
                ? 'bg-gray-400 cursor-not-allowed'
                : 'bg-blue-600 hover:bg-blue-700'
            } text-white`}
            disabled={isLoading || isAutoPopulating || !answer.trim()}
          >
            Submit Answer
          </button>
        </div>
      </form>
    </div>
  );
} 

----- /Users/jackcrawford/ai-design-flow/types/index.ts -----
export interface QANode {
  id: string;
  question: string;
  answer?: string;
  children: QANode[];
  questionNumber?: number;
}

export interface RequirementCategory {
  title: string;
  requirements: Array<{
    id: string;
    text: string;
    source: 'user-qa' | 'knowledge-base';
    sourceDetails?: {
      questionId?: string;
      knowledgeBaseIndex?: number;
    };
    priority: 'high' | 'medium' | 'low';
    category: 'functional' | 'technical' | 'ux' | 'accessibility' | 'security' | 'performance';
    tags: string[];
    createdAt: string;
    updatedAt: string;
  }>;
}

export interface RequirementsDocument {
  id: string;
  prompt: string;
  lastUpdated: string;
  categories: {
    basicNeeds: RequirementCategory;
    functionalRequirements: RequirementCategory;
    userExperience: RequirementCategory;
    implementation: RequirementCategory;
    refinements: RequirementCategory;
    constraints: RequirementCategory;
  };
}

export interface MockupVersion {
  id: string;
  timestamp: string;
  name?: string;
  qaTree: QANode;
  requirementsDoc: RequirementsDocument;
  mockupData: {
    code: string;
    colorScheme: {
      primary: string;
      secondary: string;
      accent: string;
      background: string;
      text: string;
    };
    components: string[];
    features: string[];
    nextSteps: string[];
  };
}

export interface SessionMetadata {
  id: string;
  prompt: string;
  lastUpdated: string;
  questionCount: number;
  versions: MockupVersion[];
  settings: {
    traversalMode: 'bfs' | 'dfs';
    unknownHandling: 'auto' | 'prompt';
    conflictResolution: 'auto' | 'manual';
  };
  name?: string;
} 

----- /Users/jackcrawford/ai-design-flow/types/pdf-parse.d.ts -----
declare module 'pdf-parse' {
  interface PDFData {
    text: string;
    numpages: number;
    info: any;
    metadata: any;
    version: string;
  }

  function PDFParse(dataBuffer: Buffer, options?: any): Promise<PDFData>;
  export = PDFParse;
} 

----- /Users/jackcrawford/ai-design-flow/types/settings.ts -----
export interface KnowledgeBaseSource {
  id: string;
  type: 'file' | 'text';
  name: string;
  content?: string;
  file?: File;
  processedContent?: {
    requirements?: string[];
    technicalSpecifications?: string[];
    designGuidelines?: string[];
    userPreferences?: string[];
    industryStandards?: string[];
    [key: string]: any;
  };
}

export interface QASettings {
  traversalMode: 'bfs' | 'dfs';
  unknownHandling: 'auto' | 'prompt';
  conflictResolution: 'auto' | 'manual';
  maxQuestions?: number;
  knowledgeBase?: KnowledgeBaseSource[];
} 

----- /Users/jackcrawford/ai-design-flow/.env.local -----
OPENAI_API_KEY=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

----- /Users/jackcrawford/ai-design-flow/.gitignore -----
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts


----- /Users/jackcrawford/ai-design-flow/next-env.d.ts -----
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


----- /Users/jackcrawford/ai-design-flow/next.config.ts -----
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    serverActions: true
  },
  serverExternalPackages: ['pdf-parse']
}

module.exports = nextConfig


----- /Users/jackcrawford/ai-design-flow/package.json -----
{
  "name": "ai-design-flow",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@langchain/community": "^0.3.29",
    "@langchain/openai": "^0.4.2",
    "langchain": "^0.3.15",
    "next": "15.1.6",
    "openai": "^4.83.0",
    "pdf-parse": "^1.1.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "uuid": "^11.0.5"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.1.6",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}


----- /Users/jackcrawford/ai-design-flow/tailwind.config.ts -----
import type { Config } from "tailwindcss";

export default {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        background: "var(--background)",
        foreground: "var(--foreground)",
      },
    },
  },
  plugins: [],
} satisfies Config;


----- /Users/jackcrawford/ai-design-flow/tsconfig.json -----
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


