Codebase Tree Structure:
========================
AI-DESIGN-FLOW
  ├── .next
  │   └── ... (contents hidden)
  ├── app
  │   ├── api
  │   │   ├── generate-mockup
  │   │   │   └── route.ts
  │   │   └── generate-questions
  │   │       └── route.ts
  │   ├── preview
  │   │   └── page.tsx
  │   ├── qna
  │   │   └── page.tsx
  │   ├── favicon.ico
  │   ├── globals.css
  │   ├── layout.tsx
  │   └── page.tsx
  ├── components
  │   ├── Canvas.tsx
  │   ├── CanvasTree.tsx
  │   ├── HeaderToolbar.tsx
  │   ├── PreviewArea.tsx
  │   ├── PromptInput.tsx
  │   └── QAPanel.tsx
  ├── node_modules
  │   └── ... (contents hidden)
  ├── public
  │   ├── file.svg
  │   ├── globe.svg
  │   ├── next.svg
  │   ├── vercel.svg
  │   └── window.svg
  ├── types
  │   ├── index.ts
  │   └── settings.ts
  ├── .env.local
  ├── .gitignore
  ├── codebase.txt
  ├── Concept.txt
  ├── eslint.config.mjs
  ├── generateCodebase.js
  ├── next-env.d.ts
  ├── next.config.ts
  ├── package-lock.json
  ├── package.json
  ├── postcss.config.mjs
  ├── README.md
  ├── tailwind.config.ts
  └── tsconfig.json


File Contents:
==============

----- /Users/jackcrawford/ai-design-flow/app/api/generate-mockup/route.ts -----
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const { prompt, answers } = await request.json();

    // TODO: Implement mockup generation logic
    const generatedContent = {
      requirements: '- Requirement 1\n- Requirement 2\n- Requirement 3',
      uiCode: '<div>Sample UI Code</div>',
    };

    return NextResponse.json(generatedContent);
  } catch (error) {
    console.error('Error generating mockup:', error);
    return NextResponse.json(
      { error: 'Failed to generate mockup' },
      { status: 500 }
    );
  }
} 

----- /Users/jackcrawford/ai-design-flow/app/api/generate-questions/route.ts -----
// /app/api/generate-questions/route.ts
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(request: NextRequest) {
  try {
    const { prompt, previousQuestions, traversalMode } = await request.json();

    // Calculate current depth by counting parents in previousQuestions
    let currentDepth = 0;
    let currentParent = previousQuestions[previousQuestions.length - 1];
    while (currentParent?.parent) {
      currentDepth++;
      currentParent = currentParent.parent;
    }

    const messages = [
      {
        role: 'system' as const,
        content: `You are an expert UX design assistant that helps generate follow-up questions for a design prompt. Your questions should follow a clear progression from basic needs to specific implementation details.

Follow these guidelines:
1. Question Progression Levels:
   - Level 1 (Basic Needs): Ask about fundamental user needs, target audience, and primary use cases
   - Level 2 (Requirements): Focus on specific requirements, constraints, and key features
   - Level 3 (User Experience): Explore UX preferences, accessibility needs, and interaction patterns
   - Level 4 (Implementation): Discuss specific UI elements, layouts, and technical requirements
   - Level 5 (Refinement): Fine-tune details, edge cases, and specific feature behaviors

2. Current Depth: ${currentDepth}/5
   - If depth > 4, only continue if absolutely necessary for critical information
   - Consider stopping the current line of questioning if:
     * The answers provide sufficient detail for implementation
     * The topic has been thoroughly explored
     * Further questions would be too specific or redundant

3. Traversal Mode: ${traversalMode}
   - BFS: Focus on getting a complete picture at the current level before going deeper
   - DFS: Thoroughly explore one aspect before moving to siblings

4. Response Format:
   Return a JSON object with:
   {
     "questions": ["Next question to ask"],
     "shouldStopBranch": boolean, // true if this line of questioning is complete
     "stopReason": "string explaining why we should stop (if shouldStopBranch is true)"
   }`
      },
      {
        role: 'user' as const,
        content: `The design prompt is: "${prompt}".
Previous Q&A: ${JSON.stringify(previousQuestions, null, 2)}

Based on this context:
1. Generate the next most appropriate question for the current depth level
2. Determine if we should stop this line of questioning
3. Return in the specified JSON format`
      },
    ];

    const completion = await openai.chat.completions.create({
      model: 'gpt-4',
      messages,
      temperature: 0.7,
      max_tokens: 150,
    });

    const content = completion.choices[0].message.content?.trim();
    let response = { questions: [], shouldStopBranch: false, stopReason: '' };

    try {
      response = JSON.parse(content!);
      if (!Array.isArray(response.questions)) {
        throw new Error("Questions is not an array");
      }
    } catch (jsonError) {
      console.error("Error parsing API response:", jsonError);
      // Fallback: extract questions from text
      response = {
        questions: content?.split('\n').filter((line) => line.trim() !== '') || [],
        shouldStopBranch: false,
        stopReason: ''
      };
    }

    return NextResponse.json(response);
  } catch (error) {
    console.error('Error generating questions:', error);
    return NextResponse.json(
      { error: 'Failed to generate questions' },
      { status: 500 }
    );
  }
}


----- /Users/jackcrawford/ai-design-flow/app/preview/page.tsx -----
'use client';

import { useEffect, useState } from 'react';
import PreviewArea from '@/components/PreviewArea';
import HeaderToolbar from '@/components/HeaderToolbar';

export default function PreviewPage() {
  const [generatedContent, setGeneratedContent] = useState({
    requirements: '',
    uiCode: '',
  });

  useEffect(() => {
    const storedContent = localStorage.getItem('generatedContent');
    if (storedContent) {
      setGeneratedContent(JSON.parse(storedContent));
    }
  }, []);

  return (
    <div className="min-h-screen flex flex-col">
      <HeaderToolbar />
      <main className="flex-1 container mx-auto px-4 py-8">
        <h1 className="text-3xl font-bold mb-8">Generated Preview</h1>
        <PreviewArea
          requirements={generatedContent.requirements}
          uiCode={generatedContent.uiCode}
        />
      </main>
    </div>
  );
}

----- /Users/jackcrawford/ai-design-flow/app/qna/page.tsx -----
// /app/qna/page.tsx
'use client';

import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { v4 as uuidv4 } from 'uuid';
import HeaderToolbar from '../../components/HeaderToolbar';
import QAPanel from '../../components/QAPanel';
import CanvasTree from '../../components/CanvasTree';
import { QANode } from '../../types';
import { QASettings } from '@/types/settings';

interface SavedProgress {
  qaTree: QANode;
  currentNodeId: string | null;
  questionCount: number;
  prompt: string;
  settings: QASettings;
}

export default function QnAPage() {
  const router = useRouter();
  const [prompt, setPrompt] = useState<string>('');
  const [settings, setSettings] = useState<QASettings | null>(null);
  const [qaTree, setQaTree] = useState<QANode | null>(null);
  const [currentNode, setCurrentNode] = useState<QANode | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isLoadingNextQuestion, setIsLoadingNextQuestion] = useState(false);
  const [questionCount, setQuestionCount] = useState(0);

  // Helper: Get the next question based on traversal mode
  const getNextQuestion = async (node: QANode): Promise<QANode | null> => {
    const isDFS = settings?.traversalMode === 'dfs';
    
    if (isDFS) {
      // DFS: Try to go deeper first
      if (node.answer) {
        // If this node has an answer, try to generate its first child
        const { nodes: children, shouldStopBranch } = await fetchQuestionsForNode(prompt, node);
        
        // If we should stop this branch or no children were generated, move to siblings
        if (!shouldStopBranch && children.length > 0) {
          node.children = children;
          return children[0];
        }
      }
      
      // If we can't go deeper, find the next sibling by traversing up
      let current: QANode | null = node;
      let parent = findParentNode(qaTree!, node);
      
      while (parent) {
        const siblings = parent.children;
        const currentIndex = siblings.indexOf(current!);
        
        if (currentIndex < siblings.length - 1) {
          // Return next sibling
          return siblings[currentIndex + 1];
        }
        
        // Move up to try next level's sibling
        current = parent;
        parent = findParentNode(qaTree!, parent);
      }
      
      return null; // No more questions
    } else {
      // BFS: Complete current level before going deeper
      const parent = findParentNode(qaTree!, node);
      if (!parent) return null; // Safety check
      
      // First, try to generate siblings at the current level
      const currentLevelNodes = parent.children;
      const currentIndex = currentLevelNodes.indexOf(node);
      
      // If this was the last answered node in its level, try to generate a new sibling
      if (currentIndex === currentLevelNodes.length - 1 && node.answer) {
        const { nodes: newSiblings, shouldStopBranch } = await fetchQuestionsForNode(prompt, parent);
        if (!shouldStopBranch && newSiblings.length > 0) {
          parent.children = [...currentLevelNodes, ...newSiblings];
          return newSiblings[0];
        }
      } 
      // If there are existing unanswered siblings, move to the next one
      else if (currentIndex < currentLevelNodes.length - 1) {
        return currentLevelNodes[currentIndex + 1];
      }
      
      // If we can't generate more siblings or move to next sibling,
      // look for the first answered node without children at the current level
      for (const sibling of currentLevelNodes) {
        if (sibling.answer && sibling.children.length === 0) {
          const { nodes: children, shouldStopBranch } = await fetchQuestionsForNode(prompt, sibling);
          if (!shouldStopBranch && children.length > 0) {
            sibling.children = children;
            return children[0];
          }
        }
      }
      
      // If we can't go deeper at this level, move to the next level
      const nextLevelStart = findFirstUnansweredChild(qaTree!);
      if (nextLevelStart) {
        return nextLevelStart;
      }
      
      // If no existing unanswered nodes, try to start a new level
      // Find the first node at the current level that can have children
      for (const sibling of currentLevelNodes) {
        if (sibling.answer && sibling.children.length === 0) {
          const { nodes: children, shouldStopBranch } = await fetchQuestionsForNode(prompt, sibling);
          if (!shouldStopBranch && children.length > 0) {
            sibling.children = children;
            return children[0];
          }
        }
      }
      
      return null; // No more questions at this level or deeper
    }
  };

  // Helper: Find parent node
  const findParentNode = (root: QANode | null, target: QANode): QANode | null => {
    if (!root) return null;
    if (root.children.includes(target)) return root;
    for (const child of root.children) {
      const found = findParentNode(child, target);
      if (found) return found;
    }
    return null;
  };

  // Helper: Find all nodes at the same level as the target node
  const findNodesAtSameLevel = (root: QANode | null, target: QANode): QANode[] => {
    if (!root) return [];
    const parent = findParentNode(root, target);
    if (!parent) return root.children; // If no parent, must be root level
    return parent.children;
  };

  // Helper: Find the first unanswered child in the tree (BFS)
  const findFirstUnansweredChild = (root: QANode | null): QANode | null => {
    if (!root) return null;
    const queue: QANode[] = [root];
    while (queue.length > 0) {
      const node = queue.shift()!;
      // Skip the root node when looking for unanswered questions
      if (node.children.length > 0) {
        for (const child of node.children) {
          if (!child.answer) return child;
          queue.push(child);
        }
      } else if (!node.answer && node.question !== `Prompt: ${prompt}`) {
        return node;
      }
    }
    return null;
  };

  // Helper: Find the first node that can have children (has answer but no children)
  const findFirstNodeForChildren = (root: QANode | null): QANode | null => {
    if (!root) return null;
    const queue: QANode[] = [root];
    while (queue.length > 0) {
      const node = queue.shift()!;
      // Skip the root node when looking for nodes that can have children
      if (node.answer && node.children.length === 0 && node.question !== `Prompt: ${prompt}`) {
        return node;
      }
      queue.push(...node.children);
    }
    return null;
  };

  // Helper: fetch questions for a node
  const fetchQuestionsForNode = async (designPrompt: string, parentNode: QANode): Promise<{ nodes: QANode[], shouldStopBranch: boolean, stopReason: string }> => {
    try {
      // Build the previous Q&A chain up to the root
      const previousQA: Array<{ question: string; answer?: string; parent?: any }> = [];
      let current: QANode | null = parentNode;
      
      while (current) {
        // Don't include the root prompt node in the Q&A chain
        if (current.answer && current.question !== `Prompt: ${prompt}`) {
          previousQA.unshift({
            question: current.question,
            answer: current.answer,
            parent: previousQA[0] || undefined
          });
        }
        const parent = findParentNode(qaTree, current);
        if (!parent || parent === current) break;
        current = parent;
      }
      
      const response = await fetch('/api/generate-questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt: designPrompt,
          previousQuestions: previousQA,
          traversalMode: settings?.traversalMode,
        }),
      });
      const data = await response.json();
      
      // Create a single child node with the next question number
      const nextQuestionNumber = questionCount + 1;
      const nodes: QANode[] = data.questions.slice(0, 1).map((q: string) => ({
        id: uuidv4(),
        question: q,
        children: [],
        questionNumber: nextQuestionNumber,
      }));
      
      return {
        nodes,
        shouldStopBranch: data.shouldStopBranch,
        stopReason: data.stopReason
      };
    } catch (error) {
      console.error("Error in fetchQuestionsForNode:", error);
      return { nodes: [], shouldStopBranch: true, stopReason: "Error generating questions" };
    }
  };

  // Helper: Find node by ID in the tree
  const findNodeById = (root: QANode | null, id: string): QANode | null => {
    if (!root) return null;
    if (root.id === id) return root;
    for (const child of root.children) {
      const found = findNodeById(child, id);
      if (found) return found;
    }
    return null;
  };

  // Helper: Save current progress to localStorage
  const saveProgress = () => {
    if (!qaTree || !settings) return;
    
    const progress: SavedProgress = {
      qaTree,
      currentNodeId: currentNode?.id || null,
      questionCount,
      prompt,
      settings
    };
    
    localStorage.setItem('qaProgress', JSON.stringify(progress));
  };

  // Effect to save progress whenever relevant state changes
  useEffect(() => {
    if (qaTree && !isLoading) {
      saveProgress();
    }
  }, [qaTree, currentNode, questionCount, prompt, settings]);

  // On mount: try to load saved progress or start new session
  useEffect(() => {
    const savedProgress = localStorage.getItem('qaProgress');
    const storedPrompt = localStorage.getItem('designPrompt');
    const storedSettings = localStorage.getItem('qaSettings');
    
    if (savedProgress) {
      // Load saved progress
      try {
        const progress: SavedProgress = JSON.parse(savedProgress);
        setPrompt(progress.prompt);
        setSettings(progress.settings);
        setQaTree(progress.qaTree);
        setQuestionCount(progress.questionCount);
        if (progress.currentNodeId) {
          const node = findNodeById(progress.qaTree, progress.currentNodeId);
          setCurrentNode(node);
        }
        setIsLoading(false);
        return;
      } catch (error) {
        console.error("Error loading saved progress:", error);
        // If loading saved progress fails, fall back to new session
      }
    }
    
    // Start new session
    if (storedPrompt && storedSettings) {
      const parsedSettings = JSON.parse(storedSettings);
      setPrompt(storedPrompt);
      setSettings(parsedSettings);
      
      // Create and set up root node
      const rootNode: QANode = {
        id: uuidv4(),
        question: `Prompt: ${storedPrompt}`,
        children: [],
      };
      setQaTree(rootNode);
      
      // Generate first question
      fetchQuestionsForNode(storedPrompt, rootNode).then(({ nodes: children }) => {
        if (children.length > 0) {
          rootNode.children = children;
          setQaTree({ ...rootNode });
          setCurrentNode(children[0]);
          setQuestionCount(1);
        }
        setIsLoading(false);
      });
    } else {
      console.error("No design prompt or settings found.");
      router.push('/');
    }
  }, [router]);

  // When the user submits an answer
  const handleAnswer = async (answer: string) => {
    if (!currentNode || !settings) return;
    
    setIsLoadingNextQuestion(true);
    
    // Check if we've hit the question limit
    if (settings.maxQuestions && questionCount >= settings.maxQuestions) {
      setCurrentNode(null); // End the Q&A session
      setIsLoadingNextQuestion(false);
      return;
    }
    
    // Record the answer
    currentNode.answer = answer;
    
    // Get the next question based on traversal mode
    const nextNode = await getNextQuestion(currentNode);
    
    if (nextNode) {
      setCurrentNode(nextNode);
      setQuestionCount(prev => prev + 1);
    } else {
      setCurrentNode(null); // No more questions
    }
    
    // Update the tree state
    setQaTree(prev => prev ? { ...prev } : prev);
    setIsLoadingNextQuestion(false);
  };

  return (
    <div className="min-h-screen flex flex-col bg-gray-100">
      <HeaderToolbar />
      <div className="py-2 px-6 bg-white border-b border-gray-200">
        <div className="flex justify-between items-center">
          <div className="text-sm text-gray-600">
            Questions: {questionCount}{settings?.maxQuestions ? ` / ${settings.maxQuestions}` : ''}
          </div>
          <div className="text-sm text-gray-600">
            Mode: {settings?.traversalMode === 'dfs' ? 'Depth-First' : 'Breadth-First'}
          </div>
        </div>
      </div>
      <main className="flex-1 flex">
        {/* Left: Canvas Tree view */}
        <div className="w-2/3 p-6 overflow-auto">
          <div className="bg-white rounded-lg shadow-lg p-6 min-h-full">
            <h2 className="text-2xl font-bold mb-6 text-gray-900">Question Tree</h2>
            {isLoading ? (
              <div className="flex items-center justify-center h-32">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
              </div>
            ) : (
              <CanvasTree node={qaTree} />
            )}
          </div>
        </div>
        {/* Right: Q&A Panel */}
        <div className="w-1/3 p-6 overflow-auto border-l border-gray-200">
          <QAPanel
            currentQuestion={
              currentNode
                ? currentNode.question
                : "No more questions. Q&A complete."
            }
            onSubmitAnswer={handleAnswer}
            isLoading={isLoading || isLoadingNextQuestion}
          />
        </div>
      </main>
    </div>
  );
}


----- /Users/jackcrawford/ai-design-flow/app/globals.css -----
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
}


----- /Users/jackcrawford/ai-design-flow/app/layout.tsx -----
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}


----- /Users/jackcrawford/ai-design-flow/app/page.tsx -----
// app/page.tsx
'use client';

import { useRouter } from 'next/navigation';
import { useEffect, useState } from 'react';
import PromptInput from '@/components/PromptInput';
import { QASettings } from '@/types/settings';

interface SavedProgress {
  qaTree: any;
  currentNodeId: string | null;
  questionCount: number;
  prompt: string;
  settings: QASettings;
}

export default function PromptPage() {
  const router = useRouter();
  const [savedSession, setSavedSession] = useState<SavedProgress | null>(null);

  useEffect(() => {
    const savedProgress = localStorage.getItem('qaProgress');
    if (savedProgress) {
      try {
        const progress = JSON.parse(savedProgress);
        setSavedSession(progress);
      } catch (error) {
        console.error("Error loading saved session:", error);
      }
    }
  }, []);

  const handlePromptSubmit = (prompt: string, settings: QASettings) => {
    console.log("User prompt:", prompt);
    console.log("Settings:", settings);
    
    // Clear any existing progress
    localStorage.removeItem('qaProgress');
    
    // Save new prompt and settings
    localStorage.setItem('designPrompt', prompt);
    localStorage.setItem('qaSettings', JSON.stringify(settings));
    router.push('/qna');
  };

  const handleContinueSession = () => {
    router.push('/qna');
  };

  return (
    <div className="min-h-screen flex flex-col justify-center items-center bg-gray-50 px-4">
      {/* Header */}
      <header className="mb-8 text-center">
        <h1 className="text-4xl font-bold text-gray-800">Welcome to AI Design Flow</h1>
        <p className="mt-4 text-lg text-gray-600">
          Enter your design prompt to kick off your interactive design journey.
        </p>
      </header>
      
      {/* Saved Session */}
      {savedSession && (
        <div className="w-full max-w-2xl mb-8">
          <div className="bg-white rounded-lg shadow-lg p-6 border border-gray-200">
            <h2 className="text-xl font-bold text-gray-900 mb-4">Continue Previous Session</h2>
            <div className="space-y-2 mb-4">
              <p className="text-gray-700">
                <span className="font-medium">Prompt:</span> {savedSession.prompt}
              </p>
              <p className="text-gray-700">
                <span className="font-medium">Progress:</span> {savedSession.questionCount} questions answered
              </p>
              <p className="text-gray-700">
                <span className="font-medium">Mode:</span> {savedSession.settings.traversalMode === 'dfs' ? 'Depth-First' : 'Breadth-First'}
              </p>
            </div>
            <div className="flex gap-4">
              <button
                onClick={handleContinueSession}
                className="flex-1 bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium"
              >
                Continue Session
              </button>
              <button
                onClick={() => setSavedSession(null)}
                className="flex-1 bg-gray-100 text-gray-700 px-6 py-3 rounded-lg hover:bg-gray-200 transition-colors font-medium"
              >
                Start New Session
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Prompt Input */}
      {!savedSession && (
        <div className="w-full max-w-2xl">
          <PromptInput onSubmit={handlePromptSubmit} />
        </div>
      )}
    </div>
  );
}


----- /Users/jackcrawford/ai-design-flow/components/Canvas.tsx -----
interface CanvasProps {
  answers: Array<{ question: string; answer: string }>;
}

export default function Canvas({ answers }: CanvasProps) {
  return (
    <div className="bg-gray-50 rounded-lg p-6 overflow-auto">
      <h2 className="text-xl font-semibold mb-4">Design Flow</h2>
      <div className="space-y-4">
        {answers.map((item, index) => (
          <div key={index} className="bg-white p-4 rounded-lg shadow">
            <p className="font-medium text-gray-700 mb-2">Q: {item.question}</p>
            <p className="text-gray-600">A: {item.answer}</p>
          </div>
        ))}
      </div>
    </div>
  );
} 

----- /Users/jackcrawford/ai-design-flow/components/CanvasTree.tsx -----
// components/CanvasTree.tsx
import React from 'react';
import { QANode } from '@/types'; // if you're using a separate types file

interface CanvasTreeProps {
  node: QANode | null;
  depth?: number;
  isRoot?: boolean;
}

const CanvasTree: React.FC<CanvasTreeProps> = ({ node, depth = 0, isRoot = true }) => {
  if (!node) return null;

  const isPromptNode = node.question.startsWith('Prompt:');

  return (
    <div style={{ marginLeft: depth * 16 }} className="mb-4">
      <div className={`p-2 border rounded mb-2 ${isPromptNode ? 'bg-gray-50' : 'bg-white'} shadow`}>
        <p className={`${isPromptNode ? 'font-semibold text-gray-900' : 'font-medium text-gray-900'}`}>
          {isPromptNode ? (
            node.question
          ) : (
            <>
              <span className="text-blue-600 font-semibold">Q{node.questionNumber}: </span>
              {node.question}
            </>
          )}
        </p>
        {!isPromptNode && node.answer && (
          <p className="text-gray-800 mt-1">
            <span className="text-blue-600 font-semibold">A{node.questionNumber}: </span>
            {node.answer}
          </p>
        )}
      </div>
      {node.children?.map((child: QANode) => (
        <CanvasTree key={child.id} node={child} depth={depth + 1} isRoot={false} />
      ))}
    </div>
  );
};

export default CanvasTree;


----- /Users/jackcrawford/ai-design-flow/components/HeaderToolbar.tsx -----
import Link from 'next/link';

export default function HeaderToolbar() {
  return (
    <header className="bg-white border-b">
      <div className="w-2/3 pl-6">
        <div className="flex items-center justify-between py-4">
          <div className="flex items-center space-x-6">
            <Link href="/" className="text-xl font-bold text-gray-900 hover:text-blue-600 transition-colors">
              AI Design Flow
            </Link>
            <nav className="hidden sm:flex space-x-6">
              <Link href="/qna" className="text-gray-600 hover:text-gray-900">Q&A</Link>
              <Link href="/preview" className="text-gray-600 hover:text-gray-900">Preview</Link>
            </nav>
          </div>
          <div className="flex items-center">
            <button className="text-gray-600 hover:text-gray-900">
              <span className="sr-only">Settings</span>
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
              </svg>
            </button>
          </div>
        </div>
      </div>
    </header>
  );
} 

----- /Users/jackcrawford/ai-design-flow/components/PreviewArea.tsx -----
interface PreviewAreaProps {
  requirements: string;
  uiCode: string;
}

export default function PreviewArea({ requirements, uiCode }: PreviewAreaProps) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
      <div className="bg-white rounded-lg p-6 shadow-lg">
        <h2 className="text-xl font-semibold mb-4">Requirements</h2>
        <pre className="whitespace-pre-wrap font-mono text-sm bg-gray-50 p-4 rounded">
          {requirements}
        </pre>
      </div>
      <div className="bg-white rounded-lg p-6 shadow-lg">
        <h2 className="text-xl font-semibold mb-4">Generated UI Code</h2>
        <pre className="whitespace-pre-wrap font-mono text-sm bg-gray-50 p-4 rounded overflow-auto">
          {uiCode}
        </pre>
      </div>
    </div>
  );
} 

----- /Users/jackcrawford/ai-design-flow/components/PromptInput.tsx -----
// components/PromptInput.tsx
import React, { useState, ChangeEvent } from 'react';
import { QASettings } from '@/types/settings';

interface PromptInputProps {
  onSubmit: (prompt: string, settings: QASettings) => void;
}

const PromptInput: React.FC<PromptInputProps> = ({ onSubmit }) => {
  const [prompt, setPrompt] = useState('');
  const [showSettings, setShowSettings] = useState(false);
  const [settings, setSettings] = useState<QASettings>({
    traversalMode: 'bfs',
    unknownHandling: 'auto',
    conflictResolution: 'auto'
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (prompt.trim()) {
      setShowSettings(true);
    }
  };

  const handleStartQA = () => {
    onSubmit(prompt, settings);
  };

  const handleSettingChange = (
    setting: keyof QASettings,
    value: string | number | File | undefined
  ) => {
    setSettings(prev => ({
      ...prev,
      [setting]: value
    }));
  };

  if (showSettings) {
    return (
      <div className="p-8 w-full max-w-2xl">
        <div className="mb-6">
          <h3 className="text-xl font-bold text-gray-900 mb-2">Your Prompt:</h3>
          <p className="text-gray-700 bg-gray-50 p-4 rounded-lg">{prompt}</p>
          <button
            onClick={() => setShowSettings(false)}
            className="mt-2 text-blue-600 hover:text-blue-700 text-sm"
          >
            Edit Prompt
          </button>
        </div>
        <div className="space-y-6">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Traversal Mode
            </label>
            <div className="flex gap-4">
              <label className="flex items-center">
                <input
                  type="radio"
                  name="traversalMode"
                  value="bfs"
                  checked={settings.traversalMode === 'bfs'}
                  onChange={(e) => handleSettingChange('traversalMode', e.target.value)}
                  className="mr-2"
                />
                <span className="text-gray-900">Breadth-First</span>
              </label>
              <label className="flex items-center">
                <input
                  type="radio"
                  name="traversalMode"
                  value="dfs"
                  checked={settings.traversalMode === 'dfs'}
                  onChange={(e) => handleSettingChange('traversalMode', e.target.value)}
                  className="mr-2"
                />
                <span className="text-gray-900">Depth-First</span>
              </label>
            </div>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Unknown Handling
            </label>
            <select 
              className="w-full border border-gray-300 rounded-lg p-2 text-gray-900 bg-white"
              value={settings.unknownHandling}
              onChange={(e) => handleSettingChange('unknownHandling', e.target.value)}
            >
              <option value="auto">Auto (trivial)</option>
              <option value="prompt">Always Prompt</option>
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Conflict Resolution
            </label>
            <select 
              className="w-full border border-gray-300 rounded-lg p-2 text-gray-900 bg-white"
              value={settings.conflictResolution}
              onChange={(e) => handleSettingChange('conflictResolution', e.target.value)}
            >
              <option value="auto">Auto-resolve Minor</option>
              <option value="manual">Manual Resolution</option>
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Maximum Questions
            </label>
            <input
              type="number"
              min="1"
              placeholder="Optional"
              className="w-full border border-gray-300 rounded-lg p-2 text-gray-900 bg-white"
              value={settings.maxQuestions || ''}
              onChange={(e) => handleSettingChange('maxQuestions', e.target.value ? parseInt(e.target.value) : undefined)}
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Knowledge Base (Optional)
            </label>
            <input
              type="file"
              className="w-full text-gray-900 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
              accept=".pdf,.doc,.docx,.txt"
              onChange={(e: ChangeEvent<HTMLInputElement>) => {
                const file = e.target.files?.[0];
                handleSettingChange('knowledgeBase', file);
              }}
            />
          </div>

          <button
            onClick={handleStartQA}
            className="w-full bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium"
          >
            Start Q&A
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="p-8 w-full max-w-2xl">
      <form onSubmit={handleSubmit} className="flex flex-col gap-4">
        <label htmlFor="prompt" className="text-xl font-bold text-gray-900">
          Enter your design prompt:
        </label>
        <textarea
          id="prompt"
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          placeholder="Design the interface for a 1000-floor elevator"
          className="border border-gray-300 p-4 rounded-lg h-48 text-gray-900 text-base resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white"
        />
        <button 
          type="submit" 
          className="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium"
        >
          Configure Settings
        </button>
      </form>
    </div>
  );
};

export default PromptInput;

----- /Users/jackcrawford/ai-design-flow/components/QAPanel.tsx -----
import { useState } from 'react';

interface QAPanelProps {
  currentQuestion: string;
  onSubmitAnswer: (answer: string) => void;
  isLoading: boolean;
}

export default function QAPanel({ currentQuestion, onSubmitAnswer, isLoading }: QAPanelProps) {
  const [answer, setAnswer] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (answer.trim()) {
      onSubmitAnswer(answer);
      setAnswer('');
    }
  };

  return (
    <div className="bg-white rounded-lg p-6 shadow-lg">
      <div className="mb-6">
        <h3 className="text-lg font-semibold text-gray-900 mb-2">Current Question:</h3>
        {isLoading ? (
          <div className="flex items-center space-x-2">
            <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
            <p className="text-gray-600">Loading question...</p>
          </div>
        ) : (
          <p className="text-gray-800">{currentQuestion}</p>
        )}
      </div>
      <form onSubmit={handleSubmit}>
        <div className="space-y-4">
          <textarea
            value={answer}
            onChange={(e) => setAnswer(e.target.value)}
            className="w-full h-32 p-3 border rounded-lg resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
            placeholder="Type your answer..."
            disabled={isLoading}
          />
          <button
            type="submit"
            className={`w-full px-4 py-2 rounded-lg transition-colors ${
              isLoading 
                ? 'bg-gray-400 cursor-not-allowed' 
                : 'bg-blue-600 hover:bg-blue-700'
            } text-white`}
            disabled={isLoading}
          >
            Submit Answer
          </button>
        </div>
      </form>
    </div>
  );
} 

----- /Users/jackcrawford/ai-design-flow/types/index.ts -----
export interface QANode {
  id: string;
  question: string;
  answer?: string;
  children: QANode[];
  questionNumber?: number;
} 

----- /Users/jackcrawford/ai-design-flow/types/settings.ts -----
export interface QASettings {
  traversalMode: 'bfs' | 'dfs';
  unknownHandling: 'auto' | 'prompt';
  conflictResolution: 'auto' | 'manual';
  maxQuestions?: number;
  knowledgeBase?: File;
} 

----- /Users/jackcrawford/ai-design-flow/.env.local -----
OPENAI_API_KEY=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 

----- /Users/jackcrawford/ai-design-flow/.gitignore -----
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts


----- /Users/jackcrawford/ai-design-flow/next-env.d.ts -----
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


----- /Users/jackcrawford/ai-design-flow/next.config.ts -----
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;


----- /Users/jackcrawford/ai-design-flow/package.json -----
{
  "name": "ai-design-flow",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "15.1.6",
    "openai": "^4.83.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "uuid": "^11.0.5"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.1.6",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}


----- /Users/jackcrawford/ai-design-flow/tailwind.config.ts -----
import type { Config } from "tailwindcss";

export default {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        background: "var(--background)",
        foreground: "var(--foreground)",
      },
    },
  },
  plugins: [],
} satisfies Config;


----- /Users/jackcrawford/ai-design-flow/tsconfig.json -----
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


