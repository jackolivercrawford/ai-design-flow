Codebase Tree Structure:
========================
AI-DESIGN-FLOW
  ├── .next
  │   └── ... (contents hidden)
  ├── app
  │   ├── api
  │   │   ├── generate-mockup
  │   │   │   └── route.ts
  │   │   ├── generate-questions
  │   │   │   └── route.ts
  │   │   ├── process-knowledge-base
  │   │   │   └── route.ts
  │   │   └── update-requirements
  │   │       └── route.ts
  │   ├── preview
  │   │   └── page.tsx
  │   ├── qna
  │   │   └── page.tsx
  │   ├── favicon.ico
  │   ├── globals.css
  │   ├── layout.tsx
  │   └── page.tsx
  ├── components
  │   ├── Canvas.tsx
  │   ├── CanvasTree.tsx
  │   ├── HeaderToolbar.tsx
  │   ├── LivePreview.tsx
  │   ├── PreviewArea.tsx
  │   ├── PreviewPanel.tsx
  │   ├── PromptInput.tsx
  │   └── QAPanel.tsx
  ├── node_modules
  │   └── ... (contents hidden)
  ├── public
  │   ├── file.svg
  │   ├── globe.svg
  │   ├── next.svg
  │   ├── vercel.svg
  │   └── window.svg
  ├── types
  │   ├── index.ts
  │   ├── pdf-parse.d.ts
  │   └── settings.ts
  ├── .env.local
  ├── .gitignore
  ├── codebase.txt
  ├── Concept.txt
  ├── eslint.config.mjs
  ├── generateCodebase.js
  ├── next-env.d.ts
  ├── next.config.ts
  ├── package-lock.json
  ├── package.json
  ├── postcss.config.mjs
  ├── README.md
  ├── tailwind.config.ts
  └── tsconfig.json


File Contents:
==============

----- /Users/jackcrawford/ai-design-flow/app/api/generate-mockup/route.ts -----
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { RequirementsDocument, RequirementCategory } from '@/types';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(request: NextRequest) {
  try {
    const { requirementsDoc } = await request.json();
    
    if (!requirementsDoc) {
      return NextResponse.json(
        { error: 'Requirements document is required' },
        { status: 400 }
      );
    }

    // Format requirements for the prompt
    const formattedRequirements = Object.entries(requirementsDoc.categories as Record<string, RequirementCategory>)
      .map(([key, category]) => {
        const reqs = category.requirements
          .map(req => `- ${req.text} (${req.priority} priority)`)
          .join('\n');
        return `${category.title}:\n${reqs}`;
      })
      .join('\n\n');

    // Check requirements size
    const promptText = `Design Prompt: ${requirementsDoc.prompt}\n\nRequirements:\n${formattedRequirements}`;
    const estimatedTokens = promptText.split(/\s+/).length;
    if (estimatedTokens > 2000) {
      return NextResponse.json(
        { error: 'Requirements document is too large. Please reduce the number of requirements or split into multiple requests.' },
        { status: 400 }
      );
    }

    const completion = await openai.chat.completions.create({
      model: "o3-mini",
      messages: [
        {
          role: "system",
          content: `You are an expert UI developer specializing in industrial and control system interfaces. Your task is to generate a complete, production-ready React component mockup based on the provided requirements. You MUST use React with Tailwind CSS and DaisyUI for styling. DaisyUI is already included via CDN in the preview environment.

CRITICAL: YOU MUST USE DAISYUI COMPONENTS INSTEAD OF RAW TAILWIND CLASSES. For example:

❌ WRONG (raw Tailwind):
\`\`\`tsx
<div className="p-4 bg-white rounded-lg shadow-lg">
  <h2 className="text-2xl font-bold mb-4">Title</h2>
  <button className="px-4 py-2 bg-blue-500 text-white rounded">Click me</button>
</div>
\`\`\`

✅ CORRECT (DaisyUI components):
\`\`\`tsx
<div className="card bg-base-100">
  <div className="card-body">
    <h2 className="card-title">Title</h2>
    <div className="card-actions">
      <button className="btn btn-primary">Click me</button>
    </div>
  </div>
</div>
\`\`\`

REQUIRED DAISYUI COMPONENTS:
1. Layout & Containers:
   - Cards: \`card\`, \`card-body\`, \`card-title\`, \`card-actions\`
   - Hero: \`hero\`, \`hero-content\`
   - Divider: \`divider\`

2. Navigation & Actions:
   - Buttons: \`btn\`, \`btn-primary\`, \`btn-secondary\`, etc.
   - Menu: \`menu\`, \`menu-title\`, \`menu-item\`
   - Tabs: \`tabs\`, \`tab\`, \`tab-active\`

3. Data Display:
   - Stats: \`stats\`, \`stat\`, \`stat-title\`, \`stat-value\`, \`stat-desc\`
   - Alert: \`alert\`, \`alert-info\`, \`alert-success\`, etc.
   - Badge: \`badge\`, \`badge-primary\`, etc.

4. Form Elements:
   - Input: \`input\`, \`input-bordered\`
   - Select: \`select\`, \`select-bordered\`
   - Toggle: \`toggle\`
   - Checkbox: \`checkbox\`
   - Radio: \`radio\`

5. Loading States:
   - \`loading\`, \`loading-spinner\`, \`loading-dots\`

Example of a proper DaisyUI industrial control panel:
\`\`\`tsx
function ControlPanel() {
  return (
    <div className="p-4">
      {/* Main Card */}
      <div className="card bg-base-100 shadow-xl">
        <div className="card-body">
          <h2 className="card-title">Control Panel</h2>
          
          {/* Status Display */}
          <div className="stats shadow">
            <div className="stat">
              <div className="stat-title">System Status</div>
              <div className="stat-value">Operational</div>
              <div className="stat-desc">All systems nominal</div>
            </div>
          </div>
          
          {/* Alerts */}
          <div className="alert alert-info">
            <span>System running at optimal efficiency</span>
          </div>
          
          {/* Controls */}
          <div className="form-control">
            <label className="label">
              <span className="label-text">Power Level</span>
            </label>
            <input type="range" className="range range-primary" />
          </div>
          
          {/* Action Buttons */}
          <div className="card-actions justify-end">
            <button className="btn btn-error">Emergency Stop</button>
            <button className="btn btn-primary">Start System</button>
          </div>
        </div>
      </div>
    </div>
  );
}
\`\`\`

CRITICAL COMPONENT STRUCTURE REQUIREMENTS:
1. The component MUST be named with an uppercase first letter (e.g., 'MainInterface', 'ControlPanel')
2. The component MUST be a function component with this exact structure:
   \`\`\`tsx
   function ComponentName() {
     // Your component logic here
     return (
       // Your JSX here
     );
   }
   \`\`\`
3. The component MUST have a default export at the end:
   \`export default ComponentName;\`

Guidelines:
1. Use React as the core technology.
2. Use DaisyUI components as the PRIMARY building blocks - avoid raw Tailwind classes when DaisyUI components exist.
3. Follow modern design principles while maintaining an industrial/control system aesthetic.
4. Ensure the UI is responsive and accessible.
5. Include comments explaining key design decisions.
6. Structure the code in a clean, maintainable way.
7. Use semantic HTML elements.
8. Include hover states, transitions, and proper spacing.
9. Generate a comprehensive color scheme that works with DaisyUI.
10. Include TypeScript types as comments only (avoid inline type assertions).

CRITICAL REQUIREMENTS FOR DAISYUI USAGE:
1. ALL buttons MUST use DaisyUI button classes:
   - Primary actions: \`btn btn-primary\`
   - Secondary actions: \`btn btn-secondary\`
   - Accent actions: \`btn btn-accent\`
   - Emergency/Critical: \`btn btn-error\`
   - Info/Status: \`btn btn-info\`
   - Success/Confirm: \`btn btn-success\`
   - Warning/Caution: \`btn btn-warning\`

2. ALL cards/panels MUST use DaisyUI card classes:
   - Container: \`card\`
   - Body: \`card-body\`
   - Title: \`card-title\`
   - Actions: \`card-actions\`

3. ALL status indicators MUST use DaisyUI alerts:
   - Info states: \`alert alert-info\`
   - Success states: \`alert alert-success\`
   - Warning states: \`alert alert-warning\`
   - Error states: \`alert alert-error\`

4. ALL form controls MUST use DaisyUI classes:
   - Inputs: \`input input-bordered\`
   - Select: \`select select-bordered\`
   - Range: \`range\` (with appropriate color classes)
   - Toggle: \`toggle\` (with appropriate color classes)
   - Checkbox: \`checkbox\`
   - Radio: \`radio\`

5. ALL stats/metrics MUST use DaisyUI stat components:
   - Container: \`stats\`
   - Individual stat: \`stat\`
   - Stat title: \`stat-title\`
   - Stat value: \`stat-value\`
   - Stat description: \`stat-desc\`

6. ALL loading states MUST use DaisyUI loading classes:
   - \`loading loading-spinner\`
   - \`loading loading-dots\`
   - \`loading loading-ring\`
   - \`loading loading-ball\`

7. Proper use of DaisyUI modifiers:
   - Sizes: \`btn-lg\`, \`btn-sm\`, \`input-lg\`, etc.
   - Styles: \`btn-outline\`, \`btn-ghost\`, etc.
   - States: \`btn-disabled\`, \`input-error\`, etc.

COLOR SCHEME REQUIREMENTS:
1. Generate a visually appealing and accessible color scheme suitable for industrial/control interfaces
2. Ensure sufficient contrast between text and background colors (minimum 4.5:1 for normal text, 3:1 for large text)
3. Primary colors should be bold and attention-grabbing
4. Secondary colors should complement the primary colors
5. Accent colors should provide visual interest and highlight important elements
6. Base colors should provide a clean, readable foundation
7. State colors should be clearly distinguishable (info, success, warning, error)
8. Content colors (--pc, --sc, --ac, --nc, --bc) must have excellent contrast with their backgrounds

The color scheme must work with DaisyUI's theme system using these variables:
- Primary: --p, --pf (focus), --pc (content)
- Secondary: --s, --sf (focus), --sc (content)
- Accent: --a, --af (focus), --ac (content)
- Neutral: --n, --nf (focus), --nc (content)
- Base: --b1, --b2, --b3, --bc (content)
- State: --in, --su, --wa, --er

Return your response in this exact JSON format:
{
  "code": "Complete React/Tailwind/DaisyUI component code as shown in the example above",
  "colorScheme": {
    "primary": "#hex (for main actions and headers)",
    "primary-focus": "#hex (darker shade of primary for focus/hover)",
    "primary-content": "#hex (text color on primary background)",
    "secondary": "#hex (for supporting elements)",
    "secondary-focus": "#hex (darker shade of secondary for focus/hover)",
    "secondary-content": "#hex (text color on secondary background)",
    "accent": "#hex (for attention-grabbing elements)",
    "accent-focus": "#hex (darker shade of accent for focus/hover)",
    "accent-content": "#hex (text color on accent background)",
    "neutral": "#hex (for neutral elements)",
    "neutral-focus": "#hex (darker shade of neutral for focus/hover)",
    "neutral-content": "#hex (text color on neutral background)",
    "base-100": "#hex (main background color)",
    "base-200": "#hex (slightly darker background)",
    "base-300": "#hex (even darker background)",
    "base-content": "#hex (main text color)",
    "info": "#hex (for informational elements)",
    "success": "#hex (for success states)",
    "warning": "#hex (for warning states)",
    "error": "#hex (for error states)"
  },
  "components": [
    "Detailed list of all reusable components created, with their purposes"
  ],
  "features": [
    "Comprehensive list of all implemented features, matching the requirements"
  ],
  "nextSteps": [
    "List of suggested improvements or additions for future iterations"
  ]
}`
        },
        {
          role: "user",
          content: `Design Prompt: ${requirementsDoc.prompt}

Requirements (MUST ALL BE IMPLEMENTED):
${formattedRequirements}

Generate a complete React/Tailwind mockup that satisfies ALL these requirements. The mockup should be immediately usable and include all necessary types and styling. Each requirement should be reflected in the implementation.`
        }
      ],
      max_completion_tokens: 25000,
      response_format: { type: "json_object" },
      reasoning_effort: 'medium'
    });

    const content = completion.choices[0].message.content;
    if (!content) {
      throw new Error('Empty response from OpenAI');
    }

    try {
      const mockupData = JSON.parse(content);

      // Validate mockup data structure
      if (!mockupData.code || !mockupData.colorScheme || !mockupData.components || !mockupData.features || !mockupData.nextSteps) {
        throw new Error('Invalid mockup data received');
      }

      // Ensure all required color scheme properties exist
      const requiredColors = [
        'primary',
        'primary-focus',
        'primary-content',
        'secondary',
        'secondary-focus',
        'secondary-content',
        'accent',
        'accent-focus',
        'accent-content',
        'neutral',
        'neutral-focus',
        'neutral-content',
        'base-100',
        'base-200',
        'base-300',
        'base-content',
        'info',
        'success',
        'warning',
        'error'
      ];

      // Fill in any missing colors with defaults
      const defaultColors: Record<string, string> = {
        'primary': '#374151',
        'primary-focus': '#1F2937',
        'primary-content': '#FFFFFF',
        'secondary': '#6B7280',
        'secondary-focus': '#4B5563',
        'secondary-content': '#FFFFFF',
        'accent': '#111827',
        'accent-focus': '#030712',
        'accent-content': '#FFFFFF',
        'neutral': '#4B5563',
        'neutral-focus': '#374151',
        'neutral-content': '#FFFFFF',
        'base-100': '#FFFFFF',
        'base-200': '#F3F4F6',
        'base-300': '#E5E7EB',
        'base-content': '#111827',
        'info': '#4B5563',
        'success': '#374151',
        'warning': '#6B7280',
        'error': '#1F2937'
      };

      // Ensure all required colors exist, use defaults if missing
      requiredColors.forEach(color => {
        if (!mockupData.colorScheme[color]) {
          mockupData.colorScheme[color] = defaultColors[color];
        }
      });

      // Remove inline type assertions from the code
      if (mockupData.code && typeof mockupData.code === 'string') {
        mockupData.code = mockupData.code.replace(/\sas\s+\w+/g, '');
      }

      return NextResponse.json(mockupData);
    } catch (parseError) {
      console.error('Error parsing mockup data:', parseError);
      return NextResponse.json(
        { error: 'Failed to parse mockup data' },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error('Error generating mockup:', error);
    return NextResponse.json(
      { error: 'Failed to generate mockup' },
      { status: 500 }
    );
  }
}


----- /Users/jackcrawford/ai-design-flow/app/api/generate-questions/route.ts -----
// /app/api/generate-questions/route.ts
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { KnowledgeBaseSource } from '@/types/settings';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(request: NextRequest) {
  try {
    const { prompt, previousQuestions, traversalMode, knowledgeBase, isAutoPopulate, currentQuestion, depth, parentContext } = await request.json();
    console.log('API received knowledge base:', knowledgeBase);

    // Calculate current depth by counting parents in previousQuestions
    let currentDepth = 0;
    let currentParent = previousQuestions[previousQuestions.length - 1];
    while (currentParent?.parent) {
      currentDepth++;
      currentParent = currentParent.parent;
    }

    // Format knowledge base content for the prompt
    const knowledgeBaseContext = knowledgeBase?.length 
      ? `The following information is available from multiple knowledge base sources:

${knowledgeBase.map((source: KnowledgeBaseSource, index: number) => `
Source ${index + 1} (${source.type === 'file' ? 'File' : 'Text'}: ${source.name}):
Requirements: ${JSON.stringify(source.processedContent?.requirements || [])}
Technical Specs: ${JSON.stringify(source.processedContent?.technicalSpecifications || [])}
Design Guidelines: ${JSON.stringify(source.processedContent?.designGuidelines || [])}
User Preferences: ${JSON.stringify(source.processedContent?.userPreferences || [])}
Industry Standards: ${JSON.stringify(source.processedContent?.industryStandards || [])}
`).join('\n')}

Use this information to:
- Auto-populate answers when confident (especially when multiple sources agree)
- Guide question generation based on available information
- Identify gaps that need to be filled
- Validate answers against known constraints
- Highlight any conflicts between different sources`
      : 'No knowledge base provided.';

    console.log('Formatted knowledge base context:', knowledgeBaseContext);

    const completion = await openai.chat.completions.create({
      model: 'o3-mini',
      messages: [
        {
          role: 'system',
          content: isAutoPopulate 
            ? `You are an expert UX design assistant that helps suggest answers based on the knowledge base and context. Your task is to provide a well-reasoned answer to the current question and return it as a JSON object.

Knowledge Base Context:
${knowledgeBaseContext}

Previous Questions Already Asked:
${previousQuestions.map((q: { question: string; answer: string }, index: number) => 
  `${index + 1}. Q: ${q.question}\n   A: ${q.answer}`
).join('\n')}

Guidelines for suggesting answers:
1. Focus ONLY on answering the current question
2. Use information from the knowledge base when available
3. Write answers in third person, making definitive statements
4. Avoid second person pronouns (your, you, yours) entirely
5. State suggestions as definitive facts that can be modified
6. Avoid hedging words like "might", "could", "probably", "likely", "maybe"
7. Make clear, direct suggestions even with low confidence
8. If multiple knowledge base sources agree, use that information with high confidence
9. If sources conflict, use the most relevant or recent information
10. If no relevant information exists, provide a reasonable suggestion based on UX best practices

Return your response in this JSON format:
{
  "questions": [],
  "shouldStopBranch": false,
  "stopReason": "",
  "suggestedAnswer": "Your suggested answer here",
  "sourceReferences": [array of source indices that contributed],
  "confidence": "high" | "medium" | "low"
}`
            : `You are an expert UX design assistant that helps generate follow-up questions for a design prompt. Your task is to generate ONE follow-up question based on the traversal mode and return it as a JSON object.

${parentContext ? `
Current Parent Question Context:
- Parent Question: "${parentContext.parentQuestion}"
- Parent Answer: "${parentContext.parentAnswer}"
- Parent Topics: ${JSON.stringify(parentContext.parentTopics)}

CRITICAL: The generated question MUST:
1. Be more specific than the parent question
2. Focus on a specific aspect mentioned in the parent's answer
3. Not repeat information already covered in the parent's answer
4. Ask for implementation details or specific requirements about topics mentioned in the parent's answer
` : ''}

Follow these guidelines:
1. Question Progression Levels:
   Current Depth: ${depth}/5
   
   BFS Mode Levels:
   - Level 1 (Basic Needs): Broad, fundamental questions about purpose, audience, and core requirements
     Example: "What is the fundamental purpose of the portfolio website?"
   - Level 2 (Features): Main sections and key features, but not specifics yet
     Example: "What main sections should be included in the navigation?"
   - Level 3 (Details): Specific details about each feature/section identified in level 2
     Example: "What project details should be displayed in each portfolio item?"
   - Level 4 (Refinements): Technical specifications and implementation details
     Example: "What image formats and sizes should be supported for project thumbnails?"
   - Level 5 (Polish): Edge cases and final refinements
     Example: "How should the portfolio handle projects with missing images?"

2. Child Question Generation Rules:
   - Child questions MUST be more specific than their parent question
   - Child questions MUST explore a specific aspect mentioned in the parent's answer
   - NEVER ask the same question as the parent with slightly different wording
   - Example progression:
     Parent Q: "What sections should the portfolio include?"
     Parent A: "The portfolio should include a projects section, about me, skills, and contact."
     Valid child Q: "What specific project details should be displayed in the projects section?"
     Invalid child Q: "What content should be included in the portfolio?"

3. Traversal Rules (${traversalMode}):
   ${traversalMode === 'bfs' 
     ? `BFS Guidelines:
        - CRITICAL: At Level 1 (top level), aim for 4-5 comprehensive questions that cover the main aspects
        - For Level 2+, each child question MUST directly reference and explore a specific aspect from its parent's answer
        - Each sibling at the same level should focus on a different aspect from the parent's answer
        - Example progression:
          Parent Q1: "What are the core user flows and functional requirements?"
          Parent A1: "The interface should offer search, filtering, and zoom levels..."
          Valid Child Q5: "What specific search capabilities should be implemented?"
          Valid Child Q6: "What filtering options should be available to users?"
          Valid Child Q7: "How should the zoom level functionality work?"

        Level Structure and Progression:
        - Level 1 (4-5 questions): Core requirements and fundamental aspects
          Example: "What are the core user flows?", "What accessibility features are needed?"
        
        - Level 2 (1 question per major aspect in parent's answer): Direct exploration of parent aspects
          Example: If Level 1 answer mentions "search, filtering, and zoom":
          * Q5 explores search
          * Q6 explores filtering
          * Q7 explores zoom
        
        - Level 3+ (2-3 questions per parent aspect): Implementation details
          Example: If parent answer about search mentions "real-time search and filters":
          * "How should real-time search results be displayed?"
          * "What search result filtering options are needed?"

        Aspect Coverage Rules:
        1. Each child question MUST:
           * Directly reference a specific aspect from parent's answer
           * Use similar terminology as the parent's answer
           * Ask for more specific details about that aspect
        
        2. Sibling questions MUST:
           * Each focus on a different aspect from parent's answer
           * Not overlap in their focus areas
           * Together cover all major aspects mentioned in parent's answer

        3. Moving Deeper Rules:
           * Only move deeper when all aspects of parent's answer are covered
           * Each deeper question should make the parent aspect more specific
           * Maintain clear topic lineage from Level 1 to current level
        
        Cycling Behavior:
        1. When a branch is fully explored (reached max depth or no more meaningful questions):
           * Move to unexplored siblings at the same level
           * If no siblings remain, move up one level and explore siblings there
           * If all existing branches are explored, return to Level 1 with new aspects
        
        2. When generating new Level 1 questions after a cycle:
           * Must cover completely different aspects than previous cycles
           * Should maintain the same level of importance/fundamentality as original Level 1
           * Example: If first cycle covered "user profiles" and "content management",
             second cycle might cover "analytics" and "performance optimization"
        
        Progression Rules:
        1. After getting 4-5 solid top-level questions answered:
           * Start exploring Level 2 for each answered Level 1 question
           * Only add new Level 1 questions if starting a new cycle
        
        2. When to move deeper:
           * Parent question is fully answered
           * Current level has 2-3 questions per parent aspect
           * Questions at current level are becoming redundant
        
        3. When to stay at current level:
           * Critical aspects still unexplored
           * Parent's answer reveals new important topics
           * Current level questions are still yielding valuable insights`
     : `DFS Guidelines:
        - CRITICAL: In DFS mode, fully explore ONE topic branch before moving to siblings
        - Maximum depth is 5 levels, but can be less if topics are fully explored
        - When all branches are exhausted, return to Level 1 with new aspects
        
        Sibling Count Guidelines:
        - Level 1: 4-5 main topic questions
        - Level 2-5: 2-3 questions per parent aspect
        
        Example proper DFS progression:
        Q1: "What are the core navigation features needed?"
        Parent Answer: "Need a main menu, search bar, and user profile section."
        
        First Branch (Main Menu):
        Q2: "What specific items should be in the main menu?"
        Q3: "How should the menu items be organized?"
        Q4: "What interactions should menu items have?"
        [Only after fully exploring menu, move to next sibling]
        
        Second Branch (Search):
        Q5: "What search functionality is required?"
        Q6: "How should search results be displayed?"
        Q7: "What advanced search options are needed?"
        [Complete search branch before moving to user profile]
        
        Third Branch (User Profile):
        Q8: "What user profile information should be shown?"
        Q9: "What profile customization options are needed?"
        
        Cycling Behavior:
        1. When a branch is fully explored:
           * Move to next sibling at current level
           * If no siblings remain, move up one level
           * If all branches are explored, return to Level 1
        
        2. When returning to Level 1:
           * Generate new top-level questions for unexplored aspects
           * Maintain same level of importance as original Level 1
           * Example: If first cycle covered "navigation features",
             second cycle might cover "user authentication"
        
        Branch Completion Rules:
        1. A branch is considered complete when:
           - All aspects of the current topic are fully explored
           - Questions have reached implementation-level detail
           - Further questions would be redundant
           - Reached maximum depth (5 levels)
           
        2. When to stop current branch (shouldStopBranch=true):
           - Reached maximum depth (5 levels)
           - All aspects from parent's answer are fully explored
           - Questions would become too specific to be useful
           - Current topic is fully defined with implementation details
           
        3. When to move to siblings:
           - ONLY after current branch is fully explored
           - When shouldStopBranch=true is returned
           - When no more meaningful child questions can be generated
           
        4. Question Depth Progression:
           Level 1: High-level feature/topic questions (4-5 questions)
           Level 2: Specific requirements for that feature (2-3 per parent)
           Level 3: Implementation details (2-3 per parent)
           Level 4: Edge cases and refinements (2-3 per parent)
           Level 5: Final optimizations (2-3 per parent)`
   }

4. Topic Management:
   - In BFS mode:
     * First identify ALL distinct aspects/topics from parent's answer
     * Generate siblings to cover EACH aspect before going deeper
     * Only mark shouldStopBranch=true if ALL aspects have been covered by siblings
   - In DFS mode:
     * Focus on exploring one aspect deeply before moving to siblings
     * Mark shouldStopBranch=true when current aspect is fully explored

5. Question Generation:
   - Generate exactly ONE question
   - For BFS mode siblings:
     * Look at parent's answer for unexplored aspects
     * Each sibling should focus on a DIFFERENT aspect
     * Return shouldStopBranch=true ONLY if no unexplored aspects remain
   - For DFS mode:
     * Focus on drilling deeper into current aspect
     * Return shouldStopBranch=true when aspect is fully explored

6. Stopping Criteria:
   - Stop current branch if:
     * Topic is fully explored (all aspects covered)
     * Further questions would be too specific
     * A different topic needs attention
     * Knowledge base provides sufficient information
     * The question would be redundant with parent's answer

7. Knowledge Base Context:
${knowledgeBaseContext}

8. Previous Questions Already Asked:
${previousQuestions.map((q: { question: string; answer: string }, index: number) => 
  `${index + 1}. Q: ${q.question}\n   A: ${q.answer}`
).join('\n')}

9. Response Format:
Return your response in this exact JSON format:
{
  "questions": ["Next question to ask"],
  "shouldStopBranch": boolean,
  "stopReason": "Detailed explanation of why we should stop this branch",
  "suggestedAnswer": "string with best guess answer based on knowledge base",
  "sourceReferences": [array of source indices that contributed],
  "confidence": "high" | "medium" | "low",
  "topicsCovered": ["list of topics this question relates to"],
  "parentTopic": "The main topic this question belongs to",
  "subtopics": ["Potential child topics for this question"]
}`
        },
        {
          role: 'user',
          content: isAutoPopulate
            ? `The design prompt is: "${prompt}"

Current Question: "${currentQuestion}"

Based on the knowledge base and previous Q&A context:
1. Analyze the knowledge base for relevant information about this specific question
2. Consider the context from previous questions and answers
3. Provide a clear, direct answer following the guidelines
4. Indicate which knowledge base sources (if any) contributed to the answer
5. Rate your confidence in the answer as high/medium/low

Return your response in this format:
{
  "questions": [],
  "shouldStopBranch": false,
  "stopReason": "",
  "suggestedAnswer": "Your suggested answer here",
  "sourceReferences": [array of source indices that contributed],
  "confidence": "high" | "medium" | "low"
}`
            : `The design prompt is: "${prompt}".
Previous Q&A History:
${JSON.stringify(previousQuestions, null, 2)}

Current Question: ${previousQuestions[previousQuestions.length - 1]?.question || 'Initial question'}

CRITICAL REQUIREMENTS:
1. Review ALL previous questions and their topics carefully
2. Generate ONE question that explores a COMPLETELY DIFFERENT aspect not covered in ANY previous question
3. For BFS mode, ensure the new question:
   - Stays at the same level
   - Covers a new topic not related to any previous questions
   - Follows the level-specific topic guidelines
4. Provide a suggested answer following the guidelines

Topics already covered (DO NOT ask about these or related topics):
${previousQuestions.map((q: { question: string }, index: number) => 
  `${index + 1}. ${q.question}`
).join('\n')}

Remember:
- NEVER repeat a topic that's been covered in previous questions
- Each new question must explore a different aspect of the design
- In BFS mode, stay at the current level but explore new topics
- Make clear, direct statements in suggested answers
- Never use second person pronouns`
        }
      ],
      max_completion_tokens: 4000,
      response_format: { type: "json_object" },
      reasoning_effort: 'medium'
    });

    const content = completion.choices[0].message.content?.trim();
    if (!content) {
      console.error('Empty response from OpenAI');
      // Return a default response instead of throwing
      return NextResponse.json({
        questions: ["What are the core features needed for this design?"],
        shouldStopBranch: false,
        stopReason: "",
        suggestedAnswer: null,
        sourceReferences: [],
        confidence: "low",
        topicsCovered: ["core_features"],
        parentTopic: "requirements",
        subtopics: []
      });
    }

    console.log('Raw OpenAI response:', content);

    let response: {
      questions: string[];
      shouldStopBranch: boolean;
      stopReason: string;
      suggestedAnswer: string | null;
      sourceReferences: number[];
      confidence?: 'high' | 'medium' | 'low';
      topicsCovered: string[];
      parentTopic: string;
      subtopics: string[];
    };

    try {
      // First try to parse the JSON response
      response = JSON.parse(content);
      
      // Ensure required fields exist with defaults
      response = {
        questions: Array.isArray(response.questions) ? response.questions : [response.questions || "What are the core features needed for this design?"],
        shouldStopBranch: response.shouldStopBranch || false,
        stopReason: response.stopReason || "",
        suggestedAnswer: response.suggestedAnswer || null,
        sourceReferences: response.sourceReferences || [],
        confidence: response.confidence || "low",
        topicsCovered: response.topicsCovered || [],
        parentTopic: response.parentTopic || "requirements",
        subtopics: response.subtopics || []
      };

      // Clean up questions to ensure they're plain text
      response.questions = response.questions.map((q: any) => {
        if (typeof q === 'string') return q;
        return q.question || q.text || JSON.stringify(q);
      }).filter(Boolean);

      // If no valid questions after cleanup, provide a default
      if (response.questions.length === 0) {
        response.questions = ["What are the core features needed for this design?"];
      }

      console.log('Formatted response:', response);
      return NextResponse.json(response);
    } catch (jsonError) {
      console.error("Error parsing API response:", jsonError);
      console.error("Raw content causing parse error:", content);
      
      // Try to extract a valid question from the partial response
      let extractedQuestion = "What are the core features needed for this design?";
      try {
        const questionMatch = content.match(/"questions":\s*\[\s*"([^"]+)"/);
        if (questionMatch && questionMatch[1]) {
          extractedQuestion = questionMatch[1];
        }
      } catch (e) {
        console.error("Failed to extract question from partial response");
      }
      
      // Provide a default response using any extracted data
      return NextResponse.json({
        questions: [extractedQuestion],
        shouldStopBranch: false,
        stopReason: "",
        suggestedAnswer: null,
        sourceReferences: [],
        confidence: "low",
        topicsCovered: ["core_features"],
        parentTopic: "requirements",
        subtopics: []
      });
    }
  } catch (error) {
    console.error('Error generating questions:', error);
    return NextResponse.json(
      { error: 'Failed to generate questions' },
      { status: 500 }
    );
  }
}


----- /Users/jackcrawford/ai-design-flow/app/api/process-knowledge-base/route.ts -----
import { NextRequest } from 'next/server';
import OpenAI from 'openai';
import pdfParse from 'pdf-parse';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

async function extractTextFromPDF(buffer: Buffer): Promise<string> {
  try {
    const data = await pdfParse(buffer);
    return data.text;
  } catch (error) {
    console.error('Error extracting text from PDF:', error);
    throw new Error('Failed to extract text from PDF');
  }
}

async function processContent(content: string) {
  try {
    console.log('Starting content processing...');
    const completion = await openai.chat.completions.create({
      model: "o3-mini",
      messages: [
        {
          role: "system",
          content: `You are a knowledge base processor. Extract key information from the provided document and return it as a JSON object. Focus on:
1. Requirements and constraints
2. Technical specifications
3. Design guidelines
4. User preferences or patterns
5. Industry standards or best practices

Return your response in this exact JSON format:
{
  "requirements": [],
  "technicalSpecifications": [],
  "designGuidelines": [],
  "userPreferences": [],
  "industryStandards": []}`
        },
        {
          role: "user",
          content
        }
      ],
      max_completion_tokens: 4000,
      response_format: { type: "json_object" },
      reasoning_effort: 'medium'
    });

    console.log('OpenAI response received');
    const responseContent = completion.choices[0].message.content;
    if (!responseContent) {
      console.error('Empty response content from OpenAI');
      throw new Error('Empty response from OpenAI');
    }

    try {
      const parsedContent = JSON.parse(responseContent);
      console.log('Successfully parsed OpenAI response');
      return parsedContent;
    } catch (parseError) {
      console.error('Error parsing OpenAI response:', parseError, '\nResponse content:', responseContent);
      throw new Error('Failed to parse OpenAI response');
    }
  } catch (error) {
    console.error('Error in processContent:', error);
    if (error instanceof Error) {
      throw new Error(`Failed to process content: ${error.message}`);
    }
    throw new Error('Failed to process content: Unknown error');
  }
}

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const sourceType = formData.get('type');
    const file = formData.get('file');
    const textContent = formData.get('content');

    if (!sourceType) {
      return new Response(JSON.stringify({ error: 'Source type is required' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    let content: string;

    if (sourceType === 'file' && file) {
      // Check if the file has arrayBuffer method (indicating it's a File or Blob)
      const fileObject = file as { arrayBuffer(): Promise<ArrayBuffer>; type?: string; name?: string };
      
      if ('arrayBuffer' in fileObject && typeof fileObject.arrayBuffer === 'function') {
        const buffer = Buffer.from(await fileObject.arrayBuffer());
        
        // Check file type using the file's type property or name
        const fileType = fileObject.type || '';
        const fileName = fileObject.name || '';
        
        if (fileType === 'application/pdf' || fileName.toLowerCase().endsWith('.pdf')) {
          content = await extractTextFromPDF(buffer);
        } else {
          // For text files, convert buffer to string
          content = buffer.toString('utf-8');
        }
      } else {
        throw new Error('Invalid file format');
      }
    } else if (sourceType === 'text' && typeof textContent === 'string') {
      content = textContent;
    } else {
      return new Response(JSON.stringify({ error: 'Invalid input' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    const processedContent = await processContent(content);

    return new Response(JSON.stringify({ success: true, processedContent }), {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
    });

  } catch (error: unknown) {
    console.error('Error in API route:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
    return new Response(JSON.stringify({ error: 'Internal server error', details: errorMessage }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
} 

----- /Users/jackcrawford/ai-design-flow/app/api/update-requirements/route.ts -----
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { RequirementsDocument, QANode, RequirementCategory } from '@/types';
import { KnowledgeBaseSource } from '@/types/settings';
import { v4 as uuidv4 } from 'uuid';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

function findNodeById(root: QANode | null, id: string): QANode | null {
  if (!root) return null;
  if (root.id === id) return root;
  for (const child of root.children) {
    const found = findNodeById(child, id);
    if (found) return found;
  }
  return null;
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    console.log('Received update request:', body);
    
    const { qaTree, currentNodeId, knowledgeBase, existingDocument } = body;
    
    if (!qaTree || !existingDocument) {
      return NextResponse.json(
        { error: 'QA Tree and existing document are required' },
        { status: 400 }
      );
    }
    
    // Find the current node that was just answered
    const currentNode = currentNodeId ? findNodeById(qaTree, currentNodeId) : null;
    
    // Format the Q&A history and knowledge base for the AI
    const qaContext = JSON.stringify({
      question: currentNode?.question || 'No current question',
      answer: currentNode?.answer || 'No answer',
      previousQuestions: qaTree.children.map((node: QANode) => ({
        question: node.question,
        answer: node.answer
      }))
    }, null, 2);

    const knowledgeBaseContext = knowledgeBase?.length
      ? knowledgeBase.map((source: KnowledgeBaseSource, index: number) => 
          `Source ${index + 1}: ${Object.entries(source.processedContent || {})
            .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
            .join('\n')}`
        ).join('\n\n')
      : 'No knowledge base provided';

    console.log('Sending to OpenAI:', {
      qaContext: qaContext.substring(0, 100) + '...',
      knowledgeBaseContext: knowledgeBaseContext.substring(0, 100) + '...'
    });

    const completion = await openai.chat.completions.create({
      model: "o3-mini",
      messages: [
        {
          role: "system",
          content: `You are a requirements document updater. Your task is to update a requirements document based on Q&A session information and knowledge base data and return it as a JSON object.

CRITICAL INSTRUCTIONS:
1. You MUST return ONLY a valid JSON object.
2. DO NOT include any explanatory text, markdown, or other content.
3. DO NOT wrap the JSON in code blocks or quotes.
4. The JSON must exactly match this structure:
{
  "id": string,
  "prompt": string,
  "lastUpdated": string (ISO date),
  "categories": {
    "basicNeeds": {
      "title": "Basic Needs",
      "requirements": []
    },
    "functionalRequirements": {
      "title": "Functional Requirements",
      "requirements": []
    },
    "userExperience": {
      "title": "User Experience",
      "requirements": []
    },
    "implementation": {
      "title": "Implementation",
      "requirements": []
    },
    "refinements": {
      "title": "Refinements",
      "requirements": []
    },
    "constraints": {
      "title": "Constraints",
      "requirements": []
    }
  }
}`
        },
        {
          role: "user",
          content: `Current Document: ${JSON.stringify(existingDocument)}
Latest Q&A: ${qaContext}
Knowledge Base: ${knowledgeBaseContext}

Update the requirements document with any new information from the Q&A and knowledge base. Return ONLY the updated document as a JSON object.`
        }
      ],
      max_completion_tokens: 16000,
      response_format: { type: "json_object" },
      reasoning_effort: 'medium'
    });

    const content = completion.choices[0].message.content;
    if (!content) {
      console.error('Empty response from OpenAI');
      console.log('Returning existing document due to empty OpenAI response');
      return NextResponse.json(existingDocument);
    }

    console.log('OpenAI response:', content.substring(0, 100) + '...');

    try {
      const updatedDocument = JSON.parse(content);
      
      // Validate the document structure
      if (!updatedDocument.id || !updatedDocument.categories) {
        console.error('Invalid document structure:', updatedDocument);
        console.log('Returning existing document due to invalid structure');
        return NextResponse.json(existingDocument);
      }
      
      // Helper function to determine requirement category and tags
      function analyzeRequirement(text: string): {
        category: 'functional' | 'technical' | 'ux' | 'accessibility' | 'security' | 'performance';
        tags: string[];
        priority: 'high' | 'medium' | 'low';
      } {
        const textLower = text.toLowerCase();
        let category: 'functional' | 'technical' | 'ux' | 'accessibility' | 'security' | 'performance' = 'functional';
        const tags: string[] = [];
        let priority: 'high' | 'medium' | 'low' = 'medium';

        // Category determination
        if (textLower.includes('security') || textLower.includes('emergency') || textLower.includes('safety')) {
          category = 'security';
          priority = 'high';
          tags.push('safety');
        } else if (textLower.includes('user') || textLower.includes('interface') || textLower.includes('display') || textLower.includes('visual')) {
          category = 'ux';
          tags.push('interface');
        } else if (textLower.includes('performance') || textLower.includes('speed') || textLower.includes('efficiency')) {
          category = 'performance';
          tags.push('optimization');
        } else if (textLower.includes('accessible') || textLower.includes('disability')) {
          category = 'accessibility';
          priority = 'high';
          tags.push('ada-compliance');
        } else if (textLower.includes('technical') || textLower.includes('system') || textLower.includes('integration')) {
          category = 'technical';
          tags.push('integration');
        }

        // Additional tags based on content
        if (textLower.includes('monitor') || textLower.includes('sensor')) {
          tags.push('monitoring');
        }
        if (textLower.includes('data') || textLower.includes('analytics')) {
          tags.push('data');
        }
        if (textLower.includes('ai') || textLower.includes('machine learning')) {
          tags.push('ai');
        }
        if (textLower.includes('maintenance')) {
          tags.push('maintenance');
        }
        if (textLower.includes('real-time') || textLower.includes('realtime')) {
          tags.push('real-time');
        }

        // Priority determination (if not already set by category)
        if (priority === 'medium') {
          if (textLower.includes('critical') || textLower.includes('essential') || textLower.includes('must')) {
            priority = 'high';
          } else if (textLower.includes('optional') || textLower.includes('nice to have')) {
            priority = 'low';
          }
        }

        return { category, tags, priority };
      }

      // Ensure all requirements have proper structure and IDs
      Object.values(updatedDocument.categories).forEach((category: any) => {
        if (Array.isArray(category.requirements)) {
          category.requirements = category.requirements.map((req: string | any) => {
            // If the requirement is just a string, convert it to proper structure
            if (typeof req === 'string') {
              const analysis = analyzeRequirement(req);
              return {
                id: uuidv4(),
                text: req,
                source: 'user-qa',
                priority: analysis.priority,
                category: analysis.category,
                tags: analysis.tags,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
              };
            }
            // If it's already an object but missing ID
            if (!req.id) {
              const analysis = analyzeRequirement(req.text);
              req.id = uuidv4();
              req.priority = req.priority || analysis.priority;
              req.category = req.category || analysis.category;
              req.tags = req.tags || analysis.tags;
              req.createdAt = new Date().toISOString();
              req.updatedAt = new Date().toISOString();
            }
            return req;
          });
        } else {
          category.requirements = [];
        }
      });
      
      // Ensure all required categories exist
      const requiredCategories = [
        'basicNeeds',
        'functionalRequirements',
        'userExperience',
        'implementation',
        'refinements',
        'constraints'
      ];
      
      const hasAllCategories = requiredCategories.every(
        category => updatedDocument.categories[category]
      );
      
      if (!hasAllCategories) {
        console.error('Missing required categories');
        console.log('Returning existing document due to missing categories');
        return NextResponse.json(existingDocument);
      }
      
      return NextResponse.json(updatedDocument);
    } catch (parseError) {
      console.error('Error parsing OpenAI response:', parseError);
      console.error('Raw response:', content);
      // If parsing fails, return the existing document unchanged
      console.log('Returning existing document due to parse error');
      return NextResponse.json(existingDocument);
    }
  } catch (error) {
    console.error('Error updating requirements:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error occurred' },
      { status: 500 }
    );
  }
} 

----- /Users/jackcrawford/ai-design-flow/app/preview/page.tsx -----
'use client';

import { useEffect, useState } from 'react';
import PreviewArea from '@/components/PreviewArea';
import HeaderToolbar from '@/components/HeaderToolbar';

export default function PreviewPage() {
  const [generatedContent, setGeneratedContent] = useState({
    requirements: '',
    uiCode: '',
  });

  useEffect(() => {
    const storedContent = localStorage.getItem('generatedContent');
    if (storedContent) {
      setGeneratedContent(JSON.parse(storedContent));
    }
  }, []);

  return (
    <div className="min-h-screen flex flex-col">
      <HeaderToolbar />
      <main className="flex-1 container mx-auto px-4 py-8">
        <h1 className="text-3xl font-bold mb-8">Generated Preview</h1>
        <PreviewArea
          requirements={generatedContent.requirements}
          uiCode={generatedContent.uiCode}
        />
      </main>
    </div>
  );
}

----- /Users/jackcrawford/ai-design-flow/app/qna/page.tsx -----
// /app/qna/page.tsx
'use client';

import { useEffect, useRef, useState } from 'react';
import { useRouter } from 'next/navigation';
import { v4 as uuidv4 } from 'uuid';
import HeaderToolbar from '../../components/HeaderToolbar';
import QAPanel from '../../components/QAPanel';
import CanvasTree from '../../components/CanvasTree';
import { QANode, RequirementsDocument, MockupVersion, SessionMetadata } from '@/types';
import { QASettings } from '@/types/settings';
import PreviewPanel from '../../components/PreviewPanel';

interface SavedProgress {
  qaTree: QANode;
  currentNodeId: string | null;
  questionCount: number;
  prompt: string;
  settings: QASettings;
  requirementsDoc: RequirementsDocument;
}

interface QuestionHistoryItem {
  question: string;
  answer?: string;
  topics: string[];
}

export default function QnAPage() {
  const router = useRouter();
  const hasFetchedInitialQuestion = useRef(false);
  const [prompt, setPrompt] = useState<string>('');
  const [settings, setSettings] = useState<QASettings | null>(null);
  const [qaTree, setQaTree] = useState<QANode | null>(null);
  const [currentNode, setCurrentNode] = useState<QANode | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isLoadingNextQuestion, setIsLoadingNextQuestion] = useState(false);
  const [questionCount, setQuestionCount] = useState(0);
  const [suggestedAnswer, setSuggestedAnswer] = useState<{
    text: string;
    confidence: 'high' | 'medium' | 'low';
    sourceReferences: number[];
  } | null>(null);
  const [requirementsDoc, setRequirementsDoc] = useState<RequirementsDocument | null>(null);
  const [askedQuestions, setAskedQuestions] = useState<Set<string>>(new Set());
  const [askedTopics, setAskedTopics] = useState<Set<string>>(new Set());
  const [isPreviewOpen, setIsPreviewOpen] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [sessionMetadata, setSessionMetadata] = useState<SessionMetadata | null>(null);
  const [isLeavingPage, setIsLeavingPage] = useState(false);
  const [isInitialLoad, setIsInitialLoad] = useState(true);

  // Helper: Extract topics from a question
  const extractTopics = (question: string): string[] => {
    const topics = [];
    // Common topic indicators in questions
    if (question.toLowerCase().includes('audience') || 
        question.toLowerCase().includes('user') || 
        question.toLowerCase().includes('visitor')) {
      topics.push('audience');
    }
    if (question.toLowerCase().includes('purpose') || 
        question.toLowerCase().includes('goal')) {
      topics.push('purpose');
    }
    // Add more topic extractors as needed
    return topics;
  };

  // Helper: Get the next question based on traversal mode
  const getNextQuestion = async (node: QANode): Promise<QANode | null> => {
    const isDFS = settings?.traversalMode === 'dfs';
    
    if (isDFS) {
      // DFS: Try to go deeper first by exploring the current topic fully
      if (node.answer) {
        // Build complete question history including topics for the current branch
        const branchHistory: QuestionHistoryItem[] = [];
        let current: QANode | null = node;
        let depth = 0;
        
        // Collect the current branch's history and calculate depth
        while (current) {
          if (current.question !== `Prompt: ${prompt}`) {
            branchHistory.unshift({
              question: current.question,
              answer: current.answer,
              topics: extractTopics(current.question)
            });
            depth++;
          }
          const parent = findParentNode(qaTree!, current);
          if (!parent || parent === current) break;
          current = parent;
        }

        // First try to go deeper by generating a child question
        // Make multiple attempts to get a valid child question
        for (let attempt = 0; attempt < 3; attempt++) {
          const { nodes: children, shouldStopBranch } = await fetchQuestionsForNode(
            prompt, 
            node,
            branchHistory,
            depth,
            true
          );
          
          // If we can go deeper and got valid children
          if (!shouldStopBranch && children.length > 0) {
            const newQuestionTopics = extractTopics(children[0].question);
            const currentTopics = extractTopics(node.question);
            
            // Verify the child question is related to current topic
            const isRelatedTopic = currentTopics.some(topic => 
              newQuestionTopics.includes(topic) || 
              newQuestionTopics.some(t => t.includes(topic))
            );

            if (isRelatedTopic) {
              children[0].questionNumber = questionCount + 1;
              node.children = children;
              return children[0];
            }
          }
          
          // If shouldStopBranch is true, break the retry loop
          if (shouldStopBranch) break;
        }
        
        // If we can't go deeper after attempts, try to move to the next sibling
        const parent = findParentNode(qaTree!, node);
        if (parent) {
          const siblings = parent.children;
          const currentIndex = siblings.indexOf(node);
          
          // If there are more siblings at this level, move to the next sibling
          if (currentIndex < siblings.length - 1) {
            return siblings[currentIndex + 1];
          }
          
          // If no more siblings at this level, go up one level and try those siblings
          let ancestor = parent;
          let previousNode = node;
          
          while (ancestor) {
            const ancestorParent = findParentNode(qaTree!, ancestor);
            if (!ancestorParent) {
              // We've reached the root, generate new Level 1 questions
              const rootHistory = getAllAnsweredQuestions(qaTree!);
              const { nodes: newTopLevel } = await fetchQuestionsForNode(
                prompt,
                qaTree!,
                rootHistory,
                1,
                true
              );
              
              if (newTopLevel.length > 0) {
                newTopLevel[0].questionNumber = questionCount + 1;
                qaTree!.children = [...qaTree!.children, ...newTopLevel];
                return newTopLevel[0];
              }
            }
            
            const uncles = ancestorParent?.children || [];
            const ancestorIndex = uncles.indexOf(ancestor);
            
            // If there are more siblings at this ancestor's level, use the next one
            if (ancestorIndex < uncles.length - 1) {
              return uncles[ancestorIndex + 1];
            }
            
            previousNode = ancestor;
            ancestor = ancestorParent as QANode;  // Fix type assertion
          }
        }
      }
      
      // If we reach here, generate new Level 1 questions
      const rootHistory = getAllAnsweredQuestions(qaTree!);
      const { nodes: newTopLevel } = await fetchQuestionsForNode(
        prompt,
        qaTree!,
        rootHistory,
        1,
        true
      );
      
      if (newTopLevel.length > 0) {
        newTopLevel[0].questionNumber = questionCount + 1;
        qaTree!.children = [...qaTree!.children, ...newTopLevel];
        return newTopLevel[0];
      }
      
    } else {
      // BFS: Complete all questions at the current level before going deeper
      const parent = findParentNode(qaTree!, node);
      if (!parent) {
        // We're at the root, generate new Level 1 questions
        const rootHistory = getAllAnsweredQuestions(qaTree!);
        const { nodes: newTopLevel } = await fetchQuestionsForNode(
          prompt,
          qaTree!,
          rootHistory,
          1,
          true
        );
        
        if (newTopLevel.length > 0) {
          newTopLevel[0].questionNumber = questionCount + 1;
          qaTree!.children = [...qaTree!.children, ...newTopLevel];
          return newTopLevel[0];
        }
        return null;
      }
      
      // Get all nodes at the current level
      const currentLevelNodes = parent.children;
      const currentIndex = currentLevelNodes.indexOf(node);
      const currentDepth = getNodeDepth(node);
      
      // Extract aspects from parent's answer that need to be covered
      const parentAspects = parent.answer ? 
        extractAspectsFromAnswer(parent.answer) : 
        ['basic_requirements'];
      
      // Get aspects already covered by existing siblings
      const coveredAspects = new Set(
        currentLevelNodes
          .filter(n => n.answer) // Only consider answered questions
          .map(n => {
            const topics = extractTopics(n.question);
            // Also check if the question directly references parent aspects
            return topics.filter(topic => 
              parentAspects.some(aspect => 
                topic.includes(aspect) || aspect.includes(topic)
              )
            );
          })
          .flat()
      );
      
      // Build question history for current level
      const levelHistory: QuestionHistoryItem[] = currentLevelNodes
        .filter(n => n.answer)
        .map(n => ({
          question: n.question,
          answer: n.answer,
          topics: extractTopics(n.question)
        }));
      
      // Check if all nodes at current level are answered
      const allCurrentLevelAnswered = currentLevelNodes.every(n => n.answer);
      
      // If there are existing unanswered siblings, move to the next one
      if (currentIndex < currentLevelNodes.length - 1) {
        return currentLevelNodes[currentIndex + 1];
      }
      
      // Determine if we need more siblings at this level
      const isTopLevel = currentDepth === 1;
      const uncoveredAspects = parentAspects.filter(aspect => !coveredAspects.has(aspect));
      const hasEnoughTopLevelQuestions = isTopLevel && currentLevelNodes.length >= 4;
      const hasEnoughSiblingsForLevel = !isTopLevel && currentLevelNodes.length >= 3;
      
      const shouldGenerateMoreSiblings = 
        // At top level, generate more if we don't have enough questions AND have uncovered aspects
        (isTopLevel && !hasEnoughTopLevelQuestions && uncoveredAspects.length > 0) ||
        // At other levels, only generate more if we have uncovered aspects AND haven't hit the sibling limit
        (!isTopLevel && uncoveredAspects.length > 0 && !hasEnoughSiblingsForLevel);

      // Try to generate new siblings if needed
      if (shouldGenerateMoreSiblings) {
        const { nodes: newSiblings } = await fetchQuestionsForNode(
          prompt,
          parent,
          levelHistory,
          currentDepth,
          true,
          uncoveredAspects
        );
        
        if (newSiblings.length > 0) {
          newSiblings[0].questionNumber = questionCount + 1;
          parent.children = [...currentLevelNodes, ...newSiblings];
          return newSiblings[0];
        }
      }
      
      // If all current level questions are answered and we have enough coverage, try to go deeper
      if (allCurrentLevelAnswered && 
          (isTopLevel ? hasEnoughTopLevelQuestions : currentLevelNodes.length >= 2)) {
        // Find the first answered node that doesn't have children yet
        for (const sibling of currentLevelNodes) {
          if (sibling.answer && sibling.children.length === 0) {
            const siblingHistory = levelHistory.filter(h => 
              extractTopics(h.question).some(t => 
                extractTopics(sibling.question).includes(t)
              )
            );
            
            const { nodes: children } = await fetchQuestionsForNode(
              prompt,
              sibling,
              siblingHistory,
              currentDepth + 1,
              true
            );
            
            if (children.length > 0) {
              children[0].questionNumber = questionCount + 1;
              sibling.children = children;
              return children[0];
            }
          }
        }
        
        // If we couldn't go deeper, generate new Level 1 questions
        const rootHistory = getAllAnsweredQuestions(qaTree!);
        const { nodes: newTopLevel } = await fetchQuestionsForNode(
          prompt,
          qaTree!,
          rootHistory,
          1,
          true
        );
        
        if (newTopLevel.length > 0) {
          newTopLevel[0].questionNumber = questionCount + 1;
          qaTree!.children = [...qaTree!.children, ...newTopLevel];
          return newTopLevel[0];
        }
      }
    }
    
    // If we reach here, try generating new Level 1 questions as a fallback
    const rootHistory = getAllAnsweredQuestions(qaTree!);
    const { nodes: newTopLevel } = await fetchQuestionsForNode(
      prompt,
      qaTree!,
      rootHistory,
      1,
      true
    );
    
    if (newTopLevel.length > 0) {
      newTopLevel[0].questionNumber = questionCount + 1;
      qaTree!.children = [...qaTree!.children, ...newTopLevel];
      return newTopLevel[0];
    }
    
    return null; // This should never be reached in practice
  };

  // Helper: Get all answered questions from the tree
  const getAllAnsweredQuestions = (root: QANode): QuestionHistoryItem[] => {
    const history: QuestionHistoryItem[] = [];
    const traverse = (node: QANode) => {
      if (node.question !== `Prompt: ${prompt}` && node.answer) {
        history.push({
          question: node.question,
          answer: node.answer,
          topics: extractTopics(node.question)
        });
      }
      node.children.forEach(traverse);
    };
    traverse(root);
    return history;
  };

  // Helper: Get the depth of a node in the tree
  const getNodeDepth = (node: QANode): number => {
    let depth = 0;
    let current = node;
    while (findParentNode(qaTree!, current)) {
      depth++;
      current = findParentNode(qaTree!, current)!;
    }
    return depth;
  };

  // Helper: Find parent node
  const findParentNode = (root: QANode | null, target: QANode): QANode | null => {
    if (!root) return null;
    if (root.children.includes(target)) return root;
    for (const child of root.children) {
      const found = findParentNode(child, target);
      if (found) return found;
    }
    return null;
  };

  // Helper: Find all nodes at the same level as the target node
  const findNodesAtSameLevel = (root: QANode | null, target: QANode): QANode[] => {
    if (!root) return [];
    const parent = findParentNode(root, target);
    if (!parent) return root.children; // If no parent, must be root level
    return parent.children;
  };

  // Helper: Find the first unanswered child in the tree (BFS)
  const findFirstUnansweredChild = (root: QANode | null): QANode | null => {
    if (!root) return null;
    const queue: QANode[] = [root];
    while (queue.length > 0) {
      const node = queue.shift()!;
      // Skip the root node when looking for unanswered questions
      if (node.children.length > 0) {
        for (const child of node.children) {
          if (!child.answer) return child;
          queue.push(child);
        }
      } else if (!node.answer && node.question !== `Prompt: ${prompt}`) {
        return node;
      }
    }
    return null;
  };

  // Helper: Find the first node that can have children (has answer but no children)
  const findFirstNodeForChildren = (root: QANode | null): QANode | null => {
    if (!root) return null;
    const queue: QANode[] = [root];
    while (queue.length > 0) {
      const node = queue.shift()!;
      // Skip the root node when looking for nodes that can have children
      if (node.answer && node.children.length === 0 && node.question !== `Prompt: ${prompt}`) {
        return node;
      }
      queue.push(...node.children);
    }
    return null;
  };

  // Helper: fetch questions for a node
  const fetchQuestionsForNode = async (
    designPrompt: string, 
    parentNode: QANode, 
    questionHistory: QuestionHistoryItem[], 
    depth: number, 
    setSuggestion: boolean = false,
    uncoveredAspects?: string[]
  ): Promise<{ nodes: QANode[], shouldStopBranch: boolean, stopReason: string, suggestedAnswer?: string }> => {
    try {
      console.log('Fetching questions with knowledge base:', settings?.knowledgeBase);
      
      // Get parent context for child questions
      const parentContext = parentNode.question !== `Prompt: ${designPrompt}` ? {
        parentQuestion: parentNode.question,
        parentAnswer: parentNode.answer,
        parentTopics: extractTopics(parentNode.question),
        uncoveredAspects // Add uncovered aspects to parent context
      } : null;
      
      const response = await fetch('/api/generate-questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt: designPrompt,
          previousQuestions: questionHistory,
          traversalMode: settings?.traversalMode,
          knowledgeBase: settings?.knowledgeBase,
          depth: depth,
          parentContext: parentContext,
          includeSuggestions: setSuggestion,
          uncoveredAspects // Pass uncovered aspects to API
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error occurred' }));
        throw new Error(`API request failed: ${errorData.error || response.statusText}`);
      }

      const data = await response.json();
      console.log('Received API response with suggested answer:', data.suggestedAnswer);
      
      if (!data || !Array.isArray(data.questions) || data.questions.length === 0) {
        throw new Error('Invalid response format or no questions received');
      }

      // Only set suggested answer if explicitly requested
      if (setSuggestion) {
        if (data.suggestedAnswer) {
          console.log('Setting suggested answer:', {
            text: data.suggestedAnswer,
            confidence: data.confidence || 'low',
            sourceReferences: data.sourceReferences || []
          });
          
          setSuggestedAnswer({
            text: data.suggestedAnswer,
            confidence: data.confidence || 'low',
            sourceReferences: data.sourceReferences || []
          });
        } else {
          console.log('Clearing suggested answer');
          setSuggestedAnswer(null);
        }
      }
      
      // Create a single child node with the next question number
      const nextQuestionNumber = questionCount + 1;
      const nodes: QANode[] = data.questions.slice(0, 1).map((q: string) => ({
        id: uuidv4(),
        question: q,
        children: [],
        questionNumber: nextQuestionNumber,
      }));
      
      return {
        nodes,
        shouldStopBranch: data.shouldStopBranch || false,
        stopReason: data.stopReason || 'No more questions needed',
        suggestedAnswer: data.suggestedAnswer
      };
    } catch (error) {
      console.error("Error in fetchQuestionsForNode:", error);
      // Return a default error question node
      const errorNode: QANode = {
        id: uuidv4(),
        question: "Failed to generate question. Please try again or refresh the page.",
        children: [],
        questionNumber: questionCount + 1,
      };
      return { 
        nodes: [errorNode], 
        shouldStopBranch: true, 
        stopReason: error instanceof Error ? error.message : "Error generating questions",
        suggestedAnswer: undefined
      };
    }
  };

  // Helper: Find node by ID in the tree
  const findNodeById = (root: QANode | null, id: string): QANode | null => {
    if (!root) return null;
    if (root.id === id) return root;
    for (const child of root.children) {
      const found = findNodeById(child, id);
      if (found) return found;
    }
    return null;
  };

  // Helper: Update requirements document
  const updateRequirements = async (nodeId: string | null) => {
    try {
      if (!qaTree || !requirementsDoc) {
        console.warn('Missing qaTree or requirementsDoc, skipping requirements update');
        return;
      }

      const response = await fetch('/api/update-requirements', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          qaTree,
          currentNodeId: nodeId,
          knowledgeBase: settings?.knowledgeBase,
          existingDocument: requirementsDoc
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error occurred' }));
        throw new Error(`API request failed: ${errorData.error || response.statusText}`);
      }

      const updatedDoc = await response.json();
      if (!updatedDoc || !updatedDoc.categories) {
        throw new Error('Invalid requirements document received');
      }

      setRequirementsDoc(updatedDoc);
      
      // Save progress including requirements
      saveProgress();
    } catch (error) {
      console.error('Error updating requirements:', error);
      // Don't throw the error, just log it and continue
    }
  };

  // Auto-save timer
  useEffect(() => {
    const autoSaveInterval = setInterval(() => {
      if (qaTree) {
        saveProgress(true);
      }
    }, 60000); // Auto-save every minute

    return () => clearInterval(autoSaveInterval);
  }, [qaTree, currentNode, questionCount, prompt, settings]);

  // Handle page leave
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (!isLeavingPage) {
        e.preventDefault();
        e.returnValue = '';
        saveProgress(true);
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);
    return () => window.removeEventListener('beforeunload', handleBeforeUnload);
  }, [isLeavingPage]);

  // Helper: Save current progress
  const saveProgress = (isAutoSave = false) => {
    if (!qaTree || !settings || !requirementsDoc) return;

    try {
      // Update session metadata
      const currentTime = new Date().toISOString();
      const metadata: SessionMetadata = {
        id: sessionMetadata?.id || uuidv4(),
        prompt,
        lastUpdated: currentTime,
        questionCount,
        versions: [],
        settings: {
          traversalMode: settings.traversalMode,
          unknownHandling: settings.unknownHandling,
          conflictResolution: settings.conflictResolution
        },
        name: sessionMetadata?.name
      };

      // Save progress and metadata
      localStorage.setItem('qaProgress', JSON.stringify({
        qaTree,
        currentNodeId: currentNode?.id || null,
        questionCount,
        prompt,
        settings,
        requirementsDoc
      }));

      localStorage.setItem('sessionMetadata', JSON.stringify(metadata));
      setSessionMetadata(metadata);

      if (!isAutoSave) {
        // Show success message for manual saves
        // TODO: Add a toast notification system
        console.log('Progress saved successfully');
      }
    } catch (error) {
      console.error('Error saving progress:', error);
      // TODO: Add error notification
    }
  };

  const handleVersionRestore = (version: MockupVersion) => {
    // Confirm before restoring
    if (window.confirm('Restoring this version will replace your current progress. Continue?')) {
      setQaTree(version.qaTree);
      setRequirementsDoc(version.requirementsDoc);
      
      // Find the first unanswered question in the restored tree
      const firstUnanswered = findFirstUnansweredChild(version.qaTree);
      setCurrentNode(firstUnanswered);
      
      // Update question count
      let count = 0;
      const countAnswers = (node: QANode) => {
        if (node.answer) count++;
        node.children.forEach(countAnswers);
      };
      countAnswers(version.qaTree);
      setQuestionCount(count);
      
      // Save the restored state
      saveProgress();
    }
  };

  const handleSaveSession = (name?: string) => {
    if (sessionMetadata) {
      const updatedMetadata = {
        ...sessionMetadata,
        name,
        lastUpdated: new Date().toISOString()
      };
      setSessionMetadata(updatedMetadata);
      localStorage.setItem('sessionMetadata', JSON.stringify(updatedMetadata));
      saveProgress();
    }
  };

  // On mount: try to load saved progress or start new session
  useEffect(() => {
    // Prevent duplicate API call on initial load
    if (hasFetchedInitialQuestion.current) return;
    hasFetchedInitialQuestion.current = true;

    const savedProgress = localStorage.getItem('qaProgress');
    const storedPrompt = localStorage.getItem('designPrompt');
    const storedSettings = localStorage.getItem('qaSettings');
    
    if (savedProgress) {
      // Load saved progress
      try {
        const progress: SavedProgress = JSON.parse(savedProgress);
        console.log('Loaded settings with knowledge base:', progress.settings.knowledgeBase);
        setPrompt(progress.prompt);
        setSettings(progress.settings);
        setQaTree(progress.qaTree);
        setQuestionCount(progress.questionCount);
        setRequirementsDoc(progress.requirementsDoc);
        if (progress.currentNodeId) {
          const node = findNodeById(progress.qaTree, progress.currentNodeId);
          setCurrentNode(node);
        }
        setIsLoading(false);
        setIsInitialLoad(false);
        return;
      } catch (error) {
        console.error("Error loading saved progress:", error);
      }
    }
    
    // Start new session
    if (storedPrompt && storedSettings) {
      const parsedSettings = JSON.parse(storedSettings);
      console.log('Starting new session with knowledge base:', parsedSettings.knowledgeBase);
      setPrompt(storedPrompt);
      setSettings(parsedSettings);
      
      // Create and set up root node (Q0)
      const rootNode: QANode = {
        id: uuidv4(),
        question: `Prompt: ${storedPrompt}`,
        children: [],
        questionNumber: 0,
      };
      setQaTree(rootNode);
      
      // Initialize requirements document
      const initialRequirementsDoc: RequirementsDocument = {
        id: uuidv4(),
        prompt: storedPrompt,
        lastUpdated: new Date().toISOString(),
        categories: {
          basicNeeds: { title: 'Basic Needs', requirements: [] },
          functionalRequirements: { title: 'Functional Requirements', requirements: [] },
          userExperience: { title: 'User Experience', requirements: [] },
          implementation: { title: 'Implementation', requirements: [] },
          refinements: { title: 'Refinements', requirements: [] },
          constraints: { title: 'Constraints', requirements: [] }
        }
      };
      setRequirementsDoc(initialRequirementsDoc);
      
      // Generate first question (Q1)
      fetchQuestionsForNode(storedPrompt, rootNode, [], 0, false).then(({ nodes: children, suggestedAnswer }) => {
        if (children.length > 0) {
          children[0].questionNumber = 1;
          rootNode.children = children;
          setQaTree({ ...rootNode });
          setCurrentNode(children[0]);
          if (suggestedAnswer) {
            setSuggestedAnswer({ 
              text: suggestedAnswer, 
              confidence: 'medium',
              sourceReferences: []
            });
          }
          setQuestionCount(1);
        }
        setIsLoading(false);
        setIsInitialLoad(false);
      });
    } else {
      console.error("No design prompt or settings found.");
      router.push('/');
    }
  }, [router]);

  // When the user submits an answer
  const handleAnswer = async (answer: string) => {
    if (!currentNode || !settings) return;
    
    setIsLoadingNextQuestion(true);
    setSuggestedAnswer(null);
    
    // Check if we've hit the question limit
    if (settings.maxQuestions && questionCount >= settings.maxQuestions) {
      setCurrentNode(null);
      setIsLoadingNextQuestion(false);
      return;
    }
    
    try {
      // Record the answer
      currentNode.answer = answer;
      
      // Update requirements document with new answer
      await updateRequirements(currentNode.id);
      
      // Get the next question based on traversal mode
      const nextNode = await getNextQuestion(currentNode);
      
      if (nextNode) {
        // Verify this question hasn't been asked before
        if (!askedQuestions.has(nextNode.question)) {
          setAskedQuestions(prev => new Set(prev).add(nextNode.question));
          setIsInitialLoad(true); // Prevent auto-fetch when setting current node
          setCurrentNode(nextNode);
          setQuestionCount(prev => prev + 1);
          setQaTree(prev => prev ? { ...prev } : prev);
          setIsInitialLoad(false); // Reset flag after state updates
        } else {
          console.warn('Duplicate question detected:', nextNode.question);
          setCurrentNode(null);
        }
      } else {
        setCurrentNode(null); // No more questions
        // Final requirements update with no current node
        await updateRequirements(null);
      }
    } catch (error) {
      console.error('Error in handleAnswer:', error);
    } finally {
      setIsLoadingNextQuestion(false);
    }
  };

  const handleAutoPopulate = async (): Promise<string | null> => {
    try {
      // If we already have a suggested answer, use it
      if (suggestedAnswer) {
        return suggestedAnswer.text;
      }
      
      // Otherwise, build the previous Q&A chain up to the current question
      const questionHistory: QuestionHistoryItem[] = [];
      const collectHistory = (n: QANode) => {
        if (n.question !== `Prompt: ${prompt}`) {
          questionHistory.push({
            question: n.question,
            answer: n.answer,
            topics: extractTopics(n.question)
          });
        }
        n.children.forEach(collectHistory);
      };
      collectHistory(qaTree!);

      const response = await fetch('/api/generate-questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt,
          previousQuestions: questionHistory,
          traversalMode: settings?.traversalMode,
          knowledgeBase: settings?.knowledgeBase,
          currentQuestion: currentNode?.question,
          isAutoPopulate: true
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to generate answer');
      }

      const data = await response.json();
      console.log('Auto-populate response:', data);
      
      // Return the suggestedAnswer text if it exists
      if (data.suggestedAnswer) {
        return data.suggestedAnswer;
      }
      
      return null;
    } catch (error) {
      console.error('Error auto-populating answer:', error);
      return null;
    }
  };

  const handleRestart = () => {
    // Set loading state
    setIsLoading(true);
    setIsLoadingNextQuestion(true);
    
    // Create new root node (Q0)
    const rootNode: QANode = {
      id: uuidv4(),
      question: `Prompt: ${prompt}`,
      children: [],
      questionNumber: 0, // Explicitly set prompt as Q0
    };
    
    // Reset all states
    setQaTree(rootNode);
    setQuestionCount(0);
    setCurrentNode(null);
    setAskedQuestions(new Set());
    setAskedTopics(new Set());
    
    // Reset requirements document
    const initialRequirementsDoc: RequirementsDocument = {
      id: uuidv4(),
      prompt: prompt,
      lastUpdated: new Date().toISOString(),
      categories: {
        basicNeeds: { 
          title: 'Basic Needs', 
          requirements: [] 
        },
        functionalRequirements: { 
          title: 'Functional Requirements', 
          requirements: [] 
        },
        userExperience: { 
          title: 'User Experience', 
          requirements: [] 
        },
        implementation: { 
          title: 'Implementation', 
          requirements: [] 
        },
        refinements: { 
          title: 'Refinements', 
          requirements: [] 
        },
        constraints: { 
          title: 'Constraints', 
          requirements: [] 
        }
      }
    };
    setRequirementsDoc(initialRequirementsDoc);
    
    // Generate first question (Q1)
    fetchQuestionsForNode(prompt, rootNode, [], 0, true).then(({ nodes: children }) => {
      if (children.length > 0) {
        // Set first actual question as Q1
        children[0].questionNumber = 1;
        rootNode.children = children;
        setQaTree({ ...rootNode });
        setCurrentNode(children[0]);
        setQuestionCount(1);
      }
    })
      .catch(error => {
        console.error('Error generating first question:', error);
      })
      .finally(() => {
        setIsLoading(false);
        setIsLoadingNextQuestion(false);
      });
  };

  const handleGenerate = async () => {
    setIsPreviewOpen(true);
    setIsGenerating(true);
    
    try {
      // Update requirements one final time before showing preview
      await updateRequirements(currentNode?.id || null);
      
      // Wait a bit to ensure requirements are updated
      await new Promise(resolve => setTimeout(resolve, 500));
      
    } catch (error) {
      console.error('Error generating preview:', error);
    } finally {
      setIsGenerating(false);
    }
  };

  // Helper: Extract aspects from an answer that need to be covered by child questions
  const extractAspectsFromAnswer = (answer: string): string[] => {
    const aspects: string[] = [];
    
    // Split answer into sentences and clean them
    const sentences = answer.split(/[.!?]+/)
      .map(s => s.trim())
      .filter(Boolean);
    
    sentences.forEach(sentence => {
      // Look for lists or enumerations with commas or 'and'
      if (sentence.includes(',') || /\band\b/.test(sentence)) {
        const items = sentence
          .split(/,|\band\b/)
          .map(item => item.trim().toLowerCase())
          .filter(Boolean)
          // Filter out common connecting words and articles
          .filter(item => !['the', 'a', 'an', 'should', 'would', 'could', 'with'].includes(item));
        aspects.push(...items);
      } else {
        // For single aspects, try to extract the key feature/concept
        const cleanedSentence = sentence.toLowerCase()
          .replace(/should|would|could|must|with|the|a|an/g, '')
          .trim();
        if (cleanedSentence) {
          aspects.push(cleanedSentence);
        }
      }
    });
    
    // Remove duplicates and very similar aspects
    const uniqueAspects = Array.from(new Set(aspects))
      .filter((aspect, index, self) => 
        !self.some((other, otherIndex) => 
          index !== otherIndex && 
          (other.includes(aspect) || aspect.includes(other))
        )
      );
    
    return uniqueAspects.length > 0 ? uniqueAspects : ['basic_requirements'];
  };

  return (
    <div className="min-h-screen flex flex-col bg-gray-100">
      <HeaderToolbar 
        onRestart={handleRestart} 
        onGenerate={handleGenerate}
        onSave={() => handleSaveSession()}
        showRestartButton={!isLoading}
        showGenerateButton={!isLoading && qaTree !== null}
        showSaveButton={!isLoading && qaTree !== null}
      />
      <div className="py-2 px-6 bg-white border-b border-gray-200">
        <div className="flex justify-between items-center">
          <div className="text-sm text-gray-600">
            Questions: {questionCount}{settings?.maxQuestions ? ` / ${settings.maxQuestions}` : ''}
          </div>
          <div className="text-sm text-gray-600">
            Mode: {settings?.traversalMode === 'dfs' ? 'Depth-First' : 'Breadth-First'}
          </div>
        </div>
      </div>
      <main className="flex-1 flex">
        {/* Left: Canvas Tree view */}
        <div className="w-2/3 p-6 overflow-auto">
          <div className="bg-white rounded-lg shadow-lg p-6 min-h-full">
            <h2 className="text-2xl font-bold mb-6 text-gray-900">Question Tree</h2>
            {isLoading ? (
              <div className="flex items-center justify-center h-32">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
              </div>
            ) : (
              <CanvasTree node={qaTree} />
            )}
          </div>
        </div>
        {/* Right: Q&A Panel */}
        <div className="w-1/3 p-6 overflow-auto border-l border-gray-200">
          <QAPanel
            currentQuestion={
              currentNode
                ? currentNode.question
                : "No more questions. Q&A complete."
            }
            onSubmitAnswer={handleAnswer}
            isLoading={isLoading || isLoadingNextQuestion}
            hasKnowledgeBase={Boolean(settings?.knowledgeBase?.length)}
            onAutoPopulate={handleAutoPopulate}
          />
        </div>
      </main>
      
      <PreviewPanel
        isOpen={isPreviewOpen}
        onClose={() => setIsPreviewOpen(false)}
        requirementsDoc={requirementsDoc!}
        isGenerating={isGenerating}
        qaTree={qaTree}
        onVersionRestore={handleVersionRestore}
      />
    </div>
  );
}


----- /Users/jackcrawford/ai-design-flow/app/globals.css -----
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
}


----- /Users/jackcrawford/ai-design-flow/app/layout.tsx -----
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}


----- /Users/jackcrawford/ai-design-flow/app/page.tsx -----
// app/page.tsx
'use client';

import { useRouter } from 'next/navigation';
import { useEffect, useState } from 'react';
import PromptInput from '@/components/PromptInput';
import { QASettings } from '@/types/settings';

interface SavedProgress {
  qaTree: any;
  currentNodeId: string | null;
  questionCount: number;
  prompt: string;
  settings: QASettings;
}

export default function PromptPage() {
  const router = useRouter();
  const [savedSession, setSavedSession] = useState<SavedProgress | null>(null);

  useEffect(() => {
    const savedProgress = localStorage.getItem('qaProgress');
    if (savedProgress) {
      try {
        const progress = JSON.parse(savedProgress);
        setSavedSession(progress);
      } catch (error) {
        console.error("Error loading saved session:", error);
      }
    }
  }, []);

  const handlePromptSubmit = (prompt: string, settings: QASettings) => {
    console.log("User prompt:", prompt);
    console.log("Settings:", settings);
    
    // Clear any existing progress
    localStorage.removeItem('qaProgress');
    
    // Save new prompt and settings
    localStorage.setItem('designPrompt', prompt);
    localStorage.setItem('qaSettings', JSON.stringify(settings));
    router.push('/qna');
  };

  const handleContinueSession = () => {
    router.push('/qna');
  };

  return (
    <div className="min-h-screen flex flex-col justify-center items-center bg-gray-50 px-4">
      {/* Header */}
      <header className="mb-8 text-center">
        <h1 className="text-4xl font-bold text-gray-800">Welcome to AI Design Flow</h1>
        <p className="mt-4 text-lg text-gray-600">
          Enter your design prompt to kick off your interactive design journey.
        </p>
      </header>
      
      {/* Saved Session */}
      {savedSession && (
        <div className="w-full max-w-2xl mb-8">
          <div className="bg-white rounded-lg shadow-lg p-6 border border-gray-200">
            <h2 className="text-xl font-bold text-gray-900 mb-4">Continue Previous Session</h2>
            <div className="space-y-2 mb-4">
              <p className="text-gray-700">
                <span className="font-medium">Prompt:</span> {savedSession.prompt}
              </p>
              <p className="text-gray-700">
                <span className="font-medium">Progress:</span> {savedSession.questionCount} questions answered
              </p>
              <p className="text-gray-700">
                <span className="font-medium">Mode:</span> {savedSession.settings.traversalMode === 'dfs' ? 'Depth-First' : 'Breadth-First'}
              </p>
            </div>
            <div className="flex gap-4">
              <button
                onClick={handleContinueSession}
                className="flex-1 bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium"
              >
                Continue Session
              </button>
              <button
                onClick={() => setSavedSession(null)}
                className="flex-1 bg-gray-100 text-gray-700 px-6 py-3 rounded-lg hover:bg-gray-200 transition-colors font-medium"
              >
                Start New Session
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Prompt Input */}
      {!savedSession && (
        <div className="w-full max-w-2xl">
          <PromptInput onSubmit={handlePromptSubmit} />
        </div>
      )}
    </div>
  );
}


----- /Users/jackcrawford/ai-design-flow/components/Canvas.tsx -----
interface CanvasProps {
  answers: Array<{ question: string; answer: string }>;
}

export default function Canvas({ answers }: CanvasProps) {
  return (
    <div className="bg-gray-50 rounded-lg p-6 overflow-auto">
      <h2 className="text-xl font-semibold mb-4">Design Flow</h2>
      <div className="space-y-4">
        {answers.map((item, index) => (
          <div key={index} className="bg-white p-4 rounded-lg shadow">
            <p className="font-medium text-gray-700 mb-2">Q: {item.question}</p>
            <p className="text-gray-600">A: {item.answer}</p>
          </div>
        ))}
      </div>
    </div>
  );
} 

----- /Users/jackcrawford/ai-design-flow/components/CanvasTree.tsx -----
// components/CanvasTree.tsx
import React from 'react';
import { QANode } from '@/types'; // if you're using a separate types file

interface CanvasTreeProps {
  node: QANode | null;
  depth?: number;
  isRoot?: boolean;
}

const CanvasTree: React.FC<CanvasTreeProps> = ({ node, depth = 0, isRoot = true }) => {
  if (!node) return null;

  const isPromptNode = node.question.startsWith('Prompt:');

  return (
    <div style={{ marginLeft: depth * 16 }} className="mb-4">
      <div className={`p-2 border rounded mb-2 ${isPromptNode ? 'bg-gray-50' : 'bg-white'} shadow`}>
        <p className={`${isPromptNode ? 'font-semibold text-gray-900' : 'font-medium text-gray-900'}`}>
          {isPromptNode ? (
            node.question
          ) : (
            <>
              <span className="text-blue-600 font-semibold">Q{node.questionNumber}: </span>
              {node.question}
            </>
          )}
        </p>
        {!isPromptNode && node.answer && (
          <p className="text-gray-800 mt-1">
            <span className="text-blue-600 font-semibold">A{node.questionNumber}: </span>
            {node.answer}
          </p>
        )}
      </div>
      {node.children?.map((child: QANode) => (
        <CanvasTree key={child.id} node={child} depth={depth + 1} isRoot={false} />
      ))}
    </div>
  );
};

export default CanvasTree;


----- /Users/jackcrawford/ai-design-flow/components/HeaderToolbar.tsx -----
import Link from 'next/link';

interface HeaderToolbarProps {
  onRestart?: () => void;
  onGenerate?: () => void;
  onSave?: () => void;
  showRestartButton?: boolean;
  showGenerateButton?: boolean;
  showSaveButton?: boolean;
}

const HeaderToolbar: React.FC<HeaderToolbarProps> = ({ 
  onRestart, 
  onGenerate,
  onSave,
  showRestartButton = false,
  showGenerateButton = false,
  showSaveButton = false
}) => {
  return (
    <header className="bg-white border-b border-gray-200">
      <div className="w-full px-2">
        <div className="flex justify-between items-center h-16 max-w-[1920px] mx-auto">
          <div className="pl-2">
            <Link href="/" className="text-xl font-bold text-gray-900 hover:text-gray-700 transition-colors">
              AI Design Flow
            </Link>
          </div>
          <div className="pr-2 flex space-x-4">
            {showSaveButton && onSave && (
              <button
                onClick={onSave}
                className="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors flex items-center space-x-2"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" />
                </svg>
                <span>Save Progress</span>
              </button>
            )}
            {showGenerateButton && onGenerate && (
              <button
                onClick={onGenerate}
                className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                </svg>
                <span>Generate Preview</span>
              </button>
            )}
            {showRestartButton && onRestart && (
              <button
                onClick={onRestart}
                className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
              >
                Restart Q&A
              </button>
            )}
          </div>
        </div>
      </div>
    </header>
  );
};

export default HeaderToolbar; 

----- /Users/jackcrawford/ai-design-flow/components/LivePreview.tsx -----
import React, { useEffect, useRef } from 'react';

interface LivePreviewProps {
  code: string;
  colorScheme?: {
    primary: string;
    'primary-focus': string;
    'primary-content': string;
    secondary: string;
    'secondary-focus': string;
    'secondary-content': string;
    accent: string;
    'accent-focus': string;
    'accent-content': string;
    neutral: string;
    'neutral-focus': string;
    'neutral-content': string;
    'base-100': string;
    'base-200': string;
    'base-300': string;
    'base-content': string;
    info: string;
    success: string;
    warning: string;
    error: string;
  };
}

// Helper function to adjust hex colors
function adjustColor(hex: string, amount: number): string {
  try {
    // Remove the hash if present
    hex = hex.replace('#', '');
    // Convert to RGB
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    // Adjust each component
    const adjustComponent = (c: number) => {
      const newC = Math.min(255, Math.max(0, c + amount));
      const hexComponent = newC.toString(16);
      return hexComponent.length === 1 ? '0' + hexComponent : hexComponent;
    };
    // Convert back to hex
    return '#' + adjustComponent(r) + adjustComponent(g) + adjustComponent(b);
  } catch {
    // Return a fallback color if there's any error
    return amount > 0 ? '#3B82F6' : '#1E40AF';
  }
}

// Helper function to convert hex to HSL for DaisyUI
function hexToHSL(hex: string): string {
  // Remove the hash if present
  hex = hex.replace('#', '');
  
  // Convert hex to RGB
  const r = parseInt(hex.substring(0, 2), 16) / 255;
  const g = parseInt(hex.substring(2, 4), 16) / 255;
  const b = parseInt(hex.substring(4, 6), 16) / 255;
  
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h = 0;
  let s = 0;
  const l = (max + min) / 2;

  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }

  // Convert to degrees and percentages
  const hDeg = Math.round(h * 360);
  const sPct = Math.round(s * 100);
  const lPct = Math.round(l * 100);

  return `${hDeg} ${sPct}% ${lPct}%`;
}

const LivePreview: React.FC<LivePreviewProps> = ({ code, colorScheme }) => {
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!containerRef.current || !code) return;

    try {
      // Clean up previous content
      while (containerRef.current.firstChild) {
        containerRef.current.removeChild(containerRef.current.firstChild);
      }

      // Create an iframe for the preview
      const iframe = document.createElement('iframe');
      iframe.style.width = '100%';
      iframe.style.height = '100%';
      iframe.style.border = 'none';
      containerRef.current.appendChild(iframe);

      // Transform the code:
      // 1. Remove import statements (React is provided globally)
      let transformedCode = code;
      transformedCode = transformedCode.replace(/import\s+{([^}]+)}\s+from\s+['"]react['"];?/g, '');
      transformedCode = transformedCode.replace(/import\s+React\s*,?\s*{([^}]+)}\s+from\s+['"]react['"];?/g, '');
      transformedCode = transformedCode.replace(/import\s+.*?from\s+['"].*?['"];?\n?/g, '');
      // 2. Remove export statements but preserve the component name
      const exportMatch = transformedCode.match(/export\s+default\s+(\w+)/);
      const componentName = exportMatch ? exportMatch[1] : null;
      transformedCode = transformedCode.replace(/export\s+default\s+\w+;?/, '');
      transformedCode = transformedCode.replace(/export\s+/, '');
      // 3. Remove inline type assertions
      transformedCode = transformedCode.replace(/\sas\s+\w+/g, '');

      // Escape the final code so it can be safely embedded
      const safeCode = JSON.stringify(transformedCode);

      // Build the DaisyUI theme style block using the colorScheme
      const daisyuiTheme = colorScheme
        ? `
          <script>
            tailwind.config = {
              theme: {
                extend: {},
              },
              daisyui: {
                styled: true,
                themes: false,
                base: true,
                utils: true,
                logs: false,
                rtl: false
              }
            }
          </script>
          <style>
            [data-theme="custom"] {
              /* Primary colors */
              --p: ${hexToHSL(colorScheme.primary)} !important;
              --pf: ${hexToHSL(colorScheme['primary-focus'])} !important;
              --pc: ${hexToHSL(colorScheme['primary-content'])} !important;
              
              /* Secondary colors */
              --s: ${hexToHSL(colorScheme.secondary)} !important;
              --sf: ${hexToHSL(colorScheme['secondary-focus'])} !important;
              --sc: ${hexToHSL(colorScheme['secondary-content'])} !important;
              
              /* Accent colors */
              --a: ${hexToHSL(colorScheme.accent)} !important;
              --af: ${hexToHSL(colorScheme['accent-focus'])} !important;
              --ac: ${hexToHSL(colorScheme['accent-content'])} !important;
              
              /* Neutral colors */
              --n: ${hexToHSL(colorScheme.neutral)} !important;
              --nf: ${hexToHSL(colorScheme['neutral-focus'])} !important;
              --nc: ${hexToHSL(colorScheme['neutral-content'])} !important;
              
              /* Base colors */
              --b1: ${hexToHSL(colorScheme['base-100'])} !important;
              --b2: ${hexToHSL(colorScheme['base-200'])} !important;
              --b3: ${hexToHSL(colorScheme['base-300'])} !important;
              --bc: ${hexToHSL(colorScheme['base-content'])} !important;
              
              /* State colors */
              --in: ${hexToHSL(colorScheme.info)} !important;
              --su: ${hexToHSL(colorScheme.success)} !important;
              --wa: ${hexToHSL(colorScheme.warning)} !important;
              --er: ${hexToHSL(colorScheme.error)} !important;
            }
          </style>
        `
        : '';

      // Build the HTML content for the iframe
      const html = `
        <!DOCTYPE html>
        <html data-theme="custom">
          <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <script src="https://cdn.tailwindcss.com"></script>
            <link href="https://cdn.jsdelivr.net/npm/daisyui@2.51.5/dist/full.css" rel="stylesheet">
            ${daisyuiTheme}
            <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
            <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
            <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
            <style>
              body { margin: 0; padding: 1rem; }
              * { font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; }
            </style>
          </head>
          <body data-theme="custom">
            <div id="root"></div>
            <script type="text/babel" data-presets="react,typescript">
              // Dummy type definitions to avoid runtime errors
              window.FormEvent = function(target) { return {}; };
              window.ChangeEvent = function(target) { return {}; };
              window.MouseEvent = function(target) { return {}; };

              // Prepend React hook destructuring so hooks are available
              const prelude = "const { useState, useEffect, useRef, useMemo, useCallback, useContext, useReducer } = React;";
              
              // Retrieve the safe, escaped code string
              const code = ${safeCode};

              // Combine the prelude with the generated code
              const fullCode = prelude + code;

              try {
                // Transpile the code with Babel
                const transformed = Babel.transform(fullCode, { 
                  filename: 'file.tsx', 
                  presets: ['react', 'typescript'],
                  retainLines: true
                }).code;
                
                // Evaluate the transformed code
                eval(transformed);

                // Try to find the component using the exported name first
                let MainComponent = ${componentName ? componentName : 'null'};
                
                // If not found by name, try to find it by scanning window object
                if (!MainComponent) {
                  const components = Object.values(window).filter(
                    val => typeof val === 'function' && 
                          /^[A-Z]/.test(val?.name || '') &&
                          val.toString().includes('React.createElement')
                  );
                  MainComponent = components[components.length - 1];
                }

                if (MainComponent) {
                  const root = ReactDOM.createRoot(document.getElementById('root'));
                  root.render(
                    <React.StrictMode>
                      <MainComponent />
                    </React.StrictMode>
                  );
                } else {
                  document.getElementById('root').innerHTML =
                    '<div style="padding: 1rem; color: red;">No React component found in the code. Please ensure the code includes a properly named React component with a default export.</div>';
                }
              } catch (error) {
                document.getElementById('root').innerHTML =
                  '<div style="padding: 1rem; color: red;">Error evaluating component: ' + error.message + '</div>';
                console.error('Component evaluation error:', error);
              }
            </script>
          </body>
        </html>
      `;

      const iframeDoc = iframe.contentWindow?.document;
      if (iframeDoc) {
        iframeDoc.open();
        iframeDoc.write(html);
        iframeDoc.close();
      }
    } catch (error) {
      console.error('Error rendering preview:', error);
      if (containerRef.current) {
        containerRef.current.innerHTML = `
          <div class="p-4 text-red-600 bg-red-50 rounded-lg">
            <h2 class="text-lg font-semibold mb-2">Error Rendering Preview</h2>
            <pre class="text-sm overflow-auto">
              ${error instanceof Error ? error.message : 'Unknown error occurred'}
            </pre>
          </div>
        `;
      }
    }
  }, [code, colorScheme]);

  return (
    <div ref={containerRef} className="w-full h-full bg-white">
      <div className="flex items-center justify-center h-full text-gray-400">
        Loading preview...
      </div>
    </div>
  );
};

export default LivePreview;


----- /Users/jackcrawford/ai-design-flow/components/PreviewArea.tsx -----
interface PreviewAreaProps {
  requirements: string;
  uiCode: string;
}

export default function PreviewArea({ requirements, uiCode }: PreviewAreaProps) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
      <div className="bg-white rounded-lg p-6 shadow-lg">
        <h2 className="text-xl font-semibold mb-4">Requirements</h2>
        <pre className="whitespace-pre-wrap font-mono text-sm bg-gray-50 p-4 rounded">
          {requirements}
        </pre>
      </div>
      <div className="bg-white rounded-lg p-6 shadow-lg">
        <h2 className="text-xl font-semibold mb-4">Generated UI Code</h2>
        <pre className="whitespace-pre-wrap font-mono text-sm bg-gray-50 p-4 rounded overflow-auto">
          {uiCode}
        </pre>
      </div>
    </div>
  );
} 

----- /Users/jackcrawford/ai-design-flow/components/PreviewPanel.tsx -----
import { RequirementsDocument, MockupVersion } from '@/types';
import { useState, useEffect } from 'react';
import { v4 as uuidv4 } from 'uuid';
import dynamic from 'next/dynamic';

// Dynamically import a component that will render the live preview
const LivePreview = dynamic(() => import('./LivePreview'), { ssr: false });

interface MockupData {
  code: string;
  colorScheme: {
    primary: string;
    'primary-focus': string;
    'primary-content': string;
    secondary: string;
    'secondary-focus': string;
    'secondary-content': string;
    accent: string;
    'accent-focus': string;
    'accent-content': string;
    neutral: string;
    'neutral-focus': string;
    'neutral-content': string;
    'base-100': string;
    'base-200': string;
    'base-300': string;
    'base-content': string;
    info: string;
    success: string;
    warning: string;
    error: string;
    [key: string]: string; // Allow string indexing for dynamic access
  };
  components: string[];
  features: string[];
  nextSteps: string[];
}

interface PreviewPanelProps {
  isOpen: boolean;
  onClose: () => void;
  requirementsDoc: RequirementsDocument;
  isGenerating: boolean;
  qaTree: any;
  onVersionRestore?: (version: MockupVersion) => void;
}

// Helper function to ensure complete color scheme
const ensureCompleteColorScheme = (version: MockupVersion): MockupVersion => {
  const defaultColors: Record<string, string> = {
    'primary-focus': '#1E40AF',
    'primary-content': '#FFFFFF',
    'secondary-focus': '#475569',
    'secondary-content': '#FFFFFF',
    'accent-focus': '#D97706',
    'accent-content': '#FFFFFF',
    'neutral': '#3D4451',
    'neutral-focus': '#2A2E37',
    'neutral-content': '#FFFFFF',
    'base-100': '#FFFFFF',
    'base-200': '#F3F4F6',
    'base-300': '#E5E7EB',
    'base-content': '#1F2937',
    'info': '#3ABFF8',
    'success': '#36D399',
    'warning': '#FBBD23',
    'error': '#F87272'
  };

  return {
    ...version,
    mockupData: {
      ...version.mockupData,
      colorScheme: {
        ...defaultColors,
        ...version.mockupData.colorScheme,
      }
    }
  };
};

export default function PreviewPanel({
  isOpen,
  onClose,
  requirementsDoc,
  isGenerating,
  qaTree,
  onVersionRestore
}: PreviewPanelProps) {
  const [activeTab, setActiveTab] = useState<'requirements' | 'mockup' | 'versions'>('requirements');
  const [mockupData, setMockupData] = useState<MockupData | null>(null);
  const [isMockupLoading, setIsMockupLoading] = useState(false);
  const [versions, setVersions] = useState<MockupVersion[]>([]);
  const [selectedVersion, setSelectedVersion] = useState<MockupVersion | null>(null);
  const [isCompareMode, setIsCompareMode] = useState(false);
  const [compareVersion, setCompareVersion] = useState<MockupVersion | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    // Load versions from localStorage
    try {
      const storedVersions = localStorage.getItem('mockupVersions');
      if (storedVersions) {
        setVersions(JSON.parse(storedVersions));
      }
    } catch (error) {
      console.error('Error loading versions:', error);
    }
  }, []);

  useEffect(() => {
    if (activeTab === 'mockup' && !mockupData && !isMockupLoading && !error) {
      generateMockup();
    }
  }, [activeTab, mockupData, isMockupLoading, error]);

  const generateMockup = async () => {
    setIsMockupLoading(true);
    setError(null);
    try {
      const response = await fetch('/api/generate-mockup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ requirementsDoc })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error occurred' }));
        throw new Error(errorData.error || 'Failed to generate mockup');
      }

      const data = await response.json();
      
      // Validate mockup data structure
      if (!data.code || !data.colorScheme || !data.components || !data.features || !data.nextSteps) {
        throw new Error('Invalid mockup data received');
      }

      setMockupData(data);

      // Create new version
      const newVersion: MockupVersion = {
        id: uuidv4(),
        timestamp: new Date().toISOString(),
        qaTree,
        requirementsDoc,
        mockupData: data
      };

      // Add to versions and save to localStorage
      const updatedVersions = [...versions, newVersion];
      setVersions(updatedVersions);
      localStorage.setItem('mockupVersions', JSON.stringify(updatedVersions));

    } catch (error) {
      console.error('Error generating mockup:', error);
      setError(error instanceof Error ? error.message : 'Failed to generate mockup');
    } finally {
      setIsMockupLoading(false);
    }
  };

  const handleVersionSelect = (version: MockupVersion) => {
    const completeVersion = ensureCompleteColorScheme(version);
    setSelectedVersion(completeVersion);
    setMockupData(completeVersion.mockupData);
  };

  const handleVersionRestore = (version: MockupVersion) => {
    if (onVersionRestore) {
      onVersionRestore(version);
    }
  };

  const handleCompareSelect = (version: MockupVersion) => {
    setCompareVersion(version);
    setIsCompareMode(true);
  };

  const handleCopyCode = () => {
    if (mockupData?.code) {
      navigator.clipboard.writeText(mockupData.code);
    }
  };

  const handleDownload = () => {
    if (activeTab === 'requirements') {
      // Download requirements as markdown
      const requirementsText = Object.entries(requirementsDoc.categories)
        .map(([key, category]) => {
          const reqs = category.requirements
            .map(req => `- ${req.text} (${req.priority} priority)`)
            .join('\n');
          return `## ${category.title}\n${reqs}`;
        })
        .join('\n\n');

      const content = `# ${requirementsDoc.prompt}\n\n${requirementsText}`;
      const blob = new Blob([content], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'requirements.md';
      a.click();
      URL.revokeObjectURL(url);
    } else if (mockupData?.code) {
      // Download mockup as TypeScript file
      const blob = new Blob([mockupData.code], { type: 'text/typescript' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'mockup.tsx';
      a.click();
      URL.revokeObjectURL(url);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-end">
      <div className={`${isCompareMode ? 'w-4/5' : 'w-full'} bg-white h-full shadow-lg flex flex-col`}>
        {/* Header */}
        <div className="p-4 border-b border-gray-200 flex justify-between items-center">
          <div className="flex space-x-4">
            <button
              onClick={() => setActiveTab('requirements')}
              className={`px-4 py-2 rounded-lg ${
                activeTab === 'requirements'
                  ? 'bg-blue-100 text-blue-700'
                  : 'text-gray-600 hover:bg-gray-100'
              }`}
            >
              Requirements
            </button>
            <button
              onClick={() => setActiveTab('mockup')}
              className={`px-4 py-2 rounded-lg ${
                activeTab === 'mockup'
                  ? 'bg-blue-100 text-blue-700'
                  : 'text-gray-600 hover:bg-gray-100'
              }`}
            >
              Mockup
            </button>
            <button
              onClick={() => setActiveTab('versions')}
              className={`px-4 py-2 rounded-lg ${
                activeTab === 'versions'
                  ? 'bg-blue-100 text-blue-700'
                  : 'text-gray-600 hover:bg-gray-100'
              }`}
            >
              Versions ({versions.length})
            </button>
          </div>
          <div className="flex space-x-4">
            {activeTab === 'versions' && selectedVersion && (
              <>
                <button
                  onClick={() => handleVersionRestore(selectedVersion)}
                  className="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700"
                >
                  Restore Version
                </button>
                <button
                  onClick={() => handleCompareSelect(selectedVersion)}
                  className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                >
                  Compare
                </button>
              </>
            )}
            <button
              onClick={() => {
                setIsCompareMode(false);
                setCompareVersion(null);
                onClose();
              }}
              className="text-gray-500 hover:text-gray-700"
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-hidden flex">
          {/* Live Preview (Left Side) */}
          {activeTab === 'mockup' && mockupData && (
            <div className="w-2/3 h-full border-r border-gray-200 bg-gray-50 overflow-auto">
              <div className="h-full">
                <LivePreview code={mockupData.code} colorScheme={mockupData.colorScheme} />
              </div>
            </div>
          )}

          {/* Details Panel (Right Side) */}
          <div className={`${activeTab === 'mockup' && mockupData ? 'w-1/3' : 'w-full'} h-full overflow-auto`}>
            <div className="p-6">
              {error ? (
                <div className="p-6 text-center">
                  <div className="text-red-600 mb-4">{error}</div>
                  <button
                    onClick={() => {
                      setError(null);
                      generateMockup();
                    }}
                    className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
                  >
                    Try Again
                  </button>
                </div>
              ) : isGenerating || isMockupLoading ? (
                <div className="flex items-center justify-center h-full">
                  <div className="flex flex-col items-center space-y-4">
                    <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
                    <p className="text-gray-600">
                      {isGenerating ? 'Generating preview...' : 'Generating mockup...'}
                    </p>
                  </div>
                </div>
              ) : activeTab === 'versions' ? (
                <div className="p-6">
                  <h2 className="text-xl font-semibold text-gray-900 mb-4">Version History</h2>
                  <div className="space-y-4">
                    {versions.map((version) => (
                      <div
                        key={version.id}
                        className={`p-4 border rounded-lg cursor-pointer transition-colors ${
                          selectedVersion?.id === version.id
                            ? 'border-blue-500 bg-blue-50'
                            : 'border-gray-200 hover:border-blue-300'
                        }`}
                        onClick={() => handleVersionSelect(version)}
                      >
                        <div className="flex justify-between items-start">
                          <div>
                            <p className="font-medium text-gray-900">
                              Version from {new Date(version.timestamp).toLocaleString()}
                            </p>
                            <p className="text-sm text-gray-600 mt-1">
                              {version.requirementsDoc.categories.basicNeeds.requirements.length} requirements,{' '}
                              {version.mockupData.components.length} components
                            </p>
                          </div>
                          {version.name && (
                            <span className="px-2 py-1 bg-gray-100 text-gray-700 rounded text-sm">
                              {version.name}
                            </span>
                          )}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              ) : (
                <div className={`flex ${isCompareMode ? 'space-x-4' : ''}`}>
                  <div className={`${isCompareMode ? 'w-1/2' : 'w-full'}`}>
                    {activeTab === 'requirements' ? (
                      <div className="space-y-8">
                        <div className="prose max-w-none">
                          <h1 className="text-2xl font-bold text-gray-900 mb-4">
                            {requirementsDoc.prompt}
                          </h1>
                          <p className="text-sm text-gray-500 mb-8">
                            Last updated: {new Date(requirementsDoc.lastUpdated).toLocaleString()}
                          </p>
                        </div>

                        {Object.entries(requirementsDoc.categories).map(([key, category]) => (
                          <div key={key} className="space-y-4">
                            <h2 className="text-xl font-semibold text-gray-900">
                              {category.title}
                            </h2>
                            {category.requirements && category.requirements.length > 0 ? (
                              <ul className="space-y-3">
                                {[...category.requirements]
                                  .sort((a, b) => {
                                    const priorityOrder: Record<string, number> = { 'high': 0, 'medium': 1, 'low': 2 };
                                    const aPriority = (a.priority && priorityOrder[a.priority.toLowerCase()]) ?? 1;
                                    const bPriority = (b.priority && priorityOrder[b.priority.toLowerCase()]) ?? 1;
                                    return aPriority - bPriority;
                                  })
                                  .map((req, index) => (
                                  <li
                                    key={req.id || `${key}-${index}-${req.text}`}
                                    className="bg-white rounded-lg border border-gray-200 p-4"
                                  >
                                    <div className="flex items-start justify-between">
                                      <div className="flex-1">
                                        <p className="text-gray-900">{req.text}</p>
                                        <div className="mt-2 flex flex-wrap gap-2">
                                          {req.priority && (
                                            <span className={`px-2 py-1 rounded-full text-xs ${
                                              req.priority === 'high'
                                                ? 'bg-red-100 text-red-800'
                                                : req.priority === 'medium'
                                                ? 'bg-yellow-100 text-yellow-800'
                                                : 'bg-green-100 text-green-800'
                                            }`}>
                                              {req.priority} priority
                                            </span>
                                          )}
                                          {req.category && (
                                            <span className="px-2 py-1 rounded-full text-xs bg-blue-100 text-blue-800">
                                              {req.category}
                                            </span>
                                          )}
                                          {req.tags?.map((tag, tagIndex) => (
                                            <span
                                              key={`${req.id || index}-tag-${tagIndex}`}
                                              className="px-2 py-1 rounded-full text-xs bg-gray-100 text-gray-800"
                                            >
                                              {tag}
                                            </span>
                                          ))}
                                        </div>
                                      </div>
                                    </div>
                                  </li>
                                ))}
                              </ul>
                            ) : (
                              <p className="text-gray-500 italic">No requirements in {category.title}</p>
                            )}
                          </div>
                        ))}
                      </div>
                    ) : mockupData ? (
                      <div className="space-y-8">
                        {/* Color Scheme */}
                        <div>
                          <h2 className="text-xl font-semibold text-gray-900 mb-4">Color Scheme</h2>
                          <div className="grid grid-cols-2 gap-6">
                            {/* Primary Colors */}
                            <div className="space-y-3">
                              <h3 className="font-medium text-gray-900">Primary Colors</h3>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme.primary }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme['primary-content'] }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Primary (--p)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme.primary}</span>
                                </div>
                              </div>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme['primary-focus'] }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme['primary-content'] }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Focus (--pf)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme['primary-focus']}</span>
                                </div>
                              </div>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme['primary-content'] }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme.primary }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Content (--pc)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme['primary-content']}</span>
                                </div>
                              </div>
                            </div>

                            {/* Secondary Colors */}
                            <div className="space-y-3">
                              <h3 className="font-medium text-gray-900">Secondary Colors</h3>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme.secondary }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme['secondary-content'] }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Secondary (--s)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme.secondary}</span>
                                </div>
                              </div>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme['secondary-focus'] }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme['secondary-content'] }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Focus (--sf)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme['secondary-focus']}</span>
                                </div>
                              </div>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme['secondary-content'] }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme.secondary }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Content (--sc)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme['secondary-content']}</span>
                                </div>
                              </div>
                            </div>

                            {/* Accent Colors */}
                            <div className="space-y-3">
                              <h3 className="font-medium text-gray-900">Accent Colors</h3>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme.accent }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme['accent-content'] }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Accent (--a)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme.accent}</span>
                                </div>
                              </div>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme['accent-focus'] }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme['accent-content'] }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Focus (--af)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme['accent-focus']}</span>
                                </div>
                              </div>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme['accent-content'] }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme.accent }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Content (--ac)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme['accent-content']}</span>
                                </div>
                              </div>
                            </div>

                            {/* Neutral Colors */}
                            <div className="space-y-3">
                              <h3 className="font-medium text-gray-900">Neutral Colors</h3>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme.neutral }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme['neutral-content'] }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Neutral (--n)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme.neutral}</span>
                                </div>
                              </div>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme['neutral-focus'] }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme['neutral-content'] }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Focus (--nf)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme['neutral-focus']}</span>
                                </div>
                              </div>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme['neutral-content'] }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme.neutral }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Content (--nc)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme['neutral-content']}</span>
                                </div>
                              </div>
                            </div>

                            {/* Base Colors */}
                            <div className="space-y-3">
                              <h3 className="font-medium text-gray-900">Base Colors</h3>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme['base-100'] }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme['base-content'] }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Base 100 (--b1)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme['base-100']}</span>
                                </div>
                              </div>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme['base-200'] }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme['base-content'] }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Base 200 (--b2)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme['base-200']}</span>
                                </div>
                              </div>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme['base-300'] }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme['base-content'] }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Base 300 (--b3)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme['base-300']}</span>
                                </div>
                              </div>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme['base-content'] }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ backgroundColor: mockupData.colorScheme['base-100'], color: mockupData.colorScheme['base-content'] }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Content (--bc)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme['base-content']}</span>
                                </div>
                              </div>
                            </div>

                            {/* State Colors */}
                            <div className="space-y-3">
                              <h3 className="font-medium text-gray-900">State Colors</h3>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme.info }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme['base-content'] }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Info (--in)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme.info}</span>
                                </div>
                              </div>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme.success }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme['base-content'] }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Success (--su)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme.success}</span>
                                </div>
                              </div>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme.warning }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme['base-content'] }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Warning (--wa)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme.warning}</span>
                                </div>
                              </div>
                              <div className="flex items-center space-x-2">
                                <div className="w-10 h-10 rounded border border-gray-200 shadow-sm" style={{ backgroundColor: mockupData.colorScheme.error }}>
                                  <div className="w-full h-full flex items-center justify-center text-[10px]" style={{ color: mockupData.colorScheme['base-content'] }}>
                                    Aa
                                  </div>
                                </div>
                                <div className="flex flex-col">
                                  <span className="text-sm text-gray-900">Error (--er)</span>
                                  <span className="text-xs text-gray-500">{mockupData.colorScheme.error}</span>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>

                        {/* Components */}
                        <div>
                          <h2 className="text-xl font-semibold text-gray-900 mb-4">Components</h2>
                          <ul className="list-disc list-inside space-y-2">
                            {mockupData.components.map((component, index) => (
                              <li key={index} className="text-gray-700">{component}</li>
                            ))}
                          </ul>
                        </div>

                        {/* Features */}
                        <div>
                          <h2 className="text-xl font-semibold text-gray-900 mb-4">Implemented Features</h2>
                          <ul className="list-disc list-inside space-y-2">
                            {mockupData.features.map((feature, index) => (
                              <li key={index} className="text-gray-700">{feature}</li>
                            ))}
                          </ul>
                        </div>

                        {/* Code */}
                        <div>
                          <h2 className="text-xl font-semibold text-gray-900 mb-4">Generated Code</h2>
                          <div className="relative">
                            <pre className="bg-gray-50 p-4 rounded-lg overflow-auto text-sm max-h-96">
                              <code className="text-gray-800">{mockupData.code}</code>
                            </pre>
                            <button
                              onClick={handleCopyCode}
                              className="absolute top-2 right-2 p-2 bg-white rounded-md shadow-sm hover:bg-gray-50"
                              title="Copy code"
                            >
                              <svg className="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                              </svg>
                            </button>
                          </div>
                        </div>

                        {/* Next Steps */}
                        <div>
                          <h2 className="text-xl font-semibold text-gray-900 mb-4">Next Steps</h2>
                          <ul className="list-disc list-inside space-y-2">
                            {mockupData.nextSteps.map((step, index) => (
                              <li key={index} className="text-gray-700">{step}</li>
                            ))}
                          </ul>
                        </div>
                      </div>
                    ) : null}
                  </div>
                  {isCompareMode && compareVersion && (
                    <div className="w-1/2 p-6 border-l border-gray-200">
                      <h2 className="text-xl font-semibold text-gray-900 mb-4">
                        Comparing with version from {new Date(compareVersion.timestamp).toLocaleString()}
                      </h2>
                      {/* Render comparison content */}
                      {activeTab === 'requirements' ? (
                        <div className="space-y-8">
                          {/* ... requirements comparison rendering ... */}
                        </div>
                      ) : (
                        <div className="space-y-8">
                          {/* ... mockup comparison rendering ... */}
                        </div>
                      )}
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Footer */}
        <div className="p-4 border-t border-gray-200">
          <div className="flex justify-between">
            <button
              className="px-4 py-2 text-gray-600 hover:text-gray-800"
              onClick={handleDownload}
            >
              Download {activeTab === 'requirements' ? 'Requirements' : 'Code'}
            </button>
            {activeTab === 'mockup' && mockupData && (
              <div className="flex space-x-4">
                <button
                  className="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700"
                  onClick={() => {
                    // TODO: Implement Figma export
                    alert('Figma export coming soon!');
                  }}
                >
                  Export to Figma
                </button>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
} 

----- /Users/jackcrawford/ai-design-flow/components/PromptInput.tsx -----
// components/PromptInput.tsx
import React, { useState, ChangeEvent } from 'react';
import { QASettings, KnowledgeBaseSource } from '@/types/settings';
import { v4 as uuidv4 } from 'uuid';

interface PromptInputProps {
  onSubmit: (prompt: string, settings: QASettings) => void;
}

const PromptInput: React.FC<PromptInputProps> = ({ onSubmit }) => {
  const [prompt, setPrompt] = useState('');
  const [showSettings, setShowSettings] = useState(false);
  const [settings, setSettings] = useState<QASettings>({
    traversalMode: 'bfs',
    unknownHandling: 'auto',
    conflictResolution: 'auto',
    knowledgeBase: []
  });
  const [isProcessingFile, setIsProcessingFile] = useState(false);
  const [pastedContent, setPastedContent] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (prompt.trim()) {
      setShowSettings(true);
    }
  };

  const handleStartQA = () => {
    onSubmit(prompt, settings);
  };

  const processKnowledgeBase = async (type: 'file' | 'text', data: File | string, name: string) => {
    try {
      setIsProcessingFile(true);
      const formData = new FormData();
      formData.append('type', type);
      
      if (type === 'file') {
        formData.append('file', data as File);
      } else {
        formData.append('content', data as string);
      }

      const response = await fetch('/api/process-knowledge-base', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error('Failed to process knowledge base');
      }

      const result = await response.json();
      
      const newSource: KnowledgeBaseSource = {
        id: uuidv4(),
        type,
        name,
        ...(type === 'file' ? { file: data as File } : { content: data as string }),
        processedContent: result.processedContent
      };

      setSettings(prev => ({
        ...prev,
        knowledgeBase: [...(prev.knowledgeBase || []), newSource]
      }));
    } catch (error) {
      console.error('Error processing knowledge base:', error);
      // You might want to show an error message to the user here
    } finally {
      setIsProcessingFile(false);
    }
  };

  const handleFileUpload = async (file: File) => {
    await processKnowledgeBase('file', file, file.name);
  };

  const handleTextAdd = async () => {
    if (pastedContent.trim()) {
      await processKnowledgeBase('text', pastedContent, `Pasted content ${new Date().toLocaleString()}`);
      setPastedContent('');
    }
  };

  const removeKnowledgeSource = (id: string) => {
    setSettings(prev => ({
      ...prev,
      knowledgeBase: prev.knowledgeBase?.filter(source => source.id !== id)
    }));
  };

  const handleSettingChange = (
    setting: keyof QASettings,
    value: string | number | { file: File; processedContent: any } | undefined
  ) => {
    setSettings(prev => ({
      ...prev,
      [setting]: value
    }));
  };

  if (showSettings) {
    return (
      <div className="p-8 w-full max-w-2xl">
        <div className="mb-6">
          <h3 className="text-xl font-bold text-gray-900 mb-2">Your Prompt:</h3>
          <p className="text-gray-700 bg-gray-50 p-4 rounded-lg">{prompt}</p>
          <button
            onClick={() => setShowSettings(false)}
            className="mt-2 text-blue-600 hover:text-blue-700 text-sm"
          >
            Edit Prompt
          </button>
        </div>
        <div className="space-y-6">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Traversal Mode
            </label>
            <div className="flex gap-4">
              <label className="flex items-center">
                <input
                  type="radio"
                  name="traversalMode"
                  value="bfs"
                  checked={settings.traversalMode === 'bfs'}
                  onChange={(e) => handleSettingChange('traversalMode', e.target.value)}
                  className="mr-2"
                />
                <span className="text-gray-900">Breadth-First</span>
              </label>
              <label className="flex items-center">
                <input
                  type="radio"
                  name="traversalMode"
                  value="dfs"
                  checked={settings.traversalMode === 'dfs'}
                  onChange={(e) => handleSettingChange('traversalMode', e.target.value)}
                  className="mr-2"
                />
                <span className="text-gray-900">Depth-First</span>
              </label>
            </div>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Unknown Handling
            </label>
            <select 
              className="w-full border border-gray-300 rounded-lg p-2 text-gray-900 bg-white"
              value={settings.unknownHandling}
              onChange={(e) => handleSettingChange('unknownHandling', e.target.value)}
            >
              <option value="auto">Auto (trivial)</option>
              <option value="prompt">Always Prompt</option>
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Conflict Resolution
            </label>
            <select 
              className="w-full border border-gray-300 rounded-lg p-2 text-gray-900 bg-white"
              value={settings.conflictResolution}
              onChange={(e) => handleSettingChange('conflictResolution', e.target.value)}
            >
              <option value="auto">Auto-resolve Minor</option>
              <option value="manual">Manual Resolution</option>
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Maximum Questions
            </label>
            <input
              type="number"
              min="1"
              placeholder="Optional"
              className="w-full border border-gray-300 rounded-lg p-2 text-gray-900 bg-white"
              value={settings.maxQuestions || ''}
              onChange={(e) => handleSettingChange('maxQuestions', e.target.value ? parseInt(e.target.value) : undefined)}
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Knowledge Base Sources
            </label>
            <div className="space-y-4">
              {/* File Upload */}
              <div className="space-y-2">
                <input
                  type="file"
                  className="w-full text-gray-900 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
                  accept=".pdf,.doc,.docx,.txt"
                  onChange={(e: ChangeEvent<HTMLInputElement>) => {
                    const file = e.target.files?.[0];
                    if (file) {
                      handleFileUpload(file);
                    }
                  }}
                  disabled={isProcessingFile}
                />
                <p className="text-xs text-gray-500">
                  Supported formats: PDF, DOC, DOCX, TXT
                </p>
              </div>

              {/* Text Input */}
              <div className="space-y-2">
                <textarea
                  value={pastedContent}
                  onChange={(e) => setPastedContent(e.target.value)}
                  placeholder="Paste additional content here..."
                  className="w-full h-32 p-3 border rounded-lg resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                  disabled={isProcessingFile}
                />
                <button
                  onClick={handleTextAdd}
                  disabled={!pastedContent.trim() || isProcessingFile}
                  className="px-4 py-2 text-sm bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors disabled:bg-gray-400"
                >
                  Add Text Content
                </button>
              </div>

              {/* Processing Indicator */}
              {isProcessingFile && (
                <div className="flex items-center space-x-2 text-sm text-gray-600">
                  <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
                  <span>Processing content...</span>
                </div>
              )}

              {/* Knowledge Base List */}
              {settings.knowledgeBase && settings.knowledgeBase.length > 0 && (
                <div className="mt-4">
                  <h4 className="text-sm font-medium text-gray-700 mb-2">Added Sources:</h4>
                  <div className="space-y-2">
                    {settings.knowledgeBase.map((source) => (
                      <div
                        key={source.id}
                        className="flex items-center justify-between p-2 bg-gray-50 rounded-lg"
                      >
                        <div className="flex items-center space-x-2">
                          <span className="text-sm text-gray-600">
                            {source.type === 'file' ? '📄' : '📝'}
                          </span>
                          <span className="text-sm text-gray-800">{source.name}</span>
                        </div>
                        <button
                          onClick={() => removeKnowledgeSource(source.id)}
                          className="text-red-600 hover:text-red-700"
                        >
                          ✕
                        </button>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          </div>

          <button
            onClick={handleStartQA}
            className="w-full bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium"
          >
            Start Q&A
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="p-8 w-full max-w-2xl">
      <form onSubmit={handleSubmit} className="flex flex-col gap-4">
        <label htmlFor="prompt" className="text-xl font-bold text-gray-900">
          Enter your design prompt:
        </label>
        <textarea
          id="prompt"
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          placeholder="Design the interface for a 1000-floor elevator"
          className="border border-gray-300 p-4 rounded-lg h-48 text-gray-900 text-base resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white"
        />
        <button 
          type="submit" 
          className="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium"
        >
          Configure Settings
        </button>
      </form>
    </div>
  );
};

export default PromptInput;

----- /Users/jackcrawford/ai-design-flow/components/QAPanel.tsx -----
import { useState } from 'react';

interface SuggestedAnswer {
  text: string;
  confidence: 'high' | 'medium' | 'low';
  sourceReferences?: number[];
}

interface QAPanelProps {
  currentQuestion: string;
  onSubmitAnswer: (answer: string) => void;
  isLoading: boolean;
  hasKnowledgeBase: boolean;
  onAutoPopulate: () => Promise<string | null>;
  suggestedAnswer?: SuggestedAnswer | null;
}

export default function QAPanel({ 
  currentQuestion, 
  onSubmitAnswer, 
  isLoading,
  hasKnowledgeBase,
  onAutoPopulate,
  suggestedAnswer
}: QAPanelProps) {
  const [answer, setAnswer] = useState('');
  const [isAutoPopulating, setIsAutoPopulating] = useState(false);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (answer.trim()) {
      onSubmitAnswer(answer);
      setAnswer('');
    }
  };

  const handleAutoPopulate = async () => {
    setIsAutoPopulating(true);
    try {
      const suggestedAnswer = await onAutoPopulate();
      if (suggestedAnswer) {
        setAnswer(suggestedAnswer);
      } else {
        alert('No relevant information found in the knowledge base. Please provide your expert answer.');
      }
    } catch (error) {
      console.error('Error generating answer:', error);
      alert('There was an error accessing the knowledge base. Please provide your answer manually.');
    } finally {
      setIsAutoPopulating(false);
    }
  };

  return (
    <div className="bg-white rounded-lg p-6 shadow-lg">
      <div className="mb-6">
        <h3 className="text-lg font-semibold text-gray-900 mb-2">Current Question:</h3>
        {isLoading ? (
          <div className="flex items-center space-x-2">
            <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
            <p className="text-gray-600">Loading question...</p>
          </div>
        ) : (
          <p className="text-gray-800">{currentQuestion}</p>
        )}
      </div>

      {suggestedAnswer && (
        <div className="mb-4 p-4 rounded-lg border border-gray-200">
          <div className="flex-1">
            <div className="flex items-center gap-2 mb-1">
              <h4 className="text-sm font-medium">Suggested Answer</h4>
              <span className={`text-xs px-2 py-0.5 rounded-full ${
                suggestedAnswer.confidence === 'high' 
                  ? 'bg-green-100 text-green-800'
                  : suggestedAnswer.confidence === 'medium'
                  ? 'bg-yellow-100 text-yellow-800'
                  : 'bg-gray-100 text-gray-800'
              }`}>
                {suggestedAnswer.confidence} confidence
              </span>
            </div>
            <p className="text-sm">{suggestedAnswer.text}</p>
            {suggestedAnswer.sourceReferences && suggestedAnswer.sourceReferences.length > 0 && (
              <p className="text-xs mt-2 text-gray-600">
                Sources: {suggestedAnswer.sourceReferences.map(ref => `#${ref + 1}`).join(', ')}
              </p>
            )}
            <button
              onClick={handleAutoPopulate}
              className="mt-3 w-full px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
            >
              Use This Answer
            </button>
          </div>
        </div>
      )}

      <form onSubmit={handleSubmit}>
        <div className="space-y-4">
          {hasKnowledgeBase && (
            <button
              type="button"
              onClick={handleAutoPopulate}
              disabled={isLoading || isAutoPopulating}
              className={`w-full px-4 py-2 rounded-lg transition-colors ${
                isLoading || isAutoPopulating
                  ? 'bg-gray-400 cursor-not-allowed'
                  : 'bg-green-600 hover:bg-green-700'
              } text-white flex items-center justify-center gap-2`}
            >
              {isAutoPopulating ? (
                <>
                  <div className="animate-spin rounded-full h-4 w-4 border-2 border-white border-t-transparent"></div>
                  <span>Finding Best Answer...</span>
                </>
              ) : (
                <>
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
                  </svg>
                  <span>Get Suggested Answer</span>
                </>
              )}
            </button>
          )}
          
          <textarea
            value={answer}
            onChange={(e) => setAnswer(e.target.value)}
            className="w-full h-32 p-3 border rounded-lg resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
            placeholder="Type your answer or use the suggestion button above..."
            disabled={isLoading || isAutoPopulating}
          />
          <button
            type="submit"
            className={`w-full px-4 py-2 rounded-lg transition-colors ${
              isLoading || isAutoPopulating || !answer.trim()
                ? 'bg-gray-400 cursor-not-allowed'
                : 'bg-blue-600 hover:bg-blue-700'
            } text-white`}
            disabled={isLoading || isAutoPopulating || !answer.trim()}
          >
            Submit Answer
          </button>
        </div>
      </form>
    </div>
  );
} 

----- /Users/jackcrawford/ai-design-flow/types/index.ts -----
export interface QANode {
  id: string;
  question: string;
  answer?: string;
  children: QANode[];
  questionNumber?: number;
}

export interface RequirementCategory {
  title: string;
  requirements: Array<{
    id: string;
    text: string;
    source: 'user-qa' | 'knowledge-base';
    sourceDetails?: {
      questionId?: string;
      knowledgeBaseIndex?: number;
    };
    priority: 'high' | 'medium' | 'low';
    category: 'functional' | 'technical' | 'ux' | 'accessibility' | 'security' | 'performance';
    tags: string[];
    createdAt: string;
    updatedAt: string;
  }>;
}

export interface RequirementsDocument {
  id: string;
  prompt: string;
  lastUpdated: string;
  categories: {
    basicNeeds: RequirementCategory;
    functionalRequirements: RequirementCategory;
    userExperience: RequirementCategory;
    implementation: RequirementCategory;
    refinements: RequirementCategory;
    constraints: RequirementCategory;
  };
}

export interface MockupVersion {
  id: string;
  timestamp: string;
  name?: string;
  qaTree: QANode;
  requirementsDoc: RequirementsDocument;
  mockupData: {
    code: string;
    colorScheme: {
      primary: string;
      'primary-focus': string;
      'primary-content': string;
      secondary: string;
      'secondary-focus': string;
      'secondary-content': string;
      accent: string;
      'accent-focus': string;
      'accent-content': string;
      neutral: string;
      'neutral-focus': string;
      'neutral-content': string;
      'base-100': string;
      'base-200': string;
      'base-300': string;
      'base-content': string;
      info: string;
      success: string;
      warning: string;
      error: string;
      [key: string]: string;
    };
    components: string[];
    features: string[];
    nextSteps: string[];
  };
}

export interface SessionMetadata {
  id: string;
  prompt: string;
  lastUpdated: string;
  questionCount: number;
  versions: MockupVersion[];
  settings: {
    traversalMode: 'bfs' | 'dfs';
    unknownHandling: 'auto' | 'prompt';
    conflictResolution: 'auto' | 'manual';
  };
  name?: string;
} 

----- /Users/jackcrawford/ai-design-flow/types/pdf-parse.d.ts -----
declare module 'pdf-parse' {
  interface PDFData {
    text: string;
    numpages: number;
    info: any;
    metadata: any;
    version: string;
  }

  function PDFParse(dataBuffer: Buffer, options?: any): Promise<PDFData>;
  export = PDFParse;
} 

----- /Users/jackcrawford/ai-design-flow/types/settings.ts -----
export interface KnowledgeBaseSource {
  id: string;
  type: 'file' | 'text';
  name: string;
  content?: string;
  file?: File;
  processedContent?: {
    requirements?: string[];
    technicalSpecifications?: string[];
    designGuidelines?: string[];
    userPreferences?: string[];
    industryStandards?: string[];
    [key: string]: any;
  };
}

export interface QASettings {
  traversalMode: 'bfs' | 'dfs';
  unknownHandling: 'auto' | 'prompt';
  conflictResolution: 'auto' | 'manual';
  maxQuestions?: number;
  knowledgeBase?: KnowledgeBaseSource[];
} 

----- /Users/jackcrawford/ai-design-flow/.env.local -----
OPENAI_API_KEY=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

----- /Users/jackcrawford/ai-design-flow/.gitignore -----
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts


----- /Users/jackcrawford/ai-design-flow/next-env.d.ts -----
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


----- /Users/jackcrawford/ai-design-flow/next.config.ts -----
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    serverActions: true
  },
  serverExternalPackages: ['pdf-parse']
}

module.exports = nextConfig


----- /Users/jackcrawford/ai-design-flow/package.json -----
{
  "name": "ai-design-flow",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@langchain/community": "^0.3.29",
    "@langchain/openai": "^0.4.2",
    "langchain": "^0.3.15",
    "next": "15.1.6",
    "openai": "^4.83.0",
    "pdf-parse": "^1.1.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "uuid": "^11.0.5"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.1.6",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}


----- /Users/jackcrawford/ai-design-flow/tailwind.config.ts -----
import type { Config } from "tailwindcss";

export default {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        background: "var(--background)",
        foreground: "var(--foreground)",
      },
    },
  },
  plugins: [],
} satisfies Config;


----- /Users/jackcrawford/ai-design-flow/tsconfig.json -----
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


