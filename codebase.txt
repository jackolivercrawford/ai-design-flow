Codebase Tree Structure:
========================
AI-DESIGN-FLOW
  ├── .next
  │   └── ... (contents hidden)
  ├── app
  │   ├── api
  │   │   ├── generate-mockup
  │   │   │   └── route.ts
  │   │   ├── generate-questions
  │   │   │   └── route.ts
  │   │   ├── process-knowledge-base
  │   │   │   └── route.ts
  │   │   └── update-requirements
  │   │       └── route.ts
  │   ├── preview
  │   │   └── page.tsx
  │   ├── qna
  │   │   └── page.tsx
  │   ├── favicon.ico
  │   ├── globals.css
  │   ├── layout.tsx
  │   └── page.tsx
  ├── components
  │   ├── Canvas.tsx
  │   ├── CanvasTree.tsx
  │   ├── HeaderToolbar.tsx
  │   ├── PreviewArea.tsx
  │   ├── PromptInput.tsx
  │   └── QAPanel.tsx
  ├── node_modules
  │   └── ... (contents hidden)
  ├── public
  │   ├── file.svg
  │   ├── globe.svg
  │   ├── next.svg
  │   ├── vercel.svg
  │   └── window.svg
  ├── types
  │   ├── index.ts
  │   ├── pdf-parse.d.ts
  │   └── settings.ts
  ├── .env.local
  ├── .gitignore
  ├── codebase.txt
  ├── Concept.txt
  ├── eslint.config.mjs
  ├── generateCodebase.js
  ├── next-env.d.ts
  ├── next.config.ts
  ├── package-lock.json
  ├── package.json
  ├── postcss.config.mjs
  ├── README.md
  ├── tailwind.config.ts
  └── tsconfig.json


File Contents:
==============

----- /Users/jackcrawford/ai-design-flow/app/api/generate-mockup/route.ts -----
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  try {
    const { prompt, answers } = await request.json();

    // TODO: Implement mockup generation logic
    const generatedContent = {
      requirements: '- Requirement 1\n- Requirement 2\n- Requirement 3',
      uiCode: '<div>Sample UI Code</div>',
    };

    return NextResponse.json(generatedContent);
  } catch (error) {
    console.error('Error generating mockup:', error);
    return NextResponse.json(
      { error: 'Failed to generate mockup' },
      { status: 500 }
    );
  }
} 

----- /Users/jackcrawford/ai-design-flow/app/api/generate-questions/route.ts -----
// /app/api/generate-questions/route.ts
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { KnowledgeBaseSource } from '@/types/settings';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(request: NextRequest) {
  try {
    const { prompt, previousQuestions, traversalMode, knowledgeBase, isAutoPopulate, currentQuestion, depth, parentContext } = await request.json();
    console.log('API received knowledge base:', knowledgeBase);

    // Calculate current depth by counting parents in previousQuestions
    let currentDepth = 0;
    let currentParent = previousQuestions[previousQuestions.length - 1];
    while (currentParent?.parent) {
      currentDepth++;
      currentParent = currentParent.parent;
    }

    // Format knowledge base content for the prompt
    const knowledgeBaseContext = knowledgeBase?.length 
      ? `The following information is available from multiple knowledge base sources:

${knowledgeBase.map((source: KnowledgeBaseSource, index: number) => `
Source ${index + 1} (${source.type === 'file' ? 'File' : 'Text'}: ${source.name}):
Requirements: ${JSON.stringify(source.processedContent?.requirements || [])}
Technical Specs: ${JSON.stringify(source.processedContent?.technicalSpecifications || [])}
Design Guidelines: ${JSON.stringify(source.processedContent?.designGuidelines || [])}
User Preferences: ${JSON.stringify(source.processedContent?.userPreferences || [])}
Industry Standards: ${JSON.stringify(source.processedContent?.industryStandards || [])}
`).join('\n')}

Use this information to:
- Auto-populate answers when confident (especially when multiple sources agree)
- Guide question generation based on available information
- Identify gaps that need to be filled
- Validate answers against known constraints
- Highlight any conflicts between different sources`
      : 'No knowledge base provided.';

    console.log('Formatted knowledge base context:', knowledgeBaseContext);

    const messages = [
      {
        role: 'system' as const,
        content: isAutoPopulate 
          ? `You are an expert UX design assistant that helps suggest answers based on the knowledge base and context. Your task is to provide a well-reasoned answer to the current question.

Knowledge Base Context:
${knowledgeBaseContext}

Previous Questions Already Asked:
${previousQuestions.map((q: { question: string; answer: string }, index: number) => 
  `${index + 1}. Q: ${q.question}\n   A: ${q.answer}`
).join('\n')}

Guidelines for suggesting answers:
1. Focus ONLY on answering the current question
2. Use information from the knowledge base when available
3. Write answers in third person, making definitive statements
4. Avoid second person pronouns (your, you, yours) entirely
5. State suggestions as definitive facts that can be modified
6. Avoid hedging words like "might", "could", "probably", "likely", "maybe"
7. Make clear, direct suggestions even with low confidence
8. If multiple knowledge base sources agree, use that information with high confidence
9. If sources conflict, use the most relevant or recent information
10. If no relevant information exists, provide a reasonable suggestion based on UX best practices`
          : `You are an expert UX design assistant that helps generate follow-up questions for a design prompt. Your questions should follow a clear progression based on the traversal mode.

${parentContext ? `
Current Parent Question Context:
- Parent Question: "${parentContext.parentQuestion}"
- Parent Answer: "${parentContext.parentAnswer}"
- Parent Topics: ${JSON.stringify(parentContext.parentTopics)}

CRITICAL: Any generated question MUST:
1. Be more specific than the parent question
2. Focus on a specific aspect mentioned in the parent's answer
3. Not repeat information already covered in the parent's answer
4. Ask for implementation details or specific requirements about topics mentioned in the parent's answer
` : ''}

Follow these guidelines:
1. Question Progression Levels:
   Current Depth: ${depth}/5
   
   BFS Mode Levels:
   - Level 1 (Basic Needs): Broad, fundamental questions about purpose, audience, and core requirements
     Example: "What is the fundamental purpose of the portfolio website?"
   - Level 2 (Features): Main sections and key features, but not specifics yet
     Example: "What main sections should be included in the navigation?"
   - Level 3 (Details): Specific details about each feature/section identified in level 2
     Example: "What project details should be displayed in each portfolio item?"
   - Level 4 (Refinements): Technical specifications and implementation details
     Example: "What image formats and sizes should be supported for project thumbnails?"
   - Level 5 (Polish): Edge cases and final refinements
     Example: "How should the portfolio handle projects with missing images?"

2. Child Question Generation Rules:
   - Child questions MUST be more specific than their parent question
   - Child questions MUST explore a specific aspect mentioned in the parent's answer
   - NEVER ask the same question as the parent with slightly different wording
   - Example progression:
     Parent Q: "What sections should the portfolio include?"
     Parent A: "The portfolio should include a projects section, about me, skills, and contact."
     Valid child Q: "What specific project details should be displayed in the projects section?"
     Invalid child Q: "What content should be included in the portfolio?"

3. Traversal Rules (${traversalMode}):
   ${traversalMode === 'bfs' 
     ? `BFS Guidelines:
        - At Level 1: Generate at least 3-4 broad, fundamental questions before going deeper
        - Each level should be more specific than the last
        - Questions at the same level should cover different aspects
        - Example progression:
          Level 1: "Who is the target audience?"
          Level 2: "What main navigation sections are needed?"
          Level 3: "What information should appear in the project cards?"
          Level 4: "What should happen when a project card is clicked?"`
     : `DFS Guidelines:
        - Start with a broad topic
        - Each follow-up should be more specific about that topic
        - Example progression:
          Q1: "What project showcase features are needed?"
          Q2: "How should individual project details be displayed?"
          Q3: "What specific project metrics should be highlighted?"
          Q4: "How should project success metrics be visualized?"`
   }

4. Topic Management:
   - Each level should be distinctly more specific than the previous
   - Questions should build upon previous answers
   - Avoid repeating topics already covered
   - Use previous answers to inform specificity
   - Child questions must explore specific aspects mentioned in parent's answer

5. Question Generation:
   - Questions must be specific and focused
   - Include clear parent-child relationships
   - Maintain proper depth progression
   - Follow numbering conventions per mode
   - For child questions:
     * Extract key topics/features from parent's answer
     * Ask about specific implementation details of those topics
     * Focus on one specific aspect rather than broad concepts
     * Ensure the question couldn't be answered by the parent's answer

6. Stopping Criteria:
   - Stop current branch if:
     * Topic is fully explored (all aspects covered)
     * Further questions would be too specific
     * A different topic needs attention
     * Knowledge base provides sufficient information
     * The question would be redundant with parent's answer

7. Knowledge Base Context:
${knowledgeBaseContext}

8. Previous Questions Already Asked:
${previousQuestions.map((q: { question: string; answer: string }, index: number) => 
  `${index + 1}. Q: ${q.question}\n   A: ${q.answer}`
).join('\n')}

9. Response Format:
   {
     "questions": ["Next question to ask"],
     "shouldStopBranch": boolean,
     "stopReason": "Detailed explanation of why we should stop this branch",
     "suggestedAnswer": "string with best guess answer based on knowledge base",
     "sourceReferences": [array of source indices that contributed],
     "confidence": "high" | "medium" | "low",
     "topicsCovered": ["list of topics this question relates to"],
     "parentTopic": "The main topic this question belongs to",
     "subtopics": ["Potential child topics for this question"]
   }

10. Answer Generation Guidelines:
   - Write answers in third person, making definitive statements
   - Avoid second person pronouns (your, you, yours) entirely
   - State suggestions as definitive facts that can be modified
   - Avoid hedging words like "might", "could", "probably", "likely", "maybe"
   - Make clear, direct suggestions even with low confidence`
      },
      {
        role: 'user' as const,
        content: isAutoPopulate
          ? `The design prompt is: "${prompt}"

Current Question: "${currentQuestion}"

Based on the knowledge base and previous Q&A context:
1. Analyze the knowledge base for relevant information about this specific question
2. Consider the context from previous questions and answers
3. Provide a clear, direct answer following the guidelines
4. Indicate which knowledge base sources (if any) contributed to the answer
5. Rate your confidence in the answer as high/medium/low

Return your response in this format:
{
  "questions": [],
  "shouldStopBranch": false,
  "stopReason": "",
  "suggestedAnswer": "Your suggested answer here",
  "sourceReferences": [array of source indices that contributed],
  "confidence": "high" | "medium" | "low"
}`
          : `The design prompt is: "${prompt}".
Previous Q&A History:
${JSON.stringify(previousQuestions, null, 2)}

Current Question: ${previousQuestions[previousQuestions.length - 1]?.question || 'Initial question'}

CRITICAL REQUIREMENTS:
1. Review ALL previous questions and their topics carefully
2. Generate a question that explores a COMPLETELY DIFFERENT aspect not covered in ANY previous question
3. For BFS mode, ensure the new question:
   - Stays at the same level
   - Covers a new topic not related to any previous questions
   - Follows the level-specific topic guidelines
4. Provide a suggested answer following the guidelines

Topics already covered (DO NOT ask about these or related topics):
${previousQuestions.map((q: { question: string }, index: number) => 
  `${index + 1}. ${q.question}`
).join('\n')}

Remember:
- NEVER repeat a topic that's been covered in previous questions
- Each new question must explore a different aspect of the design
- In BFS mode, stay at the current level but explore new topics
- Make clear, direct statements in suggested answers
- Never use second person pronouns`
      },
    ];

    const completion = await openai.chat.completions.create({
      model: 'gpt-4',
      messages,
      temperature: 0.7,
      max_tokens: 500
    });

    const content = completion.choices[0].message.content?.trim();
    if (!content) {
      throw new Error('Empty response from OpenAI');
    }

    console.log('Raw OpenAI response:', content);

    let response: {
      questions: string[];
      shouldStopBranch: boolean;
      stopReason: string;
      suggestedAnswer: string | null;
      sourceReferences: number[];
      confidence?: 'high' | 'medium' | 'low';
      topicsCovered: string[];
      parentTopic: string;
      subtopics: string[];
    };

    try {
      response = JSON.parse(content);
      console.log('Initial parsed response:', response);
      
      // Ensure we always have a suggested answer
      if (!response.suggestedAnswer) {
        console.log('No suggested answer provided, creating a default one');
        response.suggestedAnswer = "Based on general UX principles, a reasonable approach would be...";
        response.confidence = 'low';
        response.sourceReferences = [];
      }
      
      if (!Array.isArray(response.questions)) {
        throw new Error("Questions is not an array");
      }
      
      // Clean up questions to ensure they're plain text
      response.questions = response.questions.map((q: any) => {
        if (typeof q === 'string') {
          // Try to parse if it looks like JSON
          try {
            const parsed = JSON.parse(q);
            return parsed.question || parsed.text || q;
          } catch {
            return q;
          }
        }
        return q.question || q.text || JSON.stringify(q);
      });
      
      // Ensure suggestedAnswer has the required format
      if (response.suggestedAnswer) {
        console.log('Found suggested answer:', response.suggestedAnswer);
        
        // Make sure suggestedAnswer is a string
        const suggestedAnswerText = typeof response.suggestedAnswer === 'object' 
          ? (response.suggestedAnswer as { text?: string }).text || JSON.stringify(response.suggestedAnswer)
          : response.suggestedAnswer;
        
        response = {
          ...response,
          suggestedAnswer: suggestedAnswerText,
          confidence: response.confidence || 'high',  // Default to high if we have a suggestion
          sourceReferences: response.sourceReferences || []
        };
        console.log('Formatted response with suggestion:', response);
      } else {
        console.log('No suggested answer in response');
      }
    } catch (jsonError) {
      console.error("Error parsing API response:", jsonError);
      // Fallback: extract questions from text
      response = {
        questions: [content], // Use the entire content as a single question
        shouldStopBranch: false,
        stopReason: '',
        suggestedAnswer: null,
        sourceReferences: [],
        confidence: 'low',
        topicsCovered: [],
        parentTopic: '',
        subtopics: []
      };
    }

    return NextResponse.json(response);
  } catch (error) {
    console.error('Error generating questions:', error);
    return NextResponse.json(
      { error: 'Failed to generate questions' },
      { status: 500 }
    );
  }
}


----- /Users/jackcrawford/ai-design-flow/app/api/process-knowledge-base/route.ts -----
import { NextRequest } from 'next/server';
import OpenAI from 'openai';
import pdfParse from 'pdf-parse';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

async function extractTextFromPDF(buffer: Buffer): Promise<string> {
  try {
    const data = await pdfParse(buffer);
    return data.text;
  } catch (error) {
    console.error('Error extracting text from PDF:', error);
    throw new Error('Failed to extract text from PDF');
  }
}

async function processContent(content: string) {
  try {
    const completion = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content: `You are a knowledge base processor. Extract key information from the provided document that would be relevant for the design process. Focus on:
1. Requirements and constraints
2. Technical specifications
3. Design guidelines
4. User preferences or patterns
5. Industry standards or best practices

Return your response in this exact JSON format:
{
  "requirements": [],
  "technicalSpecifications": [],
  "designGuidelines": [],
  "userPreferences": [],
  "industryStandards": []
}`
        },
        {
          role: "user",
          content
        }
      ],
      temperature: 0.7,
      max_tokens: 2000
    });

    const responseContent = completion.choices[0].message.content;
    if (!responseContent) {
      throw new Error('Empty response from OpenAI');
    }

    try {
      return JSON.parse(responseContent);
    } catch (parseError) {
      console.error('Error parsing OpenAI response:', parseError);
      throw new Error('Failed to parse OpenAI response');
    }
  } catch (error) {
    console.error('Error processing content with OpenAI:', error);
    throw new Error('Failed to process content');
  }
}

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const sourceType = formData.get('type');
    const file = formData.get('file');
    const textContent = formData.get('content');

    if (!sourceType) {
      return new Response(JSON.stringify({ error: 'Source type is required' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    let content: string;

    if (sourceType === 'file' && file) {
      // Check if the file has arrayBuffer method (indicating it's a File or Blob)
      const fileObject = file as { arrayBuffer(): Promise<ArrayBuffer>; type?: string; name?: string };
      
      if ('arrayBuffer' in fileObject && typeof fileObject.arrayBuffer === 'function') {
        const buffer = Buffer.from(await fileObject.arrayBuffer());
        
        // Check file type using the file's type property or name
        const fileType = fileObject.type || '';
        const fileName = fileObject.name || '';
        
        if (fileType === 'application/pdf' || fileName.toLowerCase().endsWith('.pdf')) {
          content = await extractTextFromPDF(buffer);
        } else {
          // For text files, convert buffer to string
          content = buffer.toString('utf-8');
        }
      } else {
        throw new Error('Invalid file format');
      }
    } else if (sourceType === 'text' && typeof textContent === 'string') {
      content = textContent;
    } else {
      return new Response(JSON.stringify({ error: 'Invalid input' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    const processedContent = await processContent(content);

    return new Response(JSON.stringify({ success: true, processedContent }), {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
    });

  } catch (error: unknown) {
    console.error('Error in API route:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
    return new Response(JSON.stringify({ error: 'Internal server error', details: errorMessage }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
} 

----- /Users/jackcrawford/ai-design-flow/app/api/update-requirements/route.ts -----
import { NextRequest, NextResponse } from 'next/server';
import OpenAI from 'openai';
import { RequirementsDocument, QANode } from '@/types';
import { KnowledgeBaseSource } from '@/types/settings';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

function findNodeById(root: QANode | null, id: string): QANode | null {
  if (!root) return null;
  if (root.id === id) return root;
  for (const child of root.children) {
    const found = findNodeById(child, id);
    if (found) return found;
  }
  return null;
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    console.log('Received update request:', body);
    
    const { qaTree, currentNodeId, knowledgeBase, existingDocument } = body;
    
    if (!qaTree || !existingDocument) {
      return NextResponse.json(
        { error: 'QA Tree and existing document are required' },
        { status: 400 }
      );
    }
    
    // Find the current node that was just answered
    const currentNode = currentNodeId ? findNodeById(qaTree, currentNodeId) : null;
    
    // Format the Q&A history and knowledge base for the AI
    const qaContext = JSON.stringify({
      question: currentNode?.question || 'No current question',
      answer: currentNode?.answer || 'No answer',
      previousQuestions: qaTree.children.map((node: QANode) => ({
        question: node.question,
        answer: node.answer
      }))
    }, null, 2);

    const knowledgeBaseContext = knowledgeBase?.length
      ? knowledgeBase.map((source: KnowledgeBaseSource, index: number) => 
          `Source ${index + 1}: ${Object.entries(source.processedContent || {})
            .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
            .join('\n')}`
        ).join('\n\n')
      : 'No knowledge base provided';

    console.log('Sending to OpenAI:', {
      qaContext: qaContext.substring(0, 100) + '...',
      knowledgeBaseContext: knowledgeBaseContext.substring(0, 100) + '...'
    });

    const completion = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content: `You are a requirements document updater. Your task is to update a requirements document based on Q&A session information and knowledge base data.

CRITICAL INSTRUCTIONS:
1. You MUST return ONLY a valid JSON object.
2. DO NOT include any explanatory text, markdown, or other content.
3. DO NOT wrap the JSON in code blocks or quotes.
4. The JSON must exactly match this structure:
{
  "id": string,
  "prompt": string,
  "lastUpdated": string (ISO date),
  "categories": {
    "basicNeeds": {
      "title": "Basic Needs",
      "requirements": []
    },
    "functionalRequirements": {
      "title": "Functional Requirements",
      "requirements": []
    },
    "userExperience": {
      "title": "User Experience",
      "requirements": []
    },
    "implementation": {
      "title": "Implementation",
      "requirements": []
    },
    "refinements": {
      "title": "Refinements",
      "requirements": []
    },
    "constraints": {
      "title": "Constraints",
      "requirements": []
    }
  }
}`
        },
        {
          role: "user",
          content: `Current Requirements Document:
${JSON.stringify(existingDocument, null, 2)}

Latest Q&A:
${qaContext}

Knowledge Base Information:
${knowledgeBaseContext}

Update the requirements document with any new information from the Q&A and knowledge base. Return ONLY the updated document as a JSON object. Do not include any additional text or formatting.`
        }
      ],
      temperature: 0.3,
      max_tokens: 2000
    });

    const content = completion.choices[0].message.content;
    if (!content) {
      throw new Error('Empty response from OpenAI');
    }

    console.log('OpenAI response:', content.substring(0, 100) + '...');

    try {
      const updatedDocument = JSON.parse(content);
      
      // Validate the document structure
      if (!updatedDocument.id || !updatedDocument.categories) {
        console.error('Invalid document structure:', updatedDocument);
        return NextResponse.json(existingDocument);
      }
      
      // Ensure all required categories exist
      const requiredCategories = [
        'basicNeeds',
        'functionalRequirements',
        'userExperience',
        'implementation',
        'refinements',
        'constraints'
      ];
      
      const hasAllCategories = requiredCategories.every(
        category => updatedDocument.categories[category]
      );
      
      if (!hasAllCategories) {
        console.error('Missing required categories');
        return NextResponse.json(existingDocument);
      }
      
      return NextResponse.json(updatedDocument);
    } catch (parseError) {
      console.error('Error parsing OpenAI response:', parseError);
      console.error('Raw response:', content);
      // If parsing fails, return the existing document unchanged
      return NextResponse.json(existingDocument);
    }
  } catch (error) {
    console.error('Error updating requirements:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error occurred' },
      { status: 500 }
    );
  }
} 

----- /Users/jackcrawford/ai-design-flow/app/preview/page.tsx -----
'use client';

import { useEffect, useState } from 'react';
import PreviewArea from '@/components/PreviewArea';
import HeaderToolbar from '@/components/HeaderToolbar';

export default function PreviewPage() {
  const [generatedContent, setGeneratedContent] = useState({
    requirements: '',
    uiCode: '',
  });

  useEffect(() => {
    const storedContent = localStorage.getItem('generatedContent');
    if (storedContent) {
      setGeneratedContent(JSON.parse(storedContent));
    }
  }, []);

  return (
    <div className="min-h-screen flex flex-col">
      <HeaderToolbar />
      <main className="flex-1 container mx-auto px-4 py-8">
        <h1 className="text-3xl font-bold mb-8">Generated Preview</h1>
        <PreviewArea
          requirements={generatedContent.requirements}
          uiCode={generatedContent.uiCode}
        />
      </main>
    </div>
  );
}

----- /Users/jackcrawford/ai-design-flow/app/qna/page.tsx -----
// /app/qna/page.tsx
'use client';

import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { v4 as uuidv4 } from 'uuid';
import HeaderToolbar from '../../components/HeaderToolbar';
import QAPanel from '../../components/QAPanel';
import CanvasTree from '../../components/CanvasTree';
import { QANode, RequirementsDocument } from '@/types';
import { QASettings } from '@/types/settings';

interface SavedProgress {
  qaTree: QANode;
  currentNodeId: string | null;
  questionCount: number;
  prompt: string;
  settings: QASettings;
  requirementsDoc: RequirementsDocument;
}

interface QuestionHistoryItem {
  question: string;
  answer?: string;
  topics: string[];
}

export default function QnAPage() {
  const router = useRouter();
  const [prompt, setPrompt] = useState<string>('');
  const [settings, setSettings] = useState<QASettings | null>(null);
  const [qaTree, setQaTree] = useState<QANode | null>(null);
  const [currentNode, setCurrentNode] = useState<QANode | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isLoadingNextQuestion, setIsLoadingNextQuestion] = useState(false);
  const [questionCount, setQuestionCount] = useState(0);
  const [suggestedAnswer, setSuggestedAnswer] = useState<{
    text: string;
    confidence: 'high' | 'medium' | 'low';
    sourceReferences: number[];
  } | null>(null);
  const [requirementsDoc, setRequirementsDoc] = useState<RequirementsDocument | null>(null);
  const [askedQuestions, setAskedQuestions] = useState<Set<string>>(new Set());
  const [askedTopics, setAskedTopics] = useState<Set<string>>(new Set());

  // Helper: Extract topics from a question
  const extractTopics = (question: string): string[] => {
    const topics = [];
    // Common topic indicators in questions
    if (question.toLowerCase().includes('audience') || 
        question.toLowerCase().includes('user') || 
        question.toLowerCase().includes('visitor')) {
      topics.push('audience');
    }
    if (question.toLowerCase().includes('purpose') || 
        question.toLowerCase().includes('goal')) {
      topics.push('purpose');
    }
    // Add more topic extractors as needed
    return topics;
  };

  // Helper: Get the next question based on traversal mode
  const getNextQuestion = async (node: QANode): Promise<QANode | null> => {
    const isDFS = settings?.traversalMode === 'dfs';
    
    if (isDFS) {
      // DFS: Try to go deeper first by exploring the current topic fully
      if (node.answer) {
        // Build complete question history including topics for the current branch
        const branchHistory: QuestionHistoryItem[] = [];
        let current: QANode | null = node;
        let depth = 0;
        
        // Collect the current branch's history and calculate depth
        while (current) {
          if (current.question !== `Prompt: ${prompt}`) {
            branchHistory.unshift({
              question: current.question,
              answer: current.answer,
              topics: extractTopics(current.question)
            });
            depth++;
          }
          const parent = findParentNode(qaTree!, current);
          if (!parent || parent === current) break;
          current = parent;
        }

        // Try to generate a child question that explores the current topic deeper
        const { nodes: children, shouldStopBranch, stopReason } = await fetchQuestionsForNode(
          prompt, 
          node,
          branchHistory,
          depth
        );
        
        // If the AI suggests stopping this branch, move to siblings
        if (shouldStopBranch) {
          console.log(`Stopping current branch: ${stopReason}`);
          // Find the next sibling at the highest incomplete level
          let searchNode: QANode | null = node;
          while (searchNode) {
            const parent = findParentNode(qaTree!, searchNode);
            if (!parent) break;
            
            const siblings = parent.children;
            const currentIndex = siblings.indexOf(searchNode);
            
            if (currentIndex < siblings.length - 1) {
              return siblings[currentIndex + 1];
            }
            searchNode = parent;
          }
        } 
        // If we got new questions, verify they explore the current topic deeper
        else if (children.length > 0) {
          const newQuestionTopics = extractTopics(children[0].question);
          const currentTopics = extractTopics(node.question);
          
          // Check if the new question is related to the current topic
          const isRelatedTopic = currentTopics.some(topic => 
            newQuestionTopics.includes(topic) || 
            newQuestionTopics.some(t => t.includes(topic))
          );

          if (isRelatedTopic) {
            // Set the question number based on exploration order
            children[0].questionNumber = questionCount + 1;
            node.children = children;
            return children[0];
          } else {
            console.log('Generated question explores unrelated topic, trying siblings instead');
            // Try to find the next sibling that continues the current topic
            const parent = findParentNode(qaTree!, node);
            if (parent) {
              const siblings = parent.children;
              const currentIndex = siblings.indexOf(node);
              if (currentIndex < siblings.length - 1) {
                return siblings[currentIndex + 1];
              }
            }
          }
        }
      }
      
      return null; // No more questions in this branch
      
    } else {
      // BFS: Complete all questions at the current level before going deeper
      const parent = findParentNode(qaTree!, node);
      if (!parent) return null;
      
      // Get all nodes at the current level
      const currentLevelNodes = parent.children;
      const currentIndex = currentLevelNodes.indexOf(node);
      const currentDepth = getNodeDepth(node);
      
      // Build question history for current level
      const levelHistory: QuestionHistoryItem[] = currentLevelNodes.map(n => ({
        question: n.question,
        answer: n.answer,
        topics: extractTopics(n.question)
      }));
      
      // Check if all nodes at current level are answered
      const allCurrentLevelAnswered = currentLevelNodes.every(n => n.answer);
      
      // If there are existing unanswered siblings, move to the next one
      if (currentIndex < currentLevelNodes.length - 1) {
        return currentLevelNodes[currentIndex + 1];
      }
      
      // For top level (depth 1), ensure we have enough broad coverage before going deeper
      // We want at least 3-4 high-level questions answered before considering going deeper
      const isTopLevel = currentDepth === 1;
      const shouldGenerateMoreSiblings = isTopLevel ? 
        currentLevelNodes.length < 4 : // At top level, always try to get at least 4 questions
        !allCurrentLevelAnswered;      // At other levels, generate siblings until all are answered
      
      // Only try to generate new siblings if we haven't completed the current level
      // or if we need more top-level coverage
      if (shouldGenerateMoreSiblings) {
        const { nodes: newSiblings, shouldStopBranch } = await fetchQuestionsForNode(
          prompt,
          parent,
          levelHistory,
          currentDepth
        );
        
        if (!shouldStopBranch && newSiblings.length > 0) {
          // Set the question number sequentially within the layer
          newSiblings[0].questionNumber = questionCount + 1;
          parent.children = [...currentLevelNodes, ...newSiblings];
          return newSiblings[0];
        }
      }
      
      // Only if ALL nodes at current level are answered AND we have enough top-level coverage,
      // start going deeper
      if (allCurrentLevelAnswered && (!isTopLevel || currentLevelNodes.length >= 3)) {
        // Find the first answered node that doesn't have children yet
        for (const sibling of currentLevelNodes) {
          if (sibling.answer && sibling.children.length === 0) {
            const siblingHistory = levelHistory.filter(h => 
              extractTopics(h.question).some(t => 
                extractTopics(sibling.question).includes(t)
              )
            );
            
            const { nodes: children, shouldStopBranch } = await fetchQuestionsForNode(
              prompt,
              sibling,
              siblingHistory,
              currentDepth + 1
            );
            
            if (!shouldStopBranch && children.length > 0) {
              // Set the question number sequentially for the next layer
              children[0].questionNumber = questionCount + 1;
              sibling.children = children;
              return children[0];
            }
          }
        }
      }
      
      return null; // No more questions at this level or deeper
    }
  };

  // Helper: Get the depth of a node in the tree
  const getNodeDepth = (node: QANode): number => {
    let depth = 0;
    let current = node;
    while (findParentNode(qaTree!, current)) {
      depth++;
      current = findParentNode(qaTree!, current)!;
    }
    return depth;
  };

  // Helper: Find parent node
  const findParentNode = (root: QANode | null, target: QANode): QANode | null => {
    if (!root) return null;
    if (root.children.includes(target)) return root;
    for (const child of root.children) {
      const found = findParentNode(child, target);
      if (found) return found;
    }
    return null;
  };

  // Helper: Find all nodes at the same level as the target node
  const findNodesAtSameLevel = (root: QANode | null, target: QANode): QANode[] => {
    if (!root) return [];
    const parent = findParentNode(root, target);
    if (!parent) return root.children; // If no parent, must be root level
    return parent.children;
  };

  // Helper: Find the first unanswered child in the tree (BFS)
  const findFirstUnansweredChild = (root: QANode | null): QANode | null => {
    if (!root) return null;
    const queue: QANode[] = [root];
    while (queue.length > 0) {
      const node = queue.shift()!;
      // Skip the root node when looking for unanswered questions
      if (node.children.length > 0) {
        for (const child of node.children) {
          if (!child.answer) return child;
          queue.push(child);
        }
      } else if (!node.answer && node.question !== `Prompt: ${prompt}`) {
        return node;
      }
    }
    return null;
  };

  // Helper: Find the first node that can have children (has answer but no children)
  const findFirstNodeForChildren = (root: QANode | null): QANode | null => {
    if (!root) return null;
    const queue: QANode[] = [root];
    while (queue.length > 0) {
      const node = queue.shift()!;
      // Skip the root node when looking for nodes that can have children
      if (node.answer && node.children.length === 0 && node.question !== `Prompt: ${prompt}`) {
        return node;
      }
      queue.push(...node.children);
    }
    return null;
  };

  // Helper: fetch questions for a node
  const fetchQuestionsForNode = async (designPrompt: string, parentNode: QANode, questionHistory: QuestionHistoryItem[], depth: number): Promise<{ nodes: QANode[], shouldStopBranch: boolean, stopReason: string }> => {
    try {
      console.log('Fetching questions with knowledge base:', settings?.knowledgeBase);
      
      // Get parent context for child questions
      const parentContext = parentNode.question !== `Prompt: ${designPrompt}` ? {
        parentQuestion: parentNode.question,
        parentAnswer: parentNode.answer,
        parentTopics: extractTopics(parentNode.question)
      } : null;
      
      const response = await fetch('/api/generate-questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt: designPrompt,
          previousQuestions: questionHistory,
          traversalMode: settings?.traversalMode,
          knowledgeBase: settings?.knowledgeBase,
          depth: depth,
          parentContext: parentContext // Add parent context to help generate more specific child questions
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error occurred' }));
        throw new Error(`API request failed: ${errorData.error || response.statusText}`);
      }

      const data = await response.json();
      console.log('Received API response with suggested answer:', data.suggestedAnswer);
      
      if (!data || !Array.isArray(data.questions) || data.questions.length === 0) {
        throw new Error('Invalid response format or no questions received');
      }

      // Set suggested answer if available
      if (data.suggestedAnswer) {
        console.log('Setting suggested answer:', {
          text: data.suggestedAnswer,
          confidence: data.confidence || 'low',
          sourceReferences: data.sourceReferences || []
        });
        
        setSuggestedAnswer({
          text: data.suggestedAnswer,
          confidence: data.confidence || 'low',
          sourceReferences: data.sourceReferences || []
        });
      } else {
        console.log('Clearing suggested answer');
        setSuggestedAnswer(null);
      }
      
      // Create a single child node with the next question number
      const nextQuestionNumber = questionCount + 1;
      const nodes: QANode[] = data.questions.slice(0, 1).map((q: string) => ({
        id: uuidv4(),
        question: q,
        children: [],
        questionNumber: nextQuestionNumber,
      }));
      
      return {
        nodes,
        shouldStopBranch: data.shouldStopBranch || false,
        stopReason: data.stopReason || 'No more questions needed'
      };
    } catch (error) {
      console.error("Error in fetchQuestionsForNode:", error);
      // Return a default error question node
      const errorNode: QANode = {
        id: uuidv4(),
        question: "Failed to generate question. Please try again or refresh the page.",
        children: [],
        questionNumber: questionCount + 1,
      };
      return { 
        nodes: [errorNode], 
        shouldStopBranch: true, 
        stopReason: error instanceof Error ? error.message : "Error generating questions" 
      };
    }
  };

  // Helper: Find node by ID in the tree
  const findNodeById = (root: QANode | null, id: string): QANode | null => {
    if (!root) return null;
    if (root.id === id) return root;
    for (const child of root.children) {
      const found = findNodeById(child, id);
      if (found) return found;
    }
    return null;
  };

  // Helper: Update requirements document
  const updateRequirements = async (nodeId: string | null) => {
    try {
      if (!qaTree || !requirementsDoc) {
        console.warn('Missing qaTree or requirementsDoc, skipping requirements update');
        return;
      }

      const response = await fetch('/api/update-requirements', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          qaTree,
          currentNodeId: nodeId,
          knowledgeBase: settings?.knowledgeBase,
          existingDocument: requirementsDoc
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error occurred' }));
        throw new Error(`API request failed: ${errorData.error || response.statusText}`);
      }

      const updatedDoc = await response.json();
      if (!updatedDoc || !updatedDoc.categories) {
        throw new Error('Invalid requirements document received');
      }

      setRequirementsDoc(updatedDoc);
      
      // Save progress including requirements
      saveProgress();
    } catch (error) {
      console.error('Error updating requirements:', error);
      // Don't throw the error, just log it and continue
    }
  };

  // Helper: Save current progress to localStorage
  const saveProgress = () => {
    if (!qaTree || !settings) return;
    
    const progress: SavedProgress = {
      qaTree,
      currentNodeId: currentNode?.id || null,
      questionCount,
      prompt,
      settings,
      requirementsDoc: requirementsDoc!
    };
    
    localStorage.setItem('qaProgress', JSON.stringify(progress));
  };

  // Effect to save progress whenever relevant state changes
  useEffect(() => {
    if (qaTree && !isLoading) {
      saveProgress();
    }
  }, [qaTree, currentNode, questionCount, prompt, settings]);

  // On mount: try to load saved progress or start new session
  useEffect(() => {
    const savedProgress = localStorage.getItem('qaProgress');
    const storedPrompt = localStorage.getItem('designPrompt');
    const storedSettings = localStorage.getItem('qaSettings');
    
    if (savedProgress) {
      // Load saved progress
      try {
        const progress: SavedProgress = JSON.parse(savedProgress);
        console.log('Loaded settings with knowledge base:', progress.settings.knowledgeBase);
        setPrompt(progress.prompt);
        setSettings(progress.settings);
        setQaTree(progress.qaTree);
        setQuestionCount(progress.questionCount);
        setRequirementsDoc(progress.requirementsDoc);
        if (progress.currentNodeId) {
          const node = findNodeById(progress.qaTree, progress.currentNodeId);
          setCurrentNode(node);
        }
        setIsLoading(false);
        return;
      } catch (error) {
        console.error("Error loading saved progress:", error);
      }
    }
    
    // Start new session
    if (storedPrompt && storedSettings) {
      const parsedSettings = JSON.parse(storedSettings);
      console.log('Starting new session with knowledge base:', parsedSettings.knowledgeBase);
      setPrompt(storedPrompt);
      setSettings(parsedSettings);
      
      // Create and set up root node (Q0)
      const rootNode: QANode = {
        id: uuidv4(),
        question: `Prompt: ${storedPrompt}`,
        children: [],
        questionNumber: 0, // Explicitly set prompt as Q0
      };
      setQaTree(rootNode);
      
      // Initialize requirements document
      const initialRequirementsDoc: RequirementsDocument = {
        id: uuidv4(),
        prompt: storedPrompt,
        lastUpdated: new Date().toISOString(),
        categories: {
          basicNeeds: { title: 'Basic Needs', requirements: [] },
          functionalRequirements: { title: 'Functional Requirements', requirements: [] },
          userExperience: { title: 'User Experience', requirements: [] },
          implementation: { title: 'Implementation', requirements: [] },
          refinements: { title: 'Refinements', requirements: [] },
          constraints: { title: 'Constraints', requirements: [] }
        }
      };
      setRequirementsDoc(initialRequirementsDoc);
      
      // Generate first question (Q1)
      fetchQuestionsForNode(storedPrompt, rootNode, [], 0).then(({ nodes: children }) => {
        if (children.length > 0) {
          // Set first actual question as Q1
          children[0].questionNumber = 1;
          rootNode.children = children;
          setQaTree({ ...rootNode });
          setCurrentNode(children[0]);
          setQuestionCount(1);
        }
        setIsLoading(false);
      });
    } else {
      console.error("No design prompt or settings found.");
      router.push('/');
    }
  }, [router]);

  // When the user submits an answer
  const handleAnswer = async (answer: string) => {
    if (!currentNode || !settings) return;
    
    setIsLoadingNextQuestion(true);
    setSuggestedAnswer(null);
    
    // Check if we've hit the question limit
    if (settings.maxQuestions && questionCount >= settings.maxQuestions) {
      setCurrentNode(null);
      setIsLoadingNextQuestion(false);
      return;
    }
    
    try {
      // Record the answer
      currentNode.answer = answer;
      
      // Update requirements document with new answer
      await updateRequirements(currentNode.id);
      
      // Get the next question based on traversal mode
      const nextNode = await getNextQuestion(currentNode);
      
      if (nextNode) {
        // Verify this question hasn't been asked before
        if (!askedQuestions.has(nextNode.question)) {
          // Add the question to the set of asked questions
          setAskedQuestions(prev => new Set(prev).add(nextNode.question));
          
          // In BFS mode, the next node should already be properly placed by getNextQuestion
          // We don't need to add it to any parent's children here as that's handled in getNextQuestion
          setCurrentNode(nextNode);
          setQuestionCount(prev => prev + 1);
          // Update the tree state to trigger re-render
          setQaTree(prev => prev ? { ...prev } : prev);
        } else {
          console.warn('Duplicate question detected:', nextNode.question);
          setCurrentNode(null);
        }
      } else {
        setCurrentNode(null); // No more questions
        // Final requirements update with no current node
        await updateRequirements(null);
      }
    } catch (error) {
      console.error('Error in handleAnswer:', error);
    } finally {
      setIsLoadingNextQuestion(false);
    }
  };

  const handleAutoPopulate = async (): Promise<string | null> => {
    try {
      // Build the previous Q&A chain up to the current question
      const questionHistory: QuestionHistoryItem[] = [];
      const collectHistory = (n: QANode) => {
        if (n.question !== `Prompt: ${prompt}`) {
          questionHistory.push({
            question: n.question,
            answer: n.answer,
            topics: extractTopics(n.question)
          });
        }
        n.children.forEach(collectHistory);
      };
      collectHistory(qaTree!);

      const response = await fetch('/api/generate-questions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt,
          previousQuestions: questionHistory,  // Pass the full question history
          traversalMode: settings?.traversalMode,
          knowledgeBase: settings?.knowledgeBase,
          currentQuestion: currentNode?.question,
          isAutoPopulate: true // Flag to indicate this is for auto-populate
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to generate answer');
      }

      const data = await response.json();
      console.log('Auto-populate response:', data);
      
      // Return the suggestedAnswer text if it exists
      if (data.suggestedAnswer) {
        return data.suggestedAnswer;
      }
      
      return null;
    } catch (error) {
      console.error('Error auto-populating answer:', error);
      return null;
    }
  };

  const handleRestart = () => {
    // Set loading state
    setIsLoading(true);
    setIsLoadingNextQuestion(true);
    
    // Create new root node (Q0)
    const rootNode: QANode = {
      id: uuidv4(),
      question: `Prompt: ${prompt}`,
      children: [],
      questionNumber: 0, // Explicitly set prompt as Q0
    };
    
    // Reset all states
    setQaTree(rootNode);
    setQuestionCount(0);
    setCurrentNode(null);
    setAskedQuestions(new Set());
    setAskedTopics(new Set());
    
    // Reset requirements document
    const initialRequirementsDoc: RequirementsDocument = {
      id: uuidv4(),
      prompt: prompt,
      lastUpdated: new Date().toISOString(),
      categories: {
        basicNeeds: { title: 'Basic Needs', requirements: [] },
        functionalRequirements: { title: 'Functional Requirements', requirements: [] },
        userExperience: { title: 'User Experience', requirements: [] },
        implementation: { title: 'Implementation', requirements: [] },
        refinements: { title: 'Refinements', requirements: [] },
        constraints: { title: 'Constraints', requirements: [] }
      }
    };
    setRequirementsDoc(initialRequirementsDoc);
    
    // Generate first question (Q1)
    fetchQuestionsForNode(prompt, rootNode, [], 0)
      .then(({ nodes: children }) => {
        if (children.length > 0) {
          // Set first actual question as Q1
          children[0].questionNumber = 1;
          rootNode.children = children;
          setQaTree({ ...rootNode });
          setCurrentNode(children[0]);
          setQuestionCount(1);
        }
      })
      .catch(error => {
        console.error('Error generating first question:', error);
      })
      .finally(() => {
        setIsLoading(false);
        setIsLoadingNextQuestion(false);
      });
  };

  return (
    <div className="min-h-screen flex flex-col bg-gray-100">
      <HeaderToolbar onRestart={handleRestart} showRestartButton={!isLoading} />
      <div className="py-2 px-6 bg-white border-b border-gray-200">
        <div className="flex justify-between items-center">
          <div className="text-sm text-gray-600">
            Questions: {questionCount}{settings?.maxQuestions ? ` / ${settings.maxQuestions}` : ''}
          </div>
          <div className="text-sm text-gray-600">
            Mode: {settings?.traversalMode === 'dfs' ? 'Depth-First' : 'Breadth-First'}
          </div>
        </div>
      </div>
      <main className="flex-1 flex">
        {/* Left: Canvas Tree view */}
        <div className="w-2/3 p-6 overflow-auto">
          <div className="bg-white rounded-lg shadow-lg p-6 min-h-full">
            <h2 className="text-2xl font-bold mb-6 text-gray-900">Question Tree</h2>
            {isLoading ? (
              <div className="flex items-center justify-center h-32">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
              </div>
            ) : (
              <CanvasTree node={qaTree} />
            )}
          </div>
        </div>
        {/* Right: Q&A Panel */}
        <div className="w-1/3 p-6 overflow-auto border-l border-gray-200">
          <QAPanel
            currentQuestion={
              currentNode
                ? currentNode.question
                : "No more questions. Q&A complete."
            }
            onSubmitAnswer={handleAnswer}
            isLoading={isLoading || isLoadingNextQuestion}
            hasKnowledgeBase={Boolean(settings?.knowledgeBase?.length)}
            onAutoPopulate={handleAutoPopulate}
          />
        </div>
      </main>
    </div>
  );
}


----- /Users/jackcrawford/ai-design-flow/app/globals.css -----
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
}


----- /Users/jackcrawford/ai-design-flow/app/layout.tsx -----
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}


----- /Users/jackcrawford/ai-design-flow/app/page.tsx -----
// app/page.tsx
'use client';

import { useRouter } from 'next/navigation';
import { useEffect, useState } from 'react';
import PromptInput from '@/components/PromptInput';
import { QASettings } from '@/types/settings';

interface SavedProgress {
  qaTree: any;
  currentNodeId: string | null;
  questionCount: number;
  prompt: string;
  settings: QASettings;
}

export default function PromptPage() {
  const router = useRouter();
  const [savedSession, setSavedSession] = useState<SavedProgress | null>(null);

  useEffect(() => {
    const savedProgress = localStorage.getItem('qaProgress');
    if (savedProgress) {
      try {
        const progress = JSON.parse(savedProgress);
        setSavedSession(progress);
      } catch (error) {
        console.error("Error loading saved session:", error);
      }
    }
  }, []);

  const handlePromptSubmit = (prompt: string, settings: QASettings) => {
    console.log("User prompt:", prompt);
    console.log("Settings:", settings);
    
    // Clear any existing progress
    localStorage.removeItem('qaProgress');
    
    // Save new prompt and settings
    localStorage.setItem('designPrompt', prompt);
    localStorage.setItem('qaSettings', JSON.stringify(settings));
    router.push('/qna');
  };

  const handleContinueSession = () => {
    router.push('/qna');
  };

  return (
    <div className="min-h-screen flex flex-col justify-center items-center bg-gray-50 px-4">
      {/* Header */}
      <header className="mb-8 text-center">
        <h1 className="text-4xl font-bold text-gray-800">Welcome to AI Design Flow</h1>
        <p className="mt-4 text-lg text-gray-600">
          Enter your design prompt to kick off your interactive design journey.
        </p>
      </header>
      
      {/* Saved Session */}
      {savedSession && (
        <div className="w-full max-w-2xl mb-8">
          <div className="bg-white rounded-lg shadow-lg p-6 border border-gray-200">
            <h2 className="text-xl font-bold text-gray-900 mb-4">Continue Previous Session</h2>
            <div className="space-y-2 mb-4">
              <p className="text-gray-700">
                <span className="font-medium">Prompt:</span> {savedSession.prompt}
              </p>
              <p className="text-gray-700">
                <span className="font-medium">Progress:</span> {savedSession.questionCount} questions answered
              </p>
              <p className="text-gray-700">
                <span className="font-medium">Mode:</span> {savedSession.settings.traversalMode === 'dfs' ? 'Depth-First' : 'Breadth-First'}
              </p>
            </div>
            <div className="flex gap-4">
              <button
                onClick={handleContinueSession}
                className="flex-1 bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium"
              >
                Continue Session
              </button>
              <button
                onClick={() => setSavedSession(null)}
                className="flex-1 bg-gray-100 text-gray-700 px-6 py-3 rounded-lg hover:bg-gray-200 transition-colors font-medium"
              >
                Start New Session
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Prompt Input */}
      {!savedSession && (
        <div className="w-full max-w-2xl">
          <PromptInput onSubmit={handlePromptSubmit} />
        </div>
      )}
    </div>
  );
}


----- /Users/jackcrawford/ai-design-flow/components/Canvas.tsx -----
interface CanvasProps {
  answers: Array<{ question: string; answer: string }>;
}

export default function Canvas({ answers }: CanvasProps) {
  return (
    <div className="bg-gray-50 rounded-lg p-6 overflow-auto">
      <h2 className="text-xl font-semibold mb-4">Design Flow</h2>
      <div className="space-y-4">
        {answers.map((item, index) => (
          <div key={index} className="bg-white p-4 rounded-lg shadow">
            <p className="font-medium text-gray-700 mb-2">Q: {item.question}</p>
            <p className="text-gray-600">A: {item.answer}</p>
          </div>
        ))}
      </div>
    </div>
  );
} 

----- /Users/jackcrawford/ai-design-flow/components/CanvasTree.tsx -----
// components/CanvasTree.tsx
import React from 'react';
import { QANode } from '@/types'; // if you're using a separate types file

interface CanvasTreeProps {
  node: QANode | null;
  depth?: number;
  isRoot?: boolean;
}

const CanvasTree: React.FC<CanvasTreeProps> = ({ node, depth = 0, isRoot = true }) => {
  if (!node) return null;

  const isPromptNode = node.question.startsWith('Prompt:');

  return (
    <div style={{ marginLeft: depth * 16 }} className="mb-4">
      <div className={`p-2 border rounded mb-2 ${isPromptNode ? 'bg-gray-50' : 'bg-white'} shadow`}>
        <p className={`${isPromptNode ? 'font-semibold text-gray-900' : 'font-medium text-gray-900'}`}>
          {isPromptNode ? (
            node.question
          ) : (
            <>
              <span className="text-blue-600 font-semibold">Q{node.questionNumber}: </span>
              {node.question}
            </>
          )}
        </p>
        {!isPromptNode && node.answer && (
          <p className="text-gray-800 mt-1">
            <span className="text-blue-600 font-semibold">A{node.questionNumber}: </span>
            {node.answer}
          </p>
        )}
      </div>
      {node.children?.map((child: QANode) => (
        <CanvasTree key={child.id} node={child} depth={depth + 1} isRoot={false} />
      ))}
    </div>
  );
};

export default CanvasTree;


----- /Users/jackcrawford/ai-design-flow/components/HeaderToolbar.tsx -----
import Link from 'next/link';

interface HeaderToolbarProps {
  onRestart?: () => void;
  showRestartButton?: boolean;
}

const HeaderToolbar: React.FC<HeaderToolbarProps> = ({ onRestart, showRestartButton = false }) => {
  return (
    <header className="bg-white border-b border-gray-200">
      <div className="w-full px-2">
        <div className="flex justify-between items-center h-16 max-w-[1920px] mx-auto">
          <div className="pl-2">
            <Link href="/" className="text-xl font-bold text-gray-900 hover:text-gray-700 transition-colors">
              AI Design Flow
            </Link>
          </div>
          <div className="pr-2">
            {showRestartButton && onRestart && (
              <button
                onClick={onRestart}
                className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
              >
                Restart Q&A
              </button>
            )}
          </div>
        </div>
      </div>
    </header>
  );
};

export default HeaderToolbar; 

----- /Users/jackcrawford/ai-design-flow/components/PreviewArea.tsx -----
interface PreviewAreaProps {
  requirements: string;
  uiCode: string;
}

export default function PreviewArea({ requirements, uiCode }: PreviewAreaProps) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
      <div className="bg-white rounded-lg p-6 shadow-lg">
        <h2 className="text-xl font-semibold mb-4">Requirements</h2>
        <pre className="whitespace-pre-wrap font-mono text-sm bg-gray-50 p-4 rounded">
          {requirements}
        </pre>
      </div>
      <div className="bg-white rounded-lg p-6 shadow-lg">
        <h2 className="text-xl font-semibold mb-4">Generated UI Code</h2>
        <pre className="whitespace-pre-wrap font-mono text-sm bg-gray-50 p-4 rounded overflow-auto">
          {uiCode}
        </pre>
      </div>
    </div>
  );
} 

----- /Users/jackcrawford/ai-design-flow/components/PromptInput.tsx -----
// components/PromptInput.tsx
import React, { useState, ChangeEvent } from 'react';
import { QASettings, KnowledgeBaseSource } from '@/types/settings';
import { v4 as uuidv4 } from 'uuid';

interface PromptInputProps {
  onSubmit: (prompt: string, settings: QASettings) => void;
}

const PromptInput: React.FC<PromptInputProps> = ({ onSubmit }) => {
  const [prompt, setPrompt] = useState('');
  const [showSettings, setShowSettings] = useState(false);
  const [settings, setSettings] = useState<QASettings>({
    traversalMode: 'bfs',
    unknownHandling: 'auto',
    conflictResolution: 'auto',
    knowledgeBase: []
  });
  const [isProcessingFile, setIsProcessingFile] = useState(false);
  const [pastedContent, setPastedContent] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (prompt.trim()) {
      setShowSettings(true);
    }
  };

  const handleStartQA = () => {
    onSubmit(prompt, settings);
  };

  const processKnowledgeBase = async (type: 'file' | 'text', data: File | string, name: string) => {
    try {
      setIsProcessingFile(true);
      const formData = new FormData();
      formData.append('type', type);
      
      if (type === 'file') {
        formData.append('file', data as File);
      } else {
        formData.append('content', data as string);
      }

      const response = await fetch('/api/process-knowledge-base', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error('Failed to process knowledge base');
      }

      const result = await response.json();
      
      const newSource: KnowledgeBaseSource = {
        id: uuidv4(),
        type,
        name,
        ...(type === 'file' ? { file: data as File } : { content: data as string }),
        processedContent: result.processedContent
      };

      setSettings(prev => ({
        ...prev,
        knowledgeBase: [...(prev.knowledgeBase || []), newSource]
      }));
    } catch (error) {
      console.error('Error processing knowledge base:', error);
      // You might want to show an error message to the user here
    } finally {
      setIsProcessingFile(false);
    }
  };

  const handleFileUpload = async (file: File) => {
    await processKnowledgeBase('file', file, file.name);
  };

  const handleTextAdd = async () => {
    if (pastedContent.trim()) {
      await processKnowledgeBase('text', pastedContent, `Pasted content ${new Date().toLocaleString()}`);
      setPastedContent('');
    }
  };

  const removeKnowledgeSource = (id: string) => {
    setSettings(prev => ({
      ...prev,
      knowledgeBase: prev.knowledgeBase?.filter(source => source.id !== id)
    }));
  };

  const handleSettingChange = (
    setting: keyof QASettings,
    value: string | number | { file: File; processedContent: any } | undefined
  ) => {
    setSettings(prev => ({
      ...prev,
      [setting]: value
    }));
  };

  if (showSettings) {
    return (
      <div className="p-8 w-full max-w-2xl">
        <div className="mb-6">
          <h3 className="text-xl font-bold text-gray-900 mb-2">Your Prompt:</h3>
          <p className="text-gray-700 bg-gray-50 p-4 rounded-lg">{prompt}</p>
          <button
            onClick={() => setShowSettings(false)}
            className="mt-2 text-blue-600 hover:text-blue-700 text-sm"
          >
            Edit Prompt
          </button>
        </div>
        <div className="space-y-6">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Traversal Mode
            </label>
            <div className="flex gap-4">
              <label className="flex items-center">
                <input
                  type="radio"
                  name="traversalMode"
                  value="bfs"
                  checked={settings.traversalMode === 'bfs'}
                  onChange={(e) => handleSettingChange('traversalMode', e.target.value)}
                  className="mr-2"
                />
                <span className="text-gray-900">Breadth-First</span>
              </label>
              <label className="flex items-center">
                <input
                  type="radio"
                  name="traversalMode"
                  value="dfs"
                  checked={settings.traversalMode === 'dfs'}
                  onChange={(e) => handleSettingChange('traversalMode', e.target.value)}
                  className="mr-2"
                />
                <span className="text-gray-900">Depth-First</span>
              </label>
            </div>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Unknown Handling
            </label>
            <select 
              className="w-full border border-gray-300 rounded-lg p-2 text-gray-900 bg-white"
              value={settings.unknownHandling}
              onChange={(e) => handleSettingChange('unknownHandling', e.target.value)}
            >
              <option value="auto">Auto (trivial)</option>
              <option value="prompt">Always Prompt</option>
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Conflict Resolution
            </label>
            <select 
              className="w-full border border-gray-300 rounded-lg p-2 text-gray-900 bg-white"
              value={settings.conflictResolution}
              onChange={(e) => handleSettingChange('conflictResolution', e.target.value)}
            >
              <option value="auto">Auto-resolve Minor</option>
              <option value="manual">Manual Resolution</option>
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Maximum Questions
            </label>
            <input
              type="number"
              min="1"
              placeholder="Optional"
              className="w-full border border-gray-300 rounded-lg p-2 text-gray-900 bg-white"
              value={settings.maxQuestions || ''}
              onChange={(e) => handleSettingChange('maxQuestions', e.target.value ? parseInt(e.target.value) : undefined)}
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Knowledge Base Sources
            </label>
            <div className="space-y-4">
              {/* File Upload */}
              <div className="space-y-2">
                <input
                  type="file"
                  className="w-full text-gray-900 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
                  accept=".pdf,.doc,.docx,.txt"
                  onChange={(e: ChangeEvent<HTMLInputElement>) => {
                    const file = e.target.files?.[0];
                    if (file) {
                      handleFileUpload(file);
                    }
                  }}
                  disabled={isProcessingFile}
                />
                <p className="text-xs text-gray-500">
                  Supported formats: PDF, DOC, DOCX, TXT
                </p>
              </div>

              {/* Text Input */}
              <div className="space-y-2">
                <textarea
                  value={pastedContent}
                  onChange={(e) => setPastedContent(e.target.value)}
                  placeholder="Paste additional content here..."
                  className="w-full h-32 p-3 border rounded-lg resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
                  disabled={isProcessingFile}
                />
                <button
                  onClick={handleTextAdd}
                  disabled={!pastedContent.trim() || isProcessingFile}
                  className="px-4 py-2 text-sm bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors disabled:bg-gray-400"
                >
                  Add Text Content
                </button>
              </div>

              {/* Processing Indicator */}
              {isProcessingFile && (
                <div className="flex items-center space-x-2 text-sm text-gray-600">
                  <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
                  <span>Processing content...</span>
                </div>
              )}

              {/* Knowledge Base List */}
              {settings.knowledgeBase && settings.knowledgeBase.length > 0 && (
                <div className="mt-4">
                  <h4 className="text-sm font-medium text-gray-700 mb-2">Added Sources:</h4>
                  <div className="space-y-2">
                    {settings.knowledgeBase.map((source) => (
                      <div
                        key={source.id}
                        className="flex items-center justify-between p-2 bg-gray-50 rounded-lg"
                      >
                        <div className="flex items-center space-x-2">
                          <span className="text-sm text-gray-600">
                            {source.type === 'file' ? '📄' : '📝'}
                          </span>
                          <span className="text-sm text-gray-800">{source.name}</span>
                        </div>
                        <button
                          onClick={() => removeKnowledgeSource(source.id)}
                          className="text-red-600 hover:text-red-700"
                        >
                          ✕
                        </button>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          </div>

          <button
            onClick={handleStartQA}
            className="w-full bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium"
          >
            Start Q&A
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="p-8 w-full max-w-2xl">
      <form onSubmit={handleSubmit} className="flex flex-col gap-4">
        <label htmlFor="prompt" className="text-xl font-bold text-gray-900">
          Enter your design prompt:
        </label>
        <textarea
          id="prompt"
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          placeholder="Design the interface for a 1000-floor elevator"
          className="border border-gray-300 p-4 rounded-lg h-48 text-gray-900 text-base resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white"
        />
        <button 
          type="submit" 
          className="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium"
        >
          Configure Settings
        </button>
      </form>
    </div>
  );
};

export default PromptInput;

----- /Users/jackcrawford/ai-design-flow/components/QAPanel.tsx -----
import { useState } from 'react';

interface SuggestedAnswer {
  text: string;
  confidence: 'high' | 'medium' | 'low';
  sourceReferences?: number[];
}

interface QAPanelProps {
  currentQuestion: string;
  onSubmitAnswer: (answer: string) => void;
  isLoading: boolean;
  hasKnowledgeBase: boolean;
  onAutoPopulate: () => Promise<string | null>;
  suggestedAnswer?: SuggestedAnswer | null;
}

export default function QAPanel({ 
  currentQuestion, 
  onSubmitAnswer, 
  isLoading,
  hasKnowledgeBase,
  onAutoPopulate,
  suggestedAnswer
}: QAPanelProps) {
  const [answer, setAnswer] = useState('');
  const [isAutoPopulating, setIsAutoPopulating] = useState(false);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (answer.trim()) {
      onSubmitAnswer(answer);
      setAnswer('');
    }
  };

  const handleAutoPopulate = async () => {
    setIsAutoPopulating(true);
    try {
      const suggestedAnswer = await onAutoPopulate();
      if (suggestedAnswer) {
        setAnswer(suggestedAnswer);
      } else {
        alert('No relevant information found in the knowledge base. Please provide your expert answer.');
      }
    } catch (error) {
      console.error('Error generating answer:', error);
      alert('There was an error accessing the knowledge base. Please provide your answer manually.');
    } finally {
      setIsAutoPopulating(false);
    }
  };

  return (
    <div className="bg-white rounded-lg p-6 shadow-lg">
      <div className="mb-6">
        <h3 className="text-lg font-semibold text-gray-900 mb-2">Current Question:</h3>
        {isLoading ? (
          <div className="flex items-center space-x-2">
            <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
            <p className="text-gray-600">Loading question...</p>
          </div>
        ) : (
          <p className="text-gray-800">{currentQuestion}</p>
        )}
      </div>

      {suggestedAnswer && (
        <div className="mb-4 p-4 rounded-lg border border-gray-200">
          <div className="flex-1">
            <div className="flex items-center gap-2 mb-1">
              <h4 className="text-sm font-medium">Suggested Answer</h4>
              <span className={`text-xs px-2 py-0.5 rounded-full ${
                suggestedAnswer.confidence === 'high' 
                  ? 'bg-green-100 text-green-800'
                  : suggestedAnswer.confidence === 'medium'
                  ? 'bg-yellow-100 text-yellow-800'
                  : 'bg-gray-100 text-gray-800'
              }`}>
                {suggestedAnswer.confidence} confidence
              </span>
            </div>
            <p className="text-sm">{suggestedAnswer.text}</p>
            {suggestedAnswer.sourceReferences && suggestedAnswer.sourceReferences.length > 0 && (
              <p className="text-xs mt-2 text-gray-600">
                Sources: {suggestedAnswer.sourceReferences.map(ref => `#${ref + 1}`).join(', ')}
              </p>
            )}
            <button
              onClick={handleAutoPopulate}
              className="mt-3 w-full px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
            >
              Use This Answer
            </button>
          </div>
        </div>
      )}

      <form onSubmit={handleSubmit}>
        <div className="space-y-4">
          {hasKnowledgeBase && (
            <button
              type="button"
              onClick={handleAutoPopulate}
              disabled={isLoading || isAutoPopulating}
              className={`w-full px-4 py-2 rounded-lg transition-colors ${
                isLoading || isAutoPopulating
                  ? 'bg-gray-400 cursor-not-allowed'
                  : 'bg-green-600 hover:bg-green-700'
              } text-white flex items-center justify-center gap-2`}
            >
              {isAutoPopulating ? (
                <>
                  <div className="animate-spin rounded-full h-4 w-4 border-2 border-white border-t-transparent"></div>
                  <span>Finding Best Answer...</span>
                </>
              ) : (
                <>
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
                  </svg>
                  <span>Get Suggested Answer</span>
                </>
              )}
            </button>
          )}
          
          <textarea
            value={answer}
            onChange={(e) => setAnswer(e.target.value)}
            className="w-full h-32 p-3 border rounded-lg resize-none focus:ring-2 focus:ring-blue-500 focus:border-transparent text-gray-900"
            placeholder="Type your answer or use the suggestion button above..."
            disabled={isLoading || isAutoPopulating}
          />
          <button
            type="submit"
            className={`w-full px-4 py-2 rounded-lg transition-colors ${
              isLoading || isAutoPopulating || !answer.trim()
                ? 'bg-gray-400 cursor-not-allowed'
                : 'bg-blue-600 hover:bg-blue-700'
            } text-white`}
            disabled={isLoading || isAutoPopulating || !answer.trim()}
          >
            Submit Answer
          </button>
        </div>
      </form>
    </div>
  );
} 

----- /Users/jackcrawford/ai-design-flow/types/index.ts -----
export interface QANode {
  id: string;
  question: string;
  answer?: string;
  children: QANode[];
  questionNumber?: number;
}

export interface RequirementCategory {
  title: string;
  requirements: Array<{
    id: string;
    text: string;
    source: 'user-qa' | 'knowledge-base';
    sourceDetails?: {
      questionId?: string;
      knowledgeBaseIndex?: number;
    };
    priority: 'high' | 'medium' | 'low';
    category: 'functional' | 'technical' | 'ux' | 'accessibility' | 'security' | 'performance';
    tags: string[];
    createdAt: string;
    updatedAt: string;
  }>;
}

export interface RequirementsDocument {
  id: string;
  prompt: string;
  lastUpdated: string;
  categories: {
    basicNeeds: RequirementCategory;
    functionalRequirements: RequirementCategory;
    userExperience: RequirementCategory;
    implementation: RequirementCategory;
    refinements: RequirementCategory;
    constraints: RequirementCategory;
  };
} 

----- /Users/jackcrawford/ai-design-flow/types/pdf-parse.d.ts -----
declare module 'pdf-parse' {
  interface PDFData {
    text: string;
    numpages: number;
    info: any;
    metadata: any;
    version: string;
  }

  function PDFParse(dataBuffer: Buffer, options?: any): Promise<PDFData>;
  export = PDFParse;
} 

----- /Users/jackcrawford/ai-design-flow/types/settings.ts -----
export interface KnowledgeBaseSource {
  id: string;
  type: 'file' | 'text';
  name: string;
  content?: string;
  file?: File;
  processedContent?: {
    requirements?: string[];
    technicalSpecifications?: string[];
    designGuidelines?: string[];
    userPreferences?: string[];
    industryStandards?: string[];
    [key: string]: any;
  };
}

export interface QASettings {
  traversalMode: 'bfs' | 'dfs';
  unknownHandling: 'auto' | 'prompt';
  conflictResolution: 'auto' | 'manual';
  maxQuestions?: number;
  knowledgeBase?: KnowledgeBaseSource[];
} 

----- /Users/jackcrawford/ai-design-flow/.env.local -----
OPENAI_API_KEY=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 

----- /Users/jackcrawford/ai-design-flow/.gitignore -----
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts


----- /Users/jackcrawford/ai-design-flow/next-env.d.ts -----
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


----- /Users/jackcrawford/ai-design-flow/next.config.ts -----
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  experimental: {
    serverActions: {
      bodySizeLimit: '2mb'
    }
  },
  serverExternalPackages: ['pdf-parse']
};

export default nextConfig;


----- /Users/jackcrawford/ai-design-flow/package.json -----
{
  "name": "ai-design-flow",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@langchain/community": "^0.3.29",
    "@langchain/openai": "^0.4.2",
    "langchain": "^0.3.15",
    "next": "15.1.6",
    "openai": "^4.83.0",
    "pdf-parse": "^1.1.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "uuid": "^11.0.5"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.1.6",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}


----- /Users/jackcrawford/ai-design-flow/tailwind.config.ts -----
import type { Config } from "tailwindcss";

export default {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        background: "var(--background)",
        foreground: "var(--foreground)",
      },
    },
  },
  plugins: [],
} satisfies Config;


----- /Users/jackcrawford/ai-design-flow/tsconfig.json -----
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


